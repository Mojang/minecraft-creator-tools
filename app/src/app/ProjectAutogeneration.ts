import WorldTestManager from "../script/WorldTestManager";
import { ProjectItemCreationType, ProjectItemStorageType, ProjectItemType } from "./IProjectItemData";
import Project, { AUTOGENERATED_CONTENT_TOKEN, AUTOGENERATED_JS_SEPARATOR, FolderContext } from "./Project";
import ProjectItem from "./ProjectItem";
import Log from "../core/Log";
import { ProjectScriptLanguage } from "./IProjectData";
import StorageUtilities from "../storage/StorageUtilities";
import EntityTypeDefinition from "../minecraft/EntityTypeDefinition";
import BehaviorManifestDefinition from "../minecraft/BehaviorManifestDefinition";
import EnvSettings from "../devproject/EnvSettings";
import VsCodeLaunchDefinition from "../devproject/VsCodeLaunchDefinition";
import VsCodeTasksDefinition from "../devproject/VsCodeTasksDefinition";
import VsCodeExtensionsDefinition from "../devproject/VsCodeExtensionsDefinition";
import VsCodeSettingsDefinition from "../devproject/VsCodeSettingsDefinition";
import PrettierRcConfig from "../devproject/PrettierRcConfig";
import JustConfig from "../devproject/JustConfig";
import NpmPackageDefinition from "../devproject/NpmPackageDefinition";

export default class ProjectAutogeneration {
  static async updateProjectAutogeneration(project: Project) {
    let packageItems = 0;
    let envItems = 0;
    let justConfigItems = 0;
    let needsJustConfig = false;
    let needsEslintConfig = false;
    let eslintConfigItems = 0;
    let vsCodeLaunchItems = 0;
    let vsCodeExtensionsItems = 0;
    let vsCodeSettingsItems = 0;
    let vsCodeTasksItems = 0;
    let prettierRcItems = 0;

    const items = project.getItemsCopy();

    for (let i = 0; i < items.length; i++) {
      const item = items[i];

      if (item.itemType === ProjectItemType.packageJson) {
        packageItems++;

        const itemFile = item.primaryFile;
        if (itemFile) {
          if (!itemFile.isContentLoaded) {
            await itemFile.loadContent();
          }

          if (itemFile.content && typeof itemFile.content === "string") {
            if (itemFile.content.indexOf("just-scripts") > 0) {
              needsJustConfig = true;
            }
            if (itemFile.content.indexOf("eslint") > 0) {
              needsEslintConfig = true;
            }
          }
        }
      } else if (item.itemType === ProjectItemType.env) {
        envItems++;
      } else if (item.itemType === ProjectItemType.vsCodeLaunchJson) {
        vsCodeLaunchItems++;
      } else if (item.itemType === ProjectItemType.prettierRcJson) {
        prettierRcItems++;
      } else if (item.itemType === ProjectItemType.esLintConfigMjs) {
        eslintConfigItems++;
      } else if (item.itemType === ProjectItemType.justConfigTs) {
        justConfigItems++;
      }
    }

    if (envItems === 0 && (justConfigItems > 0 || needsJustConfig)) {
      project.ensureItemByProjectPath(
        "/.env",
        ProjectItemStorageType.singleFile,
        ".env",
        ProjectItemType.env,
        FolderContext.unknown,
        undefined,
        ProjectItemCreationType.generated
      );
    }

    if (prettierRcItems === 0 && packageItems > 0) {
      project.ensureItemByProjectPath(
        "/.prettierrc.json",
        ProjectItemStorageType.singleFile,
        ".prettierrc.json",
        ProjectItemType.prettierRcJson,
        FolderContext.unknown,
        undefined,
        ProjectItemCreationType.generated
      );
    }

    if (justConfigItems === 0 && needsJustConfig) {
      project.ensureItemByProjectPath(
        "/just.config.ts",
        ProjectItemStorageType.singleFile,
        "just.config.ts",
        ProjectItemType.justConfigTs,
        FolderContext.unknown,
        undefined,
        ProjectItemCreationType.generated
      );
    }

    if (eslintConfigItems === 0 && needsEslintConfig) {
      project.ensureItemByProjectPath(
        "/eslint.config.mjs",
        ProjectItemStorageType.singleFile,
        "eslint.config.mjs",
        ProjectItemType.esLintConfigMjs,
        FolderContext.unknown,
        undefined,
        ProjectItemCreationType.generated
      );
    }

    if (vsCodeLaunchItems === 0 && packageItems > 0 && project.projectFolder) {
      project.ensureItemByProjectPath(
        "/.vscode/launch.json",
        ProjectItemStorageType.singleFile,
        "launch.json",
        ProjectItemType.vsCodeLaunchJson,
        FolderContext.unknown,
        undefined,
        ProjectItemCreationType.generated
      );
    }

    if (vsCodeSettingsItems === 0 && packageItems > 0 && project.projectFolder) {
      project.ensureItemByProjectPath(
        "/.vscode/settings.json",
        ProjectItemStorageType.singleFile,
        "settings.json",
        ProjectItemType.vsCodeSettingsJson,
        FolderContext.unknown,
        undefined,
        ProjectItemCreationType.generated
      );
    }

    if (vsCodeTasksItems === 0 && packageItems > 0 && project.projectFolder) {
      project.ensureItemByProjectPath(
        "/.vscode/tasks.json",
        ProjectItemStorageType.singleFile,
        "tasks.json",
        ProjectItemType.vsCodeTasksJson,
        FolderContext.unknown,
        undefined,
        ProjectItemCreationType.generated
      );
    }

    if (vsCodeExtensionsItems === 0 && packageItems > 0 && project.projectFolder) {
      project.ensureItemByProjectPath(
        "/.vscode/extensions.json",
        ProjectItemStorageType.singleFile,
        "extensions.json",
        ProjectItemType.vsCodeExtensionsJson,
        FolderContext.unknown,
        undefined,
        ProjectItemCreationType.generated
      );
    }

    for (let i = 0; i < items.length; i++) {
      const item = items[i];

      if (item.creationType === ProjectItemCreationType.generated) {
        await ProjectAutogeneration.updateItemAutogeneration(item);
      }

      await ProjectAutogeneration.updateItemAutogeneratedSideFiles(item);
    }
  }

  static async updateItemAutogeneratedSideFiles(item: ProjectItem) {
    if (!item.primaryFile || !item.project) {
      return;
    }

    if (item.itemType === ProjectItemType.worldTest) {
      const worldTestManager = await WorldTestManager.ensureOnFile(item.primaryFile);

      if (worldTestManager) {
        await worldTestManager.persistSideFiles(item.project);
      }
    }
  }

  static async updateItemAutogeneration(item: ProjectItem, contentOnlyUpdate?: boolean) {
    if (!contentOnlyUpdate && !item.isContentLoaded) {
      await item.loadContent();
    }

    if (item.primaryFile == null || item.creationType !== ProjectItemCreationType.generated) {
      return;
    }

    if (item.itemType === ProjectItemType.catalogIndexJs) {
      if (!item.primaryFile.isContentLoaded) {
        await item.primaryFile.loadContent();
      }

      ProjectAutogeneration.updateCatalogJsContent(item, await ProjectAutogeneration.getCatalogJsContent(item.project));
    } else if (item.itemType === ProjectItemType.env) {
      item.primaryFile.setContent(
        await EnvSettings.getContent(
          item.project,
          typeof item.primaryFile.content === "string" ? item.primaryFile.content : undefined
        )
      );
    } else if (item.itemType === ProjectItemType.justConfigTs) {
      const justConfigTs = await JustConfig.ensureOnFile(item.primaryFile);

      if (justConfigTs) {
        await justConfigTs.ensureDefault();
        await justConfigTs.save();
      }
    } else if (item.itemType === ProjectItemType.vsCodeLaunchJson) {
      const vscodelaunch = await VsCodeLaunchDefinition.ensureOnFile(item.primaryFile);

      if (vscodelaunch) {
        await vscodelaunch.ensureMinContent();
        await vscodelaunch.save();
      }
    } else if (item.itemType === ProjectItemType.vsCodeTasksJson) {
      const vscodetasks = await VsCodeTasksDefinition.ensureOnFile(item.primaryFile);

      if (vscodetasks) {
        await vscodetasks.ensureMinContent();
        await vscodetasks.save();
      }
    } else if (item.itemType === ProjectItemType.vsCodeExtensionsJson) {
      const vscodeextensions = await VsCodeExtensionsDefinition.ensureOnFile(item.primaryFile);

      if (vscodeextensions) {
        await vscodeextensions.ensureMinContent();
        await vscodeextensions.save();
      }
    } else if (item.itemType === ProjectItemType.vsCodeSettingsJson) {
      const vscodesettings = await VsCodeSettingsDefinition.ensureOnFile(item.primaryFile);

      if (vscodesettings) {
        await vscodesettings.ensureMinContent();
        await vscodesettings.save();
      }
    } else if (item.itemType === ProjectItemType.prettierRcJson) {
      const prettierrc = await PrettierRcConfig.ensureOnFile(item.primaryFile);

      if (prettierrc) {
        await prettierrc.ensureMinContent();
        await prettierrc.save();
      }
    } else if (item.itemType === ProjectItemType.packageJson) {
      const packageJson = await NpmPackageDefinition.ensureOnFile(item.primaryFile);

      if (packageJson) {
        await packageJson.ensureMinContent(item.project);
        await packageJson.save();
      }
    } else if (item.itemType === ProjectItemType.behaviorPackManifestJson) {
      item.primaryFile.setContent(await BehaviorManifestDefinition.getContent(item.project, contentOnlyUpdate));
    } else if (item.itemType === ProjectItemType.entityTypeBaseJs) {
      const content = await ProjectAutogeneration.getGeneratedEntityTypeScript(item);

      if (content.javaScript !== undefined) {
        item.primaryFile.setContent(content.javaScript);
      }
      if (
        item.project.preferredScriptLanguage === ProjectScriptLanguage.typeScript &&
        content.typeScript !== undefined
      ) {
        const file = item.primaryFile.parentFolder.ensureFile(
          StorageUtilities.getBaseFromName(item.primaryFile.name) + ".ts"
        );

        file.setContent(content.typeScript);
      }

      if (
        item.project.preferredScriptLanguage === ProjectScriptLanguage.typeScript &&
        content.typeScript !== undefined
      ) {
        const file = item.primaryFile.parentFolder.ensureFile(
          StorageUtilities.getBaseFromName(item.primaryFile.name) + ".ts"
        );

        file.setContent(content.typeScript);
      }
    } else if (item.itemType === ProjectItemType.entityTypeBaseTs) {
      const content = await ProjectAutogeneration.getGeneratedEntityTypeScript(item);

      if (content.typeScript !== undefined) {
        item.primaryFile.setContent(content.typeScript);
      }
    }
  }

  static async getCatalogJsContent(project: Project) {
    const content: string[] = [];

    const behaviorPackRootFolder = await project.ensureDefaultBehaviorPackFolder();

    const items = project.getItemsCopy();

    for (let i = 0; i < items.length; i++) {
      const projectItem = items[i];

      if (projectItem.itemType === ProjectItemType.worldTest) {
        const file = await projectItem.loadFileContent();

        if (file) {
          const newFileName = StorageUtilities.getBaseFromName(file.name) + ".gen.js";

          content.push('import "scripts/' + newFileName + '";');
        }
      } else if (
        projectItem.itemType === ProjectItemType.js ||
        projectItem.itemType === ProjectItemType.buildProcessedJs ||
        projectItem.itemType === ProjectItemType.entityTypeBaseJs ||
        projectItem.itemType === ProjectItemType.testJs
      ) {
        const file = await projectItem.loadFileContent();

        if (file) {
          let filePath = file.getFolderRelativePath(behaviorPackRootFolder);

          if (!file.isContentLoaded) {
            await file.loadContent(false);
          }

          if ((file.content !== null || filePath !== null) && filePath !== undefined) {
            if (filePath.startsWith("/scripts/")) {
              filePath = filePath.substring(9, filePath.length);
            }

            if (filePath.startsWith("/")) {
              filePath = filePath.substring(1, filePath.length);
            }

            content.push('import "' + filePath + '";');
          }
        }
      }
    }

    return AUTOGENERATED_JS_SEPARATOR + "\n\n" + content.join("\n");
  }

  static async updateCatalogJsContent(item: ProjectItem, newContent: string) {
    if (item.primaryFile == null || item.primaryFile.content instanceof Uint8Array) {
      Log.unexpectedContentState();
      return;
    }

    if (
      item.primaryFile.content === undefined ||
      item.primaryFile.content === null ||
      item.primaryFile.content.trim() === ""
    ) {
      item.primaryFile.setContent(newContent);
      return;
    }

    let updatedContent = item.primaryFile.content;

    const autogenToken = updatedContent.indexOf(AUTOGENERATED_CONTENT_TOKEN);

    if (autogenToken >= 0) {
      let previous = updatedContent.lastIndexOf("\r", autogenToken);

      if (previous < 0) {
        previous = updatedContent.lastIndexOf("\n", autogenToken);

        if (previous < 0) {
          previous = 0;
        }
      }

      const previousComment = updatedContent.lastIndexOf("//", autogenToken);

      // we expect \n//, but if for some reason the comment has moved, let's only strip from the comment forward.
      if (previousComment > previous + 2) {
        previous = previousComment;
      }

      if (previous >= 0) {
        updatedContent = updatedContent.substring(0, previous);
      }
    }

    updatedContent += newContent;

    item.primaryFile.setContent(updatedContent);
  }

  static async getGeneratedEntityTypeScript(item: ProjectItem) {
    if (item.projectPath === null || item.projectPath === undefined) {
      return { javaScript: "", typeScript: undefined };
    }

    let typeName = StorageUtilities.getBaseFromName(StorageUtilities.getLeafName(item.projectPath));

    if (typeName.endsWith(".base")) {
      typeName = typeName.substring(0, typeName.length - 5);
    }

    const items = item.project.getItemsCopy();

    for (let i = 0; i < items.length; i++) {
      const candItem = items[i];

      if (
        candItem.itemType === ProjectItemType.entityTypeBehavior &&
        candItem.projectPath !== null &&
        candItem.projectPath !== undefined
      ) {
        const jsonName = StorageUtilities.getBaseFromName(StorageUtilities.getLeafName(candItem.projectPath));

        if (jsonName === typeName) {
          const jsonFile = await candItem.loadFileContent();

          if (jsonFile !== undefined && jsonFile !== null) {
            if (jsonFile.manager === undefined) {
              await EntityTypeDefinition.ensureOnFile(jsonFile);
            }

            if (jsonFile.manager) {
              const et = jsonFile.manager as EntityTypeDefinition;

              const js = et.getScript(false);
              let ts = undefined;

              if (item.project.preferredScriptLanguage === ProjectScriptLanguage.typeScript) {
                ts = et.getScript(true);
              }

              return { javaScript: js, typeScript: ts };
            }
          }
        }
      }
    }

    return { javaScript: "", typeScript: undefined };
  }
}
