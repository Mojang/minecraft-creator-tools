// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import IFile from "../storage/IFile";
import IFolder from "../storage/IFolder";
import Carto from "./Carto";
import IProjectData, {
  ProjectEditPreference,
  ProjectRole,
  ProjectScriptLanguage,
  ProjectScriptVersion,
} from "./IProjectData";
import { ProjectDataType, ProjectFocus } from "./IProjectData";
import ProjectItem from "./ProjectItem";
import IProjectItemData, { ProjectItemCreationType, ProjectItemStorageType, ProjectItemType } from "./IProjectItemData";
import Utilities from "./../core/Utilities";
import { EventDispatcher } from "ste-events";
import StorageUtilities from "../storage/StorageUtilities";
import GitHubStorage from "../github/GitHubStorage";
import Log from "../core/Log";
import DifferenceSet from "../storage/DifferenceSet";
import IProjectScriptState from "./IProjectScriptState";
import ProjectUtilities from "./ProjectUtilities";
import IStorage, { IFolderMove } from "../storage/IStorage";
import { GameType, Generator } from "../minecraft/WorldLevelDat";
import { BackupType } from "../minecraft/IWorldSettings";
import BehaviorManifestDefinition from "../minecraft/BehaviorManifestDefinition";
import MinecraftUtilities from "../minecraft/MinecraftUtilities";
import LocManager from "../minecraft/LocManager";
import ProjectInfoSet from "../info/ProjectInfoSet";
import ProjectUpdateRunner from "../updates/ProjectUpdateRunner";
import ProjectUpdateResult from "../updates/ProjectUpdateResult";
import { StatusTopic, StatusType } from "./Status";
import { ProjectInfoSuite } from "../info/IProjectInfoData";
import Pack, { PackType } from "../minecraft/Pack";
import { IErrorable } from "../core/IErrorable";
import ProjectDeploySync from "./ProjectDeploySync";
import { MinecraftTrack } from "./ICartoData";
import ProjectItemRelations from "./ProjectItemRelations";
import ResourceManifestDefinition from "../minecraft/ResourceManifestDefinition";
import ISimpleReference from "../core/ISimpleReference";
import ProjectLookupUtilities from "./ProjectLookupUtilities";
import ProjectVariant from "./ProjectVariant";
import { ProjectItemVariantType } from "./IProjectItemVariant";
import ProjectItemInference from "./ProjectItemInference";

export enum ProjectAutoDeploymentMode {
  deployOnSave = 0,
  noAutoDeployment = 1,
}

export enum ProjectErrorState {
  noError = 0,
  projectFolderOrFileDoesNotExist = 1,
  cabinetFileCouldNotBeProcessed = 2,
}

export enum FolderContext {
  unknown = 0,
  behaviorPack = 1,
  resourcePack = 2,
  skinPack = 3,
  docs = 4,
  world = 5,
  typeDefs = 6,
  distBuildFolder = 7,
  vscodeFolder = 8,
  resourcePackSubPack = 9,
  metaData = 10,
  libFolder = 11,
  persona = 12,
  mctoolsWorkingFolder = 13,
  designPack = 14,
}

export const ProjectTargetStrings = [
  "<default>",
  "Latest Minecraft Bedrock",
  "Latest Minecraft Bedrock preview",
  "Latest Minecraft Education",
  "Latest Minecraft Education preview",
];

export const AUTOGENERATED_CONTENT_TOKEN = "==== AUTOGENERATED";
export const AUTOGENERATED_JS_SEPARATOR =
  "\r\n// ===== AUTOGENERATED CONTENT ===== CONTENT AT OR BELOW THIS LINE WILL BE WIPED AND UPDATED WHEN USED IN TOOLING";
export const AUTOGENERATED_WHOLEFILE_JS_SEPARATOR =
  "// ===== AUTOGENERATED FILE ===== CONTENT WITHIN THIS FILE WILL BE WIPED AND UPDATED WHEN USED IN TOOLING";
export const AUTOGENERATED_WHOLEFILE_MCFUNCTION_SEPARATOR =
  "# ===== AUTOGENERATED FILE ===== CONTENT WITHIN THIS FILE WILL BE WIPED AND UPDATED WHEN USED IN TOOLING";
export const AUTOGENERATED_WHOLEFILE_GENERAL_SEPARATOR =
  "===== AUTOGENERATED FILE ===== CONTENT WITHIN THIS FILE WILL BE WIPED AND UPDATED WHEN USED IN TOOLING";

export const minecraftScriptModules: {
  id: string;
  module_name?: string;
  uuid?: string;
  preferredVersion: string | number[];
}[] = [
  { id: "@minecraft/server", module_name: "@minecraft/server", preferredVersion: "1.12.0-beta" },
  { id: "@minecraft/server-gametest", module_name: "@minecraft/server-gametest", preferredVersion: "1.0.0-beta" },
  { id: "@minecraft/server-ui", module_name: "@minecraft/server-ui", preferredVersion: "1.2.0-beta" },
  { id: "@minecraft/server-admin", module_name: "@minecraft/server-admin", preferredVersion: "1.0.0-beta" },
  { id: "@minecraft/server-net", module_name: "@minecraft/server-net", preferredVersion: "1.0.0-beta" },
  { id: "@minecraft/server-editor", module_name: "@minecraft/server-editor", preferredVersion: "0.1.0-beta" },
];

export const remappedMinecraftScriptModules: { [oldModuleName: string]: string } = {
  "mojang-minecraft": "@minecraft/server",
  "mojang-gametest": "@minecraft/server-gametest",
  "mojang-minecraft-ui": "@minecraft/server-ui",
  "mojang-server-admin": "@minecraft/server-admin",
  "mojang-net": "@minecraft/server-net",
  "@minecraft/server-editor-bindings": "@minecraft/server-editor",
};

export default class Project {
  #data: IProjectData;
  #preferencesFile: IFile | null;
  #carto: Carto;
  loc: LocManager;
  #errorState = ProjectErrorState.noError;
  #errorMessage?: string | undefined;
  #infoSet: ProjectInfoSet | null = null;

  #gitHubStorage?: GitHubStorage;

  public differencesFromGitHub?: DifferenceSet;

  #relationsProcessed: boolean = false;

  #folderStructureLoaded: boolean = false;
  #infoSetNeedsUpdating: boolean = false;

  #mainDeployFolder: IFolder | null = null;
  #projectFolder: IFolder | null;
  #projectCabinetFile: IFile | null = null;

  #distBuildFolder: IFolder | null = null;
  #libFolder: IFolder | null = null;

  #distBuildScriptsFolder: IFolder | null = null;
  #libScriptsFolder: IFolder | null = null;

  docsContainer: IFolder | null;

  worldContainer: IFolder | null = null;

  #mainDeploySync: ProjectDeploySync | null = null;

  #isDisposed: boolean = false;

  behaviorPacksContainer: IFolder | null;
  defaultBehaviorPackFolder: IFolder | null;

  skinPacksContainer: IFolder | null;
  defaultSkinPackFolder: IFolder | null;

  personaPacksContainer: IFolder | null;
  defaultPersonaPackFolder: IFolder | null;

  designPacksContainer: IFolder | null;
  defaultDesignPackFolder: IFolder | null;
  projectItemAccessoryFolder: IFolder | null;

  #packs: Pack[] = [];

  defaultWorldFolder: IFolder | null;

  #defaultScriptsFolder: IFolder | null;

  resourcePacksContainer: IFolder | null;
  defaultResourcePackFolder: IFolder | null;

  #items: ProjectItem[];
  #itemsByProjectPath: { [storagePath: string]: ProjectItem | undefined } = {};

  public changedFilesSinceLastSaved: { [storagePath: string]: IFile | undefined } = {};

  #isLoaded = false;
  #isInflated = false;

  #isProjectFolderEnsured = false;
  #useProjectNameInProjectStorage = false;

  #accessoryFilePaths: string[] | undefined;
  #accessoryFoldersForFilePaths: IFolder[] | null = null;

  #accessoryFolders: IFolder[] | null = null;

  private _onPropertyChanged = new EventDispatcher<Project, string>();
  private _onLoaded = new EventDispatcher<Project, Project>();
  private _onInflated = new EventDispatcher<Project, Project>();
  private _onSaved = new EventDispatcher<Project, Project>();
  private _onNeedsSaveChanged = new EventDispatcher<Project, Project>();
  private _onItemChanged = new EventDispatcher<Project, ProjectItem>();
  private _onItemAdded = new EventDispatcher<Project, ProjectItem>();
  private _onItemRemoved = new EventDispatcher<Project, ProjectItem>();

  #isProcessingRelations: boolean = false;
  #pendingProcessingRelationsRequests: ((value: unknown) => void)[] = [];

  public variants: { [label: string]: ProjectVariant };

  hasInferredFiles = false;
  #readOnlySafety = false;

  public get readOnlySafety() {
    return this.#readOnlySafety;
  }

  public set readOnlySafety(newReadOnly: boolean) {
    this.#readOnlySafety = newReadOnly;

    if (this.#projectFolder) {
      this.#projectFolder.storage.readOnly = this.#readOnlySafety;
    }
  }

  public get carto() {
    return this.#carto;
  }

  public get role() {
    if (this.#data.role === undefined) {
      return ProjectRole.general;
    }

    return this.#data.role;
  }

  public set role(newRole: ProjectRole) {
    this.#data.role = newRole;
  }

  public get errorState() {
    return this.#errorState;
  }

  public get errorMessage() {
    return this.#errorMessage;
  }

  public get preferencesFile() {
    return this.#preferencesFile;
  }

  public get accessoryFolders() {
    return this.#accessoryFolders;
  }

  public set accessoryFolders(folders: IFolder[] | null) {
    this.#accessoryFolders = folders;
  }

  public get accessoryFilePaths() {
    return this.#accessoryFilePaths;
  }

  public set accessoryFilePaths(files: string[] | undefined) {
    this.#accessoryFilePaths = files;
  }

  public get infoSet() {
    if (!this.#infoSet) {
      this.#infoSet = new ProjectInfoSet(this, ProjectInfoSuite.default);
    }

    return this.#infoSet;
  }

  public get collapsedStoragePaths() {
    if (!this.#data.collapsedStoragePaths) {
      this.#data.collapsedStoragePaths = [];
    }

    return this.#data.collapsedStoragePaths;
  }

  public set collapsedStoragePaths(newCollapsedPaths: string[]) {
    this.#data.collapsedStoragePaths = newCollapsedPaths;
  }

  public get packs() {
    return this.#packs;
  }

  public hasUnsavedChanges() {
    for (const filePath in this.changedFilesSinceLastSaved) {
      return true;
    }

    return false;
  }

  public getBehaviorPackCount() {
    let count = 0;
    for (const projectItem of this.items) {
      if (projectItem.itemType === ProjectItemType.behaviorPackManifestJson) {
        count++;
      }
    }

    return count;
  }

  public getResourcePackCount() {
    let count = 0;

    for (const projectItem of this.items) {
      if (projectItem.itemType === ProjectItemType.resourcePackManifestJson) {
        count++;
      }
    }

    return count;
  }

  public getIsPackFolderManaged() {
    let rpCount = 0;
    let bpCount = 0;

    for (const projectItem of this.items) {
      if (projectItem.itemType === ProjectItemType.behaviorPackManifestJson) {
        bpCount++;
      } else if (projectItem.itemType === ProjectItemType.resourcePackManifestJson) {
        rpCount++;
      }
    }

    return bpCount < 2 && rpCount < 2;
  }

  public get key() {
    if (this.localFilePath) {
      return StorageUtilities.canonicalizePath(this.localFilePath);
    }

    if (this.#projectFolder) {
      if (this.#projectFolder.name && this.#projectFolder.name.length > 0) {
        return this.#projectFolder.name;
      }

      return StorageUtilities.canonicalizePath(this.#projectFolder.fullPath);
    }

    if (this.#preferencesFile) {
      return StorageUtilities.canonicalizePath(this.#preferencesFile.name);
    }

    return this.title;
  }

  public get containerName() {
    if (this.localFilePath) {
      return StorageUtilities.getLeafName(this.localFilePath);
    }

    if (this.#projectFolder) {
      if (this.#projectFolder.name && this.#projectFolder.name.length > 0) {
        return this.#projectFolder.name;
      }

      return StorageUtilities.getLeafName(this.#projectFolder.fullPath);
    }

    if (this.#preferencesFile) {
      return StorageUtilities.getBaseFromName(this.#preferencesFile.name);
    }

    return this.title;
  }

  public get defaultNamespace(): string | undefined {
    return this.#data.defaultNamespace;
  }

  public get effectiveDefaultNamespace(): string {
    if (this.#data.defaultNamespace || this.#data.defaultNamespace === "") {
      return this.#data.defaultNamespace;
    }

    return this.effectiveShortName;
  }

  public set defaultNamespace(newDefaultNamespace: string | undefined) {
    if (newDefaultNamespace !== this.#data.defaultNamespace) {
      this.#data.defaultNamespace = newDefaultNamespace;

      this._onPropertyChanged.dispatch(this, "defaultNamespace");
    }
  }

  public get scriptEntryPoint(): string {
    if (this.#data.scriptEntryPoint || this.#data.scriptEntryPoint === "") {
      return this.#data.scriptEntryPoint;
    }

    return this.scriptEntryPoint;
  }

  public set scriptEntryPoint(newScriptEntryPoint: string) {
    if (newScriptEntryPoint !== this.#data.scriptEntryPoint) {
      this.#data.scriptEntryPoint = newScriptEntryPoint;

      this._onPropertyChanged.dispatch(this, "scriptEntryPoint");
    }
  }

  public get worldSettings() {
    return this.#data.worldSettings;
  }

  public get editorWorldSettings() {
    return this.#data.editorWorldSettings;
  }

  public get isMinecraftCreator(): boolean {
    return this.#data.creator?.toLowerCase() === "minecraft";
  }

  public async getLookupChoices(lookupId: string): Promise<ISimpleReference[] | undefined> {
    return await ProjectLookupUtilities.getLookup(this, lookupId);
  }

  public ensureWorldSettings() {
    if (this.#data.worldSettings === undefined) {
      if (this.carto.worldSettings) {
        this.#data.worldSettings = this.carto.worldSettings;
      } else {
        this.initializeWorldSettings();

        if (this.#data.worldSettings === undefined) {
          throw new Error();
        }
      }
    }

    return this.#data.worldSettings;
  }

  public ensureEditorWorldSettings() {
    if (this.#data.editorWorldSettings === undefined) {
      if (this.carto.editorWorldSettings) {
        this.#data.editorWorldSettings = this.carto.editorWorldSettings;
      } else {
        this.initializeEditorWorldSettings();

        if (this.#data.editorWorldSettings === undefined) {
          throw new Error();
        }
      }
    }

    return this.#data.editorWorldSettings;
  }

  public get usesCustomWorldSettings() {
    return this.#data.usesCustomWorldSettings;
  }

  public set usesCustomWorldSettings(newValue: boolean | undefined) {
    this.#data.usesCustomWorldSettings = newValue;
  }

  public get isLoaded() {
    return this.#isLoaded;
  }

  public get isInflated() {
    return this.#isInflated;
  }

  public get distBuildFolder() {
    return this.#distBuildFolder;
  }

  public set distBuildFolder(folder: IFolder | null) {
    this.#distBuildFolder = folder;
  }

  public get libFolder() {
    return this.#libFolder;
  }

  public set libFolder(folder: IFolder | null) {
    this.#libFolder = folder;
  }

  public get distScriptsFolder() {
    return this.#distBuildScriptsFolder;
  }

  public get libScriptsFolder() {
    return this.#libScriptsFolder;
  }

  public get useProjectNameInRootProjectStorage() {
    return this.#useProjectNameInProjectStorage;
  }

  public set useProjectNameInRootProjectStorage(newVal: boolean) {
    this.#useProjectNameInProjectStorage = newVal;
  }

  public get onPropertyChanged() {
    return this._onPropertyChanged.asEvent();
  }

  public get onLoaded() {
    return this._onLoaded.asEvent();
  }

  public get onInflated() {
    return this._onInflated.asEvent();
  }

  public get onSaved() {
    return this._onSaved.asEvent();
  }

  public get onNeedsSaveChanged() {
    return this._onNeedsSaveChanged.asEvent();
  }

  public get onItemChanged() {
    return this._onItemChanged.asEvent();
  }

  public get onItemAdded() {
    return this._onItemAdded.asEvent();
  }

  public get onItemRemoved() {
    return this._onItemRemoved.asEvent();
  }

  get projectFolderTitle(): string | undefined {
    return this.#data.projectFolderTitle;
  }

  set projectFolderTitle(newTitle: string | undefined) {
    this.#data.projectFolderTitle = newTitle;
  }

  get projectFolder(): IFolder | null {
    return this.#projectFolder;
  }

  get accessoryFoldersForFilePaths(): IFolder[] | null {
    return this.#accessoryFoldersForFilePaths;
  }

  get localFolderPath(): string | undefined {
    return this.#data.localFolderPath;
  }

  set localFolderPath(newPath: string | undefined) {
    this.#data.localFolderPath = newPath;
  }

  get mainDeployFolderPath(): string | undefined {
    return this.#data.mainDeployFolderPath;
  }

  set mainDeployFolderPath(newPath: string | undefined) {
    this.#data.mainDeployFolderPath = newPath;
  }

  get localFilePath(): string | undefined {
    return this.#data.localFilePath;
  }

  set localFilePath(newPath: string | undefined) {
    this.#data.localFilePath = newPath;
  }

  get items(): ProjectItem[] {
    return this.#items;
  }

  get gitHubReferences() {
    if (this.#data.gitHubReferences === undefined) {
      this.#data.gitHubReferences = [];
    }

    return this.#data.gitHubReferences;
  }

  async getBehaviorPackScriptsFolder() {
    const bpFolder = await this.ensureDefaultBehaviorPackFolder();

    return bpFolder.folders["scripts"];
  }

  async ensureBehaviorPackScriptsFolder() {
    const bpFolder = await this.ensureDefaultBehaviorPackFolder();

    return bpFolder.ensureFolder("scripts");
  }

  async getMainScriptsFolder() {
    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    return this.#projectFolder.folders["scripts"];
  }

  async ensureProjectItemAccessoryFolder() {
    if (this.projectItemAccessoryFolder) {
      return this.projectItemAccessoryFolder;
    }
    await this.loadFolderStructure();
    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    const defaultDesignFolder = await this.ensureDefaultDesignPackFolder();

    this.projectItemAccessoryFolder = defaultDesignFolder.ensureFolder("project_item_data");

    return this.projectItemAccessoryFolder;
  }

  async ensureMainScriptsFolder() {
    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    return this.#projectFolder.ensureFolder("scripts");
  }

  async ensureScriptGenFolder() {
    const scriptsFolder = await this.ensureMainScriptsFolder();

    if (!scriptsFolder) {
      throw new Error("Unexpectedly could not create a main scripts folder");
    }

    return scriptsFolder.ensureFolder("_gen");
  }

  get preferredScriptLanguage() {
    if (
      this.#data.preferredScriptLanguage === undefined ||
      this.#data.preferredScriptLanguage === ProjectScriptLanguage.typeScript
    ) {
      return ProjectScriptLanguage.typeScript;
    }

    return this.#data.preferredScriptLanguage;
  }

  set preferredScriptLanguage(newLanguage: ProjectScriptLanguage) {
    this.#data.preferredScriptLanguage = newLanguage;
  }

  get scriptVersion() {
    if (this.#data.scriptVersion === undefined) {
      return ProjectScriptVersion.latestStable;
    }

    return this.#data.scriptVersion;
  }

  get messages() {
    return this.#data.messages;
  }

  set scriptVersion(newVersion: ProjectScriptVersion) {
    this.#data.scriptVersion = newVersion;
  }

  get editPreference() {
    if (this.#data.editPreference === undefined) {
      return ProjectEditPreference.summarized;
    }

    return this.#data.editPreference;
  }

  set editPreference(newEditPreference: ProjectEditPreference) {
    this.#data.editPreference = newEditPreference;
  }

  get contentsModified() {
    let val = this.#data.contentsModified;

    if (val === null) {
      return null;
    }

    if (!(val instanceof Date)) {
      val = new Date(val);
    }

    return val;
  }

  getItemsCopy(): ProjectItem[] {
    return this.#items.slice();
  }

  public initializeWorldSettings() {
    if (this.#data.worldSettings === undefined) {
      this.#data.worldSettings = {
        gameType: GameType.creative,
        generator: Generator.infinite,
        randomSeed: "2000",
        isEditor: false,
        backupType: BackupType.every5Minutes,
        useCustomSettings: false,
      };

      this.ensureDefaultWorldName();
    }
  }

  private ensureDefaultWorldName() {
    if (this.worldSettings && this.worldSettings.name === undefined) {
      this.worldSettings.name = this.name + " " + Utilities.getDateStr(new Date());

      this.save();
    }
  }

  public initializeEditorWorldSettings() {
    if (this.#data.editorWorldSettings === undefined) {
      this.#data.editorWorldSettings = {
        gameType: GameType.creative,
        generator: Generator.infinite,
        randomSeed: "2000",
        isEditor: true,
        backupType: BackupType.every5Minutes,
        useCustomSettings: false,
      };

      this.ensureDefaultEditorWorldName();
    }
  }

  private ensureDefaultEditorWorldName() {
    if (this.editorWorldSettings && this.editorWorldSettings.name === undefined) {
      this.editorWorldSettings.name = this.name + " " + Utilities.getDateStr(new Date());

      this.save();
    }
  }

  public addMessage(message: string, context?: string, operation?: string, type?: StatusType, topic?: StatusTopic) {
    if (this.#data.messages === undefined) {
      this.#data.messages = [];
    }

    if (type === undefined) {
      type = StatusType.message;
    }

    const messageCanon = message.trim().toLowerCase();

    if (messageCanon.length > 1) {
      const status = {
        time: new Date(),
        message: message,
        context: context,
        operation: operation,
        topic: topic,
        type: type,
      };

      this.#data.messages.push(status);
    }
  }

  public appendErrors(errorable: IErrorable, operation?: string) {
    if (!errorable.errorMessages) {
      return;
    }

    for (const err of errorable.errorMessages) {
      this.carto.notifyStatusUpdate(err.message, StatusTopic.general);

      this.addMessage(err.message, err.context, operation, StatusType.message);
    }
  }

  removeItem(item: ProjectItem) {
    const newArr: ProjectItem[] = [];

    for (let i = 0; i < this.items.length; i++) {
      if (this.items[i] !== item) {
        newArr.push(this.items[i]);
      }
    }
    const path = ProjectUtilities.canonicalizeStoragePath(item.projectPath);

    if (!Utilities.isUsableAsObjectKey(path)) {
      return;
    }

    this.#itemsByProjectPath[path] = undefined;

    this.#items = newArr;

    const newDataArr: IProjectItemData[] = [];

    for (let i = 0; i < this.#data.items.length; i++) {
      if (this.#data.items[i].projectPath !== item.projectPath) {
        newDataArr.push(this.#data.items[i]);
      }
    }

    this.#data.items = newDataArr;
    this.#infoSetNeedsUpdating = true;

    this._onItemRemoved.dispatch(this, item);
  }

  updateContentsModified() {
    this.#data.contentsModified = new Date();
  }

  get modified(): Date | null {
    if (this.#preferencesFile != null && this.#preferencesFile.latestModified != null) {
      if (this.contentsModified != null && this.contentsModified > this.#preferencesFile.latestModified) {
        return this.contentsModified;
      }

      return this.#preferencesFile.latestModified;
    } else {
      return this.contentsModified;
    }
  }

  get showHiddenItems() {
    if (this.#data.showHiddenItems === true) {
      return true;
    }

    return false;
  }

  set showHiddenItems(showItems: boolean) {
    if (showItems !== this.showHiddenItems) {
      this.#data.showHiddenItems = showItems;

      this._onPropertyChanged.dispatch(this, "showHiddenItems");
    }
  }

  get showFunctions() {
    if (this.#data.showFunctions === undefined) {
      return true;
    }

    return this.#data.showFunctions;
  }

  set showFunctions(showFunctions: boolean) {
    if (showFunctions !== this.showFunctions) {
      this.#data.showFunctions = showFunctions;

      this._onPropertyChanged.dispatch(this, "showFunctions");
    }
  }

  get showAssets() {
    if (this.#data.showAssets === undefined) {
      return true;
    }

    return this.#data.showAssets;
  }

  set showAssets(showAssets: boolean) {
    if (showAssets !== this.showAssets) {
      this.#data.showAssets = showAssets;

      this._onPropertyChanged.dispatch(this, "showAssets");
    }
  }

  get showTypes() {
    if (this.#data.showTypes === undefined) {
      return true;
    }

    return this.#data.showTypes;
  }

  set showTypes(showTypes: boolean) {
    if (showTypes !== this.showTypes) {
      this.#data.showTypes = showTypes;

      this._onPropertyChanged.dispatch(this, "showTypes");
    }
  }

  get name(): string {
    return this.#data.name;
  }

  set name(newName: string) {
    this.#data.name = newName;
  }

  get lastMapDeployedHash(): string | undefined {
    return this.#data.lastMapDeployedHash;
  }

  get lastMapDeployedDate(): Date | undefined {
    return this.#data.lastMapDeployedDate;
  }

  set lastMapDeployedHash(newValue: string | undefined) {
    this.#data.lastMapDeployedHash = newValue;
  }

  set lastMapDeployedDate(newValue: Date | undefined) {
    this.#data.lastMapDeployedDate = newValue;
  }

  get effectiveCreator(): string {
    if (this.#data.creator && this.#data.creator.length > 0) {
      return this.#data.creator;
    }

    if (this.carto.creator && this.carto.creator.length > 0) {
      return this.carto.creator;
    }

    return "contoso";
  }

  get effectiveShortName(): string {
    if (this.#data.shortName && this.#data.shortName.length > 0) {
      return this.#data.shortName;
    }
    if (this.effectiveCreator.length > 0 && this.#data.name && this.#data.name.length > 0) {
      return ProjectUtilities.getSuggestedProjectShortName(this.effectiveCreator, this.#data.name);
    }

    return "cont_game";
  }

  get shortName(): string | undefined {
    return this.#data.shortName;
  }

  set shortName(newShortName: string | undefined) {
    if (this.#data.shortName !== newShortName) {
      this.#data.shortName = newShortName;

      this._onPropertyChanged.dispatch(this, "shortName");
    }
  }

  get creator(): string | undefined {
    return this.#data.creator;
  }

  set creator(newCreator: string | undefined) {
    if (this.#data.creator !== newCreator) {
      this.#data.creator = newCreator;

      this._onPropertyChanged.dispatch(this, "creator");
    }
  }

  get title(): string {
    if (this.#data.title) {
      return this.#data.title;
    }

    return this.name;
  }

  set title(newTitle: string) {
    if (this.#data.title !== newTitle) {
      this.#data.title = newTitle;

      this._onPropertyChanged.dispatch(this, "title");
    }
  }

  get track(): MinecraftTrack | undefined {
    return this.#data.track;
  }

  set track(newTrack: MinecraftTrack | undefined) {
    if (newTrack !== this.#data.track) {
      this.#data.track = newTrack;
      this._onPropertyChanged.dispatch(this, "track");
    }
  }

  get effectiveTrack(): MinecraftTrack {
    if (this.#data.track !== undefined) {
      return this.#data.track;
    }

    return this.#carto.effectiveTrack;
  }

  set originalFullPath(newOriginalPath: string | undefined) {
    if (this.#data.originalFullPath !== newOriginalPath) {
      this.#data.originalFullPath = newOriginalPath;

      this._onPropertyChanged.dispatch(this, "originalFullPath");
    }
  }

  get originalFullPath(): string | undefined {
    return this.#data.originalFullPath;
  }

  set originalFileList(newFileList: string[] | undefined) {
    if (this.#data.originalFileList !== newFileList) {
      this.#data.originalFileList = newFileList;

      this._onPropertyChanged.dispatch(this, "originalFileList");
    }
  }

  get originalFileList(): string[] | undefined {
    return this.#data.originalFileList;
  }

  set originalGitHubOwner(newGitHubOwner: string | undefined) {
    if (this.#data.originalGitHubOwner !== newGitHubOwner) {
      this.#data.originalGitHubOwner = newGitHubOwner;

      this._onPropertyChanged.dispatch(this, "originalGitHubOwner");
    }
  }

  set originalGalleryId(newGalleryId: string | undefined) {
    if (this.#data.originalGalleryId !== newGalleryId) {
      this.#data.originalGalleryId = newGalleryId;

      this._onPropertyChanged.dispatch(this, "originalGalleryId");
    }
  }

  get originalGalleryId(): string | undefined {
    return this.#data.originalGalleryId;
  }

  set originalSampleId(newSampleId: string | undefined) {
    if (this.#data.originalSampleId !== newSampleId) {
      this.#data.originalSampleId = newSampleId;

      this._onPropertyChanged.dispatch(this, "originalSampleId");
    }
  }

  get originalSampleId(): string | undefined {
    return this.#data.originalSampleId;
  }

  get originalGitHubOwner(): string | undefined {
    return this.#data.originalGitHubOwner;
  }

  set originalGitHubFolder(newGitHubFolder: string | undefined) {
    if (this.#data.originalGitHubFolder !== newGitHubFolder) {
      this.#data.originalGitHubFolder = newGitHubFolder;

      this._onPropertyChanged.dispatch(this, "originalGitHubFolder");
    }
  }

  get originalGitHubFolder(): string | undefined {
    return this.#data.originalGitHubFolder;
  }

  set originalGitHubRepoName(newGitHubRepoName: string | undefined) {
    if (this.#data.originalGitHubRepoName !== newGitHubRepoName) {
      this.#data.originalGitHubRepoName = newGitHubRepoName;

      this._onPropertyChanged.dispatch(this, "originalGitHubRepoName");
    }
  }

  get originalGitHubRepoName(): string | undefined {
    return this.#data.originalGitHubRepoName;
  }

  set originalGitHubBranch(newGitHubBranch: string | undefined) {
    if (this.#data.originalGitHubBranch !== newGitHubBranch) {
      this.#data.originalGitHubBranch = newGitHubBranch;

      this._onPropertyChanged.dispatch(this, "originalGitHubBranch");
    }
  }

  get originalGitHubBranch(): string | undefined {
    return this.#data.originalGitHubBranch;
  }

  set gitHubOwner(newGitHubOwner: string | undefined) {
    if (this.#data.gitHubOwner !== newGitHubOwner) {
      this.#data.gitHubOwner = newGitHubOwner;

      this._onPropertyChanged.dispatch(this, "gitHubOwner");
    }
  }

  get gitHubOwner(): string | undefined {
    return this.#data.gitHubOwner;
  }

  set gitHubFolder(newGitHubFolder: string | undefined) {
    if (this.#data.gitHubFolder !== newGitHubFolder) {
      this.#data.gitHubFolder = newGitHubFolder;

      this._onPropertyChanged.dispatch(this, "gitHubFolder");
    }
  }

  get gitHubFolder(): string | undefined {
    return this.#data.gitHubFolder;
  }

  set gitHubRepoName(newGitHubRepoName: string | undefined) {
    if (this.#data.gitHubRepoName !== newGitHubRepoName) {
      this.#data.gitHubRepoName = newGitHubRepoName;

      this._onPropertyChanged.dispatch(this, "gitHubRepoName");
    }
  }

  get gitHubRepoName(): string | undefined {
    return this.#data.gitHubRepoName;
  }

  set gitHubBranch(newGitHubBranch: string | undefined) {
    if (this.#data.gitHubBranch !== newGitHubBranch) {
      this.#data.gitHubBranch = newGitHubBranch;

      this._onPropertyChanged.dispatch(this, "gitHubBranch");
    }
  }

  get gitHubBranch(): string | undefined {
    return this.#data.gitHubBranch;
  }

  get description(): string {
    return this.#data.description;
  }

  set description(newDescription: string) {
    if (this.#data.description !== newDescription) {
      this.#data.description = newDescription;

      this._onPropertyChanged.dispatch(this, "description");
    }
  }

  public async applyDescription(newTitle: string) {
    this.title = newTitle;

    if (this.editPreference === ProjectEditPreference.summarized && this.defaultBehaviorPackUniqueId) {
      for (const projectItem of this.items) {
        const itemFile = projectItem.primaryFile;

        if (itemFile && projectItem.itemType === ProjectItemType.behaviorPackManifestJson) {
          const manifestJson = await BehaviorManifestDefinition.ensureOnFile(itemFile);

          if (
            manifestJson &&
            manifestJson.definition &&
            Utilities.uuidEqual(manifestJson.definition.header.uuid, this.defaultBehaviorPackUniqueId)
          ) {
            const header = manifestJson.ensureHeader(this.title, this.description);

            header.name = newTitle;

            manifestJson.save();
          }
        }
      }
    }
  }

  get autoDeploymentMode(): ProjectAutoDeploymentMode {
    if (this.#data.autoDeploymentMode === undefined) {
      return 0;
    }

    return this.#data.autoDeploymentMode as ProjectAutoDeploymentMode;
  }

  set autoDeploymentMode(newMode: ProjectAutoDeploymentMode) {
    if (this.#data.autoDeploymentMode !== newMode) {
      this.#data.autoDeploymentMode = newMode;

      this._onPropertyChanged.dispatch(this, "autoDeploymentMode");
    }
  }

  get version(): number[] {
    let vmj = this.#data.versionMajor;
    if (vmj === undefined) {
      vmj = 0;
    }

    let vmi = this.#data.versionMinor;
    if (vmi === undefined) {
      vmi = 0;
    }

    let vmp = this.#data.versionPatch;
    if (vmp === undefined) {
      vmp = 0;
    }

    return [vmj, vmi, vmp];
  }

  get versionMajor(): number | undefined {
    return this.#data.versionMajor;
  }

  set versionMajor(newVersion: number | undefined) {
    if (this.#data.versionMajor !== newVersion) {
      this.#data.versionMajor = newVersion;

      this._onPropertyChanged.dispatch(this, "versionMajor");
    }
  }

  get versionMinor(): number | undefined {
    return this.#data.versionMinor;
  }

  set versionMinor(newVersion: number | undefined) {
    if (this.#data.versionMinor !== newVersion) {
      this.#data.versionMinor = newVersion;

      this._onPropertyChanged.dispatch(this, "versionMinor");
    }
  }

  get versionPatch(): number | undefined {
    return this.#data.versionPatch;
  }

  set versionPatch(newVersion: number | undefined) {
    if (this.#data.versionPatch !== newVersion) {
      this.#data.versionPatch = newVersion;

      this._onPropertyChanged.dispatch(this, "versionPatch");
    }
  }

  get defaultResourcePackUniqueId(): string {
    return this.#data.defaultResourcePackUniqueId;
  }

  set defaultResourcePackUniqueId(newId: string) {
    if (this.#data.defaultResourcePackUniqueId !== newId) {
      this.#data.defaultResourcePackUniqueId = newId;

      this._onPropertyChanged.dispatch(this, "defaultResourcePackUniqueId");
    }
  }

  async setDefaultResourcePackUniqueIdAndUpdateDependencies(newId: string) {
    if (this.#data.defaultResourcePackUniqueId !== newId) {
      const oldId = this.#data.defaultResourcePackUniqueId;

      this.#data.defaultResourcePackUniqueId = newId;

      if (oldId && oldId.length > 4) {
        await ResourceManifestDefinition.setNewResourcePackId(this, newId, oldId);
      }

      this._onPropertyChanged.dispatch(this, "defaultResourcePackUniqueId");
    }
  }

  get defaultResourcePackVersion(): number[] {
    if (this.#data.defaultResourcePackVersion === undefined) {
      const vMajor = this.versionMajor ? this.versionMajor : 0;
      const vMinor = this.versionMinor ? this.versionMinor : 0;
      const vPatch = this.versionPatch ? this.versionPatch : 1;

      return [vMajor, vMinor, vPatch];
    }

    return this.#data.defaultResourcePackVersion;
  }

  set defaultResourcePackVersion(newVersion: number[]) {
    if (this.#data.defaultResourcePackVersion !== newVersion) {
      this.#data.defaultResourcePackVersion = newVersion;

      this._onPropertyChanged.dispatch(this, "defaultResourcePackVersion");
    }
  }

  get defaultBehaviorPackUniqueId(): string {
    return this.#data.defaultBehaviorPackUniqueId;
  }

  set defaultBehaviorPackUniqueId(newId: string) {
    if (this.#data.defaultBehaviorPackUniqueId !== newId) {
      this.#data.defaultBehaviorPackUniqueId = newId;

      this._onPropertyChanged.dispatch(this, "defaultBehaviorPackUniqueId");
    }
  }

  async setDefaultBehaviorPackUniqueIdAndUpdateDependencies(newId: string) {
    if (this.#data.defaultBehaviorPackUniqueId !== newId) {
      const oldId = this.#data.defaultBehaviorPackUniqueId;
      this.#data.defaultBehaviorPackUniqueId = newId;

      if (oldId && oldId.length > 4) {
        await BehaviorManifestDefinition.setNewBehaviorPackId(this, newId, oldId);
      }

      this._onPropertyChanged.dispatch(this, "defaultBehaviorPackUniqueId");
    }
  }

  get defaultBehaviorPackVersion(): number[] {
    if (this.#data.defaultBehaviorPackVersion === undefined) {
      const vMajor = this.versionMajor ? this.versionMajor : 0;
      const vMinor = this.versionMinor ? this.versionMinor : 0;
      const vPatch = this.versionPatch ? this.versionPatch : 1;

      return [vMajor, vMinor, vPatch];
    }

    return this.#data.defaultBehaviorPackVersion;
  }

  set defaultBehaviorPackVersion(newVersion: number[]) {
    if (this.#data.defaultBehaviorPackVersion !== newVersion) {
      this.#data.defaultBehaviorPackVersion = newVersion;

      this._onPropertyChanged.dispatch(this, "defaultBehaviorPackVersion");
    }
  }

  get defaultDataUniqueId(): string {
    return this.#data.defaultDataUniqueId;
  }

  set defaultDataUniqueId(newId: string) {
    if (this.#data.defaultDataUniqueId !== newId) {
      this.#data.defaultDataUniqueId = newId;

      this._onPropertyChanged.dispatch(this, "defaultDataUniqueId");
    }
  }

  public async ensureInfoSetGenerated() {
    const infoSet = this.infoSet;

    if (infoSet.completedGeneration) {
      return infoSet;
    }

    await infoSet.generateForProject(this.#infoSetNeedsUpdating);

    this.#infoSetNeedsUpdating = false;

    return infoSet;
  }

  async ensureScriptInDestination() {
    const bpScriptsFolder = await this.ensureBehaviorPackScriptsFolder();

    if (bpScriptsFolder === undefined) {
      return;
    }

    const coreScriptsFolderPath = StorageUtilities.canonicalizePath(bpScriptsFolder.storageRelativePath);

    for (const pi of this.#items) {
      if ((pi.itemType === ProjectItemType.testJs || pi.itemType === ProjectItemType.js) && pi.projectPath) {
        let spath = StorageUtilities.canonicalizePath(pi.projectPath);
        if (!spath.startsWith(coreScriptsFolderPath)) {
          const scriptsTokenIndex = spath.indexOf("/scripts/");
          if (scriptsTokenIndex >= 0) {
            spath = spath.substring(scriptsTokenIndex + 8);
          }

          await pi.load();
          const itemFile = pi.primaryFile;

          if (itemFile && itemFile.content) {
            const item = this.ensureItemByProjectPath(
              StorageUtilities.ensureEndsWithDelimiter(coreScriptsFolderPath) +
                StorageUtilities.ensureNotStartsWithDelimiter(spath),
              ProjectItemStorageType.singleFile,
              StorageUtilities.getLeafName(spath),
              ProjectItemType.buildProcessedJs,
              FolderContext.behaviorPack,
              undefined,
              ProjectItemCreationType.normal
            );

            const file = await item.ensureFileStorage();

            if (file) {
              file.setContent(itemFile.content);
            }
          }
        }
      }
    }
  }

  async hasScript() {
    for (const pi of this.#items) {
      if (
        pi.itemType === ProjectItemType.actionSet ||
        pi.itemType === ProjectItemType.testJs ||
        pi.itemType === ProjectItemType.js ||
        pi.itemType === ProjectItemType.buildProcessedJs ||
        pi.itemType === ProjectItemType.ts
      ) {
        return true;
      }
    }

    const scriptsFolder = await this.getBehaviorPackScriptsFolder();
    if (!scriptsFolder) {
      return false;
    }

    await scriptsFolder.load();

    if (scriptsFolder.fileCount > 0 || scriptsFolder.folderCount > 0) {
      return true;
    }

    return false;
  }

  get projectCabinetFile() {
    return this.#projectCabinetFile;
  }

  get defaultScriptModuleUniqueId(): string {
    return this.#data.defaultScriptModuleUniqueId;
  }

  set defaultScriptModuleUniqueId(newId: string) {
    if (this.#data.defaultScriptModuleUniqueId !== newId) {
      this.#data.defaultScriptModuleUniqueId = newId;

      this._onPropertyChanged.dispatch(this, "defaultScriptModuleUniqueId");
    }
  }

  get focus(): ProjectFocus {
    return this.#data.focus;
  }

  set focus(newFocus: ProjectFocus) {
    if (this.#data.focus !== newFocus) {
      this.#data.focus = newFocus;

      this._onPropertyChanged.dispatch(this, "focus");
    }
  }

  constructor(carto: Carto, name: string, preferencesFile: IFile | null, sanitizeName?: boolean) {
    this._handleDeployUpdated = this._handleDeployUpdated.bind(this);
    this._handleProjectFileContentsUpdated = this._handleProjectFileContentsUpdated.bind(this);
    this.applyUpdate = this.applyUpdate.bind(this);
    this.ensurePreferencesAndFolderLoadedFromFile = this.ensurePreferencesAndFolderLoadedFromFile.bind(this);
    this.ensureProjectFolder = this.ensureProjectFolder.bind(this);
    this._handleProjectFolderMoved = this._handleProjectFolderMoved.bind(this);

    this.loc = new LocManager(this);

    let sanName = name;

    if (sanitizeName) {
      sanName = ProjectUtilities.sanitizeProjectName(sanName);
    }

    this.#data = {
      dataType: ProjectDataType.clientStorage,
      variants: {},
      storageBasePath: "",
      contentsModified: null,
      dataStorageRelativePath: "/" + name + "/",
      editPreference: ProjectEditPreference.summarized,
      name: sanName,
      title: sanName,
      description: sanName + " description",
      defaultBehaviorPackUniqueId: Utilities.createUuid(),
      defaultResourcePackUniqueId: Utilities.createUuid(),
      defaultScriptModuleUniqueId: Utilities.createUuid(),
      defaultDataUniqueId: Utilities.createUuid(),
      focus: ProjectFocus.general,
      items: [],
    };

    this.#preferencesFile = preferencesFile;

    this.#projectFolder = null;
    this.defaultBehaviorPackFolder = null;
    this.defaultWorldFolder = null;
    this.defaultSkinPackFolder = null;
    this.defaultDesignPackFolder = null;
    this.#defaultScriptsFolder = null;
    this.behaviorPacksContainer = null;
    this.docsContainer = null;
    this.defaultResourcePackFolder = null;
    this.resourcePacksContainer = null;
    this.designPacksContainer = null;
    this.skinPacksContainer = null;
    this.worldContainer = null;
    this.defaultPersonaPackFolder = null;
    this.personaPacksContainer = null;
    this.projectItemAccessoryFolder = null;
    this.#carto = carto;
    this.#items = [];
    this.variants = {};
  }

  notifyProjectItemChanged(item: ProjectItem) {
    this._onItemChanged.dispatch(this, item);
  }

  clearFolders() {
    this._unapplyFromProjectFolder();

    if (this.#projectFolder) {
      this.#projectFolder.clearAllManagers();
    }

    this.#projectFolder = null;
    this.defaultBehaviorPackFolder = null;
    this.defaultWorldFolder = null;
    this.defaultSkinPackFolder = null;
    this.defaultDesignPackFolder = null;
    this.#defaultScriptsFolder = null;
    this.behaviorPacksContainer = null;
    this.docsContainer = null;
    this.defaultResourcePackFolder = null;
    this.resourcePacksContainer = null;
    this.skinPacksContainer = null;
    this.worldContainer = null;

    this.#packs = [];
  }

  ensureVariant(label: string) {
    label = ProjectVariant.canonicalizeVariantLabel(label);

    if (!this.variants[label]) {
      if (!this.#data.variants) {
        this.#data.variants = {};
      }

      if (Utilities.isUsableAsObjectKey(label)) {
        if (this.#data.variants[label] === undefined) {
          this.#data.variants[label] = { label: label };
        }

        this.variants[label] = new ProjectVariant(this, this.#data.variants[label]);
      }
    }

    return this.variants[label];
  }

  async ensureWorldContainer() {
    if (!this.worldContainer) {
      const pf = await this.ensureProjectFolder();

      if (pf) {
        await pf.load(false);

        if (pf.folders["worlds"]) {
          this.worldContainer = pf.folders["worlds"];
        } else if (pf.folders["minecraftWorlds"]) {
          this.worldContainer = pf.folders["minecraftWorlds"];
        } else {
          this.worldContainer = pf;
        }
      }
    }

    return this.worldContainer;
  }

  async ensureCatalogIndex() {
    if (!this.hasScript) {
      return;
    }

    const scriptsFolder = await this.ensureBehaviorPackScriptsFolder();

    if (!scriptsFolder) {
      return;
    }

    this.ensureItemByTag(
      "jsindex",
      "index.js",
      ProjectItemType.catalogIndexJs,
      StorageUtilities.ensureEndsWithDelimiter(scriptsFolder.storageRelativePath) + "index.js",
      ProjectItemStorageType.singleFile,
      ProjectItemCreationType.generated
    );
  }

  async getDefaultScriptsFile() {
    const defaultBehaviorPack = await this.getDefaultBehaviorPack();

    if (defaultBehaviorPack) {
      if (defaultBehaviorPack.manifest) {
        const manifest = defaultBehaviorPack.manifest as BehaviorManifestDefinition;

        const scriptMod = manifest.getScriptModule();

        if (scriptMod && scriptMod.entry && scriptMod.entry.toLowerCase().startsWith("scripts/")) {
          let scriptsFolder = await this.getMainScriptsFolder();

          let scriptsText = scriptMod.entry.substring(8);

          if (scriptsText.toLowerCase().endsWith(".js")) {
            scriptsText = scriptsText.substring(0, scriptsText.length - 3);
          }

          if (scriptsFolder) {
            let file = scriptsFolder.files[scriptsText + ".ts"];

            if (!file) {
              file = scriptsFolder.files[scriptsText + ".js"];
            }

            return file;
          }
        }
      }
    }

    return undefined;
  }

  async inferProjectItemsFromFilesRootFolder(force?: boolean, processingCallback?: (area: string) => void) {
    const rootFolder = await this.ensureProjectFolder();

    const operId = await this.carto.notifyOperationStarted(
      "Loading project files for '" + this.name + "' from folder '" + rootFolder.fullPath + "'",
      StatusTopic.projectLoad
    );

    if (this.#projectFolder) {
      await ProjectItemInference.inferProjectItemsFromFolder(
        this,
        rootFolder,
        "",
        FolderContext.unknown,
        undefined,
        false,
        this.#projectFolder,
        0,
        undefined,
        force,
        processingCallback
      );

      if (processingCallback) {
        processingCallback("Analyzing " + this.items.length + " project items...");
      }
    }

    await this.carto.notifyOperationEnded(
      operId,
      "Done loading project files for '" + this.name + "' from folder '" + rootFolder.fullPath + "'",
      StatusTopic.projectLoad
    );

    this.hasInferredFiles = true;
  }

  async ensureAutogeneratedBehaviorPackManifest() {
    const bpFolder = await this.ensureDefaultBehaviorPackFolder();

    if (!bpFolder) {
      return;
    }

    this.ensureItemByTag(
      "manifestjson",
      "behaviorpackmanifest",
      ProjectItemType.behaviorPackManifestJson,
      StorageUtilities.ensureEndsWithDelimiter(bpFolder.storageRelativePath) + "manifest.json",
      ProjectItemStorageType.singleFile,
      ProjectItemCreationType.generated
    );
  }

  dispose() {
    if (this.#projectFolder) {
      this._unapplyFromProjectFolder();
      this.#projectFolder.dispose();
      this.#projectFolder = null;
    }

    if (this.#projectCabinetFile) {
      this.#projectCabinetFile.dispose();
      this.#projectCabinetFile = null;
    }

    if (this.#distBuildFolder) {
      this.#distBuildFolder.dispose();
      this.#distBuildFolder = null;
    }

    if (this.#libFolder) {
      this.#libFolder.dispose();
      this.#libFolder = null;
    }

    if (this.#distBuildScriptsFolder) {
      this.#distBuildScriptsFolder.dispose();
      this.#distBuildScriptsFolder = null;
    }

    if (this.#libScriptsFolder) {
      this.#libScriptsFolder.dispose();
      this.#libScriptsFolder = null;
    }

    if (this.docsContainer) {
      this.docsContainer.dispose();
      this.docsContainer = null;
    }

    if (this.worldContainer) {
      this.worldContainer.dispose();
      this.worldContainer = null;
    }

    if (this.behaviorPacksContainer) {
      this.behaviorPacksContainer.dispose();
      this.behaviorPacksContainer = null;
    }

    if (this.defaultBehaviorPackFolder) {
      this.defaultBehaviorPackFolder.dispose();
      this.defaultBehaviorPackFolder = null;
    }

    if (this.#defaultScriptsFolder) {
      this.#defaultScriptsFolder.dispose();
      this.#defaultScriptsFolder = null;
    }

    if (this.resourcePacksContainer) {
      this.resourcePacksContainer.dispose();
      this.resourcePacksContainer = null;
    }

    if (this.defaultResourcePackFolder) {
      this.defaultResourcePackFolder.dispose();
      this.defaultResourcePackFolder = null;
    }

    this.#isDisposed = true;
  }

  resetProjectItems() {
    const newProjectItems: ProjectItem[] = [];

    for (const projectItem of this.items) {
      if (projectItem.itemType !== ProjectItemType.unknown && projectItem.itemType !== ProjectItemType.unknownJson) {
        newProjectItems.push(projectItem);
      }
    }

    this.#items = newProjectItems;
  }

  ensureStoragePathIsCollapsed(storagePath: string) {
    for (const pathCollapsed of this.collapsedStoragePaths) {
      if (pathCollapsed === storagePath) {
        return;
      }
    }

    this.collapsedStoragePaths.push(storagePath);
  }

  get isVanillaSourceProject() {
    return this.defaultBehaviorPackUniqueId === "ee649bcf-256c-4013-9068-6a802b89d756";
  }

  ensureStoragePathIsNotCollapsed(storagePath: string) {
    const newCollapsedPaths: string[] = [];

    for (const pathCollapsed of this.collapsedStoragePaths) {
      if (pathCollapsed !== storagePath) {
        newCollapsedPaths.push(pathCollapsed);
      }
    }

    this.#data.collapsedStoragePaths = newCollapsedPaths;
  }

  async inferProjectItemsFromFiles(force?: boolean, processingCallback?: (area: string) => void) {
    if (!this.hasInferredFiles || force) {
      await this.ensureProjectFolder();

      if (this.projectCabinetFile !== null) {
        const operId = await this.carto.notifyOperationStarted(
          "Loading project files for '" + this.name + "' from '" + this.projectCabinetFile.fullPath + "'",
          StatusTopic.projectLoad
        );

        await this.ensureProjectFolderFromCabinet();
        /*await project._inferProjectItemsFromZipFile(
          project.#projectCabinetFile.storageRelativePath,
          project.#projectCabinetFile,
          false
        );*/

        if (this.projectFolder) {
          await ProjectItemInference.inferProjectItemsFromFolder(
            this,
            this.projectFolder,
            "",
            FolderContext.unknown,
            undefined,
            false,
            this.projectFolder,
            0,
            undefined,
            force
          );
        }

        await this.carto.notifyOperationEnded(
          operId,
          "Done loading project files for '" + this.name + "' from file '" + this.projectCabinetFile.fullPath + "'",
          StatusTopic.projectLoad
        );

        this.hasInferredFiles = true;
      } else {
        await this.inferProjectItemsFromFilesRootFolder(false, processingCallback);
      }

      if (this.#accessoryFolders) {
        for (let i = 0; i < this.#accessoryFolders.length; i++) {
          await ProjectItemInference.inferProjectItemsFromFolder(
            this,
            this.#accessoryFolders[i],
            "",
            FolderContext.unknown,
            undefined,
            false,
            this.#accessoryFolders[i],
            0,
            "o." + this.#accessoryFolders[i].name,
            force,
            processingCallback
          );
        }
      }
    }
  }

  async ensureProjectFolderFromCabinet() {
    if (!this.#projectCabinetFile) {
      Log.unexpectedUndefined("EPFFC");
      return;
    }

    await this.#projectCabinetFile.loadContent();

    const rootFolder = await StorageUtilities.getFileStorageFolder(this.#projectCabinetFile);

    if (rootFolder && typeof rootFolder === "string") {
      this.#errorState = ProjectErrorState.cabinetFileCouldNotBeProcessed;
      this.#errorMessage = rootFolder;
    } else if (rootFolder !== this.#projectFolder && typeof rootFolder !== "string") {
      this._unapplyFromProjectFolder();
      if (rootFolder) {
        this.#projectFolder = rootFolder;

        this._applyToProjectFolder();
      } else {
        this.#projectFolder = null;
      }
    }
  }

  async inferProjectItemsFromZipFile(projectPath: string, file: IFile, force?: boolean): Promise<string | undefined> {
    let operId = await this.carto.notifyOperationStarted("Loading package file " + file.name);
    await file.loadContent();

    const rootFolder = await StorageUtilities.getFileStorageFolder(file);

    if (typeof rootFolder === "string") {
      return rootFolder;
    } else if (rootFolder) {
      await ProjectItemInference.inferProjectItemsFromFolder(
        this,
        rootFolder,
        projectPath + "#",
        FolderContext.unknown,
        undefined,
        false,
        rootFolder,
        0,
        undefined,
        force
      );
    }

    await this.carto.notifyOperationEnded(operId, "Done loading package file " + file.name);
    return undefined;
  }

  async processRelations(force?: boolean) {
    if (this.#relationsProcessed && !force) {
      return;
    }

    if (this.#isProcessingRelations) {
      const pendingProcessing = this.#pendingProcessingRelationsRequests;

      const prom = (resolve: (value: unknown) => void, reject: (reason?: any) => void) => {
        pendingProcessing.push(resolve);
      };

      await new Promise(prom);

      return;
    } else {
      this.#isProcessingRelations = true;

      const processOperId = await this.carto.notifyOperationStarted(
        "Processing relations for '" + this.name + "'",
        StatusTopic.processing
      );

      await ProjectItemRelations.calculate(this);

      this.#relationsProcessed = true;

      if (processOperId !== undefined) {
        await this.carto.notifyOperationEnded(
          processOperId,
          "Completed processing of '" + this.name + "'",
          StatusTopic.processing
        );
      }

      this.#isProcessingRelations = false;

      const pendingProcessing = this.#pendingProcessingRelationsRequests;
      this.#pendingProcessingRelationsRequests = [];

      for (const prom of pendingProcessing) {
        prom(undefined);
      }
    }
  }

  async ensureJsIndexFile() {
    if (this.projectFolder === null) {
      throw new Error("Could not find project folder");
    }

    const bpFolder = await this.ensureDefaultBehaviorPackFolder();

    const defaultPath = bpFolder.getFolderRelativePath(this.projectFolder);

    this.ensureItemByTag(
      "jsindex",
      "index.js",
      ProjectItemType.catalogIndexJs,
      defaultPath + "scripts/index.js",
      ProjectItemStorageType.singleFile,
      ProjectItemCreationType.generated
    );
  }

  async applyUpdate(updaterId: string, updaterIndex: number): Promise<ProjectUpdateResult[]> {
    const pur = new ProjectUpdateRunner(this);

    return await pur.update(updaterId, updaterIndex);
  }

  async getScriptState() {
    const state: IProjectScriptState = {
      hasScript: false,
      hasModule: {},
    };

    for (let i = 0; i < this.#items.length; i++) {
      const pi = this.#items[i];

      if (
        pi.itemType === ProjectItemType.js ||
        pi.itemType === ProjectItemType.buildProcessedJs ||
        pi.itemType === ProjectItemType.testJs ||
        pi.itemType === ProjectItemType.ts ||
        pi.itemType === ProjectItemType.worldTest
      ) {
        state.hasScript = true;

        if (
          (pi.itemType === ProjectItemType.js ||
            pi.itemType === ProjectItemType.buildProcessedJs ||
            pi.itemType === ProjectItemType.testJs ||
            pi.itemType === ProjectItemType.ts) &&
          pi.primaryFile
        ) {
          await pi.primaryFile.loadContent();
          const content = pi.primaryFile.content;

          if (content && typeof content === "string") {
            for (let i = 0; i < minecraftScriptModules.length; i++) {
              const mod = minecraftScriptModules[i];

              if (content.indexOf(mod.id) >= 0) {
                if (Utilities.isUsableAsObjectKey(mod.id)) {
                  state.hasModule[mod.id] = true;
                }
              }
            }
          }
        }
      }
    }

    return state;
  }

  getFirstItemByType(itemType: ProjectItemType) {
    for (let i = 0; i < this.#items.length; i++) {
      const pi = this.#items[i];

      if (pi.itemType === itemType) {
        return pi;
      }
    }

    return undefined;
  }

  hasAddonJson() {
    return false;
  }

  private async loadFolderStructure() {
    Log.assert(!this.#isDisposed, "PLFS");

    if (this.#folderStructureLoaded) {
      return;
    }

    const projectFolder = await this.ensureProjectFolder();

    await this.processProjectFolder(projectFolder);

    this.#folderStructureLoaded = true;
  }

  private async processProjectFolder(folder: IFolder) {
    await folder.load();

    let manifest = folder.files["manifest.json"];

    if (manifest === undefined) {
      manifest = folder.files["pack_manifest.json"];
    }

    if (!this.#projectFolder) {
      throw new Error("Unexpectedly could not find a project folder.");
    }

    if (manifest) {
      let parentFolder = folder.parentFolder;

      if (parentFolder === this.#projectFolder.parentFolder) {
        parentFolder = null;
      }

      let folderContext = FolderContext.behaviorPack;
      let isWorld = false;

      if (parentFolder !== null) {
        if (MinecraftUtilities.pathLooksLikeResourcePackName(parentFolder.fullPath)) {
          folderContext = FolderContext.resourcePack;
        } else if (MinecraftUtilities.pathLooksLikeDesignPackName(parentFolder.fullPath)) {
          folderContext = FolderContext.designPack;
        } else if (MinecraftUtilities.pathLooksLikeSkinPackName(parentFolder.fullPath)) {
          folderContext = FolderContext.skinPack;
        } else if (MinecraftUtilities.pathLooksLikePersonaPackName(parentFolder.fullPath)) {
          folderContext = FolderContext.persona;
        } else if (MinecraftUtilities.pathLooksLikePersonaPackName(parentFolder.fullPath)) {
          folderContext = FolderContext.persona;
        }
      }

      const levelDat = folder.files["level.dat"];

      if (levelDat) {
        isWorld = true;
      }

      if (isWorld && this.defaultWorldFolder === null) {
        this.defaultWorldFolder = folder;

        if (parentFolder !== null) {
          this.worldContainer = parentFolder;
        }
      } else if (!isWorld && folderContext === FolderContext.resourcePack && this.defaultResourcePackFolder === null) {
        this.defaultResourcePackFolder = folder;

        if (parentFolder !== null) {
          this.resourcePacksContainer = parentFolder;
        }
      } else if (!isWorld && folderContext === FolderContext.designPack && this.defaultDesignPackFolder === null) {
        this.defaultDesignPackFolder = folder;

        if (parentFolder !== null) {
          this.designPacksContainer = parentFolder;
        }
      } else if (!isWorld && folderContext === FolderContext.skinPack && this.defaultSkinPackFolder === null) {
        this.defaultSkinPackFolder = folder;

        if (parentFolder !== null) {
          this.skinPacksContainer = parentFolder;
        }
      } else if (!isWorld && folderContext === FolderContext.persona && this.defaultPersonaPackFolder === null) {
        this.defaultPersonaPackFolder = folder;

        if (parentFolder !== null) {
          this.personaPacksContainer = parentFolder;
        }
      } else if (!isWorld && folderContext === FolderContext.behaviorPack && this.defaultBehaviorPackFolder === null) {
        this.defaultBehaviorPackFolder = folder;

        if (parentFolder !== null) {
          this.behaviorPacksContainer = parentFolder;
        }
      }
    } else {
      for (const folderName in folder.folders) {
        const childFolder = folder.folders[folderName];

        if (childFolder !== undefined && !childFolder.errorStatus) {
          await this.processProjectFolder(childFolder);
        }
      }
    }
  }

  public getItemByFile(file: IFile) {
    let projectItem = this.getItemByProjectPath(file.storageRelativePath);

    if (projectItem !== undefined) {
      return projectItem;
    }

    return this.getItemByExtendedOrProjectPath(file.extendedPath);
  }

  public getItemByProjectPath(projectPath: string): ProjectItem | undefined {
    return this.#itemsByProjectPath[ProjectUtilities.canonicalizeStoragePath(projectPath)];
  }

  public getItemByExtendedOrProjectPath(storagePath: string): ProjectItem | undefined {
    let path = ProjectUtilities.canonicalizeStoragePath(storagePath);
    let result = this.#itemsByProjectPath[path];

    if (result) {
      return result;
    }

    let nextSlash = path.indexOf("/", 1);

    if (nextSlash > 1) {
      result = this.#itemsByProjectPath[path.substring(nextSlash)];

      if (result) {
        return result;
      }
    }

    nextSlash = path.indexOf("root/", 1);

    if (nextSlash > 1) {
      nextSlash = path.indexOf("/", nextSlash + 5);

      if (nextSlash > 1) {
        result = this.#itemsByProjectPath[path.substring(nextSlash)];

        if (result) {
          return result;
        }
      }
    }

    return undefined;
  }

  public ensureItemFromFile(
    file: IFile,
    itemType: ProjectItemType,
    folderContext: FolderContext,
    creationType?: ProjectItemCreationType
  ) {
    if (this.projectFolder) {
      const projectPath = file.getFolderRelativePath(this.projectFolder);

      if (projectPath) {
        return this.ensureItemByProjectPath(
          projectPath,
          ProjectItemStorageType.singleFile,
          file.name,
          itemType,
          folderContext,
          undefined,
          creationType ? creationType : ProjectItemCreationType.normal,
          file
        );
      }
    }

    return undefined;
  }

  public ensureItemByProjectPath(
    projectPath: string,
    storageType: ProjectItemStorageType,
    name: string,
    itemType: ProjectItemType,
    context: FolderContext,
    source?: string,
    creationType?: ProjectItemCreationType,
    file?: IFile,
    tag?: string,
    isInWorld?: boolean
  ) {
    let variantName = undefined;
    let originalPath = projectPath;
    let targetVariantType: ProjectItemVariantType = ProjectItemVariantType.general;
    const projectPathLower = projectPath.toLowerCase();

    if (context === FolderContext.resourcePackSubPack) {
      const indexOfSubpacks = projectPathLower.indexOf("/subpacks/");

      if (indexOfSubpacks >= 0) {
        const nextSlash = projectPath.indexOf("/", indexOfSubpacks + 10);

        if (nextSlash >= 0) {
          targetVariantType = ProjectItemVariantType.subPack;
          variantName = projectPath.substring(indexOfSubpacks + 10, nextSlash);
          projectPath = projectPath.substring(0, indexOfSubpacks) + projectPath.substring(nextSlash);
        }
      }
    } else {
      const packsRoot = projectPathLower.indexOf("_packs/");
      if (packsRoot >= 0) {
        const packFolderNameEnd = projectPathLower.indexOf("/", packsRoot + 7);

        if (packFolderNameEnd > 0) {
          const packFolderName = projectPath.substring(packsRoot + 7, packFolderNameEnd);

          const lastUnderscore = packFolderName.lastIndexOf("_");
          if (lastUnderscore > 0) {
            const potentialVersionSection = packFolderName.substring(lastUnderscore + 1);

            if (Utilities.isNumericIsh(potentialVersionSection) && potentialVersionSection.indexOf(".") > 0) {
              variantName = potentialVersionSection;
              targetVariantType = ProjectItemVariantType.versionSlice;

              projectPath = projectPath.replace("_" + potentialVersionSection + "/", "/");
            }
          }
        }
      }
    }

    let pi = this.getItemByProjectPath(projectPath);

    if (pi !== undefined) {
      if (variantName) {
        const piv = pi.ensureVariant(variantName);

        piv.projectPath = originalPath;
        piv.variantType = targetVariantType;

        if (!piv.file && file) {
          piv.setFile(file);
        }
      } else {
        if (!pi.defaultFile && file) {
          pi.setFile(file);
        }
      }

      return pi;
    }

    const tags = [];

    if (tag) {
      tags.push(tag);
    }

    pi = this.createItem({
      itemType: itemType,
      variants: {},
      projectPath: projectPath,
      storageType: storageType,
      creationType: creationType,
      source: source,
      tags: tags,
      name: name,
    });

    if (variantName) {
      const piv = pi.ensureVariant(variantName);

      piv.variantType = targetVariantType;
      piv.projectPath = originalPath;

      if (file) {
        piv.setFile(file);
      }
    } else if (file) {
      pi.setFile(file);
    }

    if (isInWorld !== undefined) {
      pi.isInWorld = isInWorld;
    }

    if (pi.itemType === ProjectItemType.unknownJson && itemType !== ProjectItemType.unknownJson) {
      pi.itemType = itemType;
    }

    return pi;
  }

  public getItemByTag(tag: string): ProjectItem | null {
    for (const projectItem of this.#items) {
      if (projectItem.hasTag(tag)) {
        return projectItem;
      }
    }

    return null;
  }

  public hasItemOfType(type: ProjectItemType): boolean {
    for (const projectItem of this.#items) {
      if (projectItem.itemType === type) {
        return true;
      }
    }

    return false;
  }

  public getItemsByType(type: ProjectItemType): ProjectItem[] {
    const items = [];

    for (const projectItem of this.#items) {
      if (projectItem.itemType === type) {
        items.push(projectItem);
      }
    }

    return items;
  }

  public ensureItemByTag(
    tag: string,
    name: string,
    itemType: ProjectItemType,
    storagePath?: string,
    storageType?: ProjectItemStorageType,
    creationType?: ProjectItemCreationType,
    file?: IFile,
    isInWorld?: boolean
  ) {
    let pi = this.getItemByTag(tag);

    if (pi != null) {
      return pi;
    }

    pi = this.createItem({
      itemType: itemType,
      variants: {},
      projectPath: storagePath,
      storageType: storageType,
      creationType: creationType,
      tags: [tag],
      name: name,
    });

    if (file) {
      pi.setFile(file);
    }

    if (pi.itemType === ProjectItemType.unknownJson && itemType !== ProjectItemType.unknownJson) {
      pi.itemType = itemType;
    }

    return pi;
  }

  async ensureWorkingFolderForFile(file: IFile) {
    if (!this.projectFolder) {
      return undefined;
    }

    let relativePath = file.getFolderRelativePath(this.projectFolder);

    if (relativePath === undefined) {
      return undefined;
    }

    relativePath = StorageUtilities.canonicalizePath(relativePath);

    relativePath = StorageUtilities.ensureEndsWithDelimiter(relativePath.replace(/\./gi, "_"));

    const workingFolder = this.projectFolder.ensureFolder(".working");

    return await workingFolder.ensureFolderFromRelativePath(relativePath);
  }

  createItem(initialSettings: IProjectItemData) {
    this.#data.items.push(initialSettings);

    const pi = new ProjectItem(this, initialSettings);

    const path = ProjectUtilities.canonicalizeStoragePath(pi.projectPath);

    if (Utilities.isUsableAsObjectKey(path)) {
      this.#itemsByProjectPath[path] = pi;
      this.#items.push(pi);
      this.#infoSetNeedsUpdating = true;
      this._onItemAdded.dispatch(this, pi);
    }

    return pi;
  }

  async ensurePreferencesAndFolderLoadedFromFile() {
    Log.assert(!this.#isDisposed, "PLF");

    if (this.#isLoaded) {
      return;
    }

    if (this.#preferencesFile === null) {
      return;
    }

    await this.#preferencesFile.loadContent(false);

    this.hasInferredFiles = false;
    this.#items = [];
    this.#itemsByProjectPath = {};
    this.#data.items = [];

    if (Utilities.isString(this.#preferencesFile.content) && this.#preferencesFile.content != null) {
      this.#data = JSON.parse(this.#preferencesFile.content as string);
    }

    await this.ensureProjectFolder();

    this.#isLoaded = true;

    this._onLoaded.dispatch(this, this);
  }

  async ensureInflated() {
    Log.assert(!this.#isDisposed, "PLINF");

    if (this.#isInflated) {
      return;
    }

    await this.ensurePreferencesAndFolderLoadedFromFile();

    this.#items = [];
    this.#itemsByProjectPath = {};

    if (this.#data) {
      for (let i = 0; i < this.#data.items.length; i++) {
        const projectItemData = this.#data.items[i];

        const projectItem = new ProjectItem(this, projectItemData);
        const path = ProjectUtilities.canonicalizeStoragePath(projectItem.projectPath);

        if (Utilities.isUsableAsObjectKey(path)) {
          this.#itemsByProjectPath[path] = projectItem;
          this.#items.push(projectItem);

          this._onItemAdded.dispatch(this, projectItem);
        }
      }
    }

    this._onInflated.dispatch(this, this);

    this.initializeWorldSettings();
    this.ensureDefaultWorldName();

    this.#isInflated = true;
  }

  async deleteThisProject() {
    if (this.#preferencesFile) {
      await this.#preferencesFile.deleteThisFile();
    }

    await this.loadFolderStructure();

    if (this.projectFolder) {
      await this.#projectFolder?.deleteThisFolder();
    }
  }

  async saveToFile() {
    Log.assert(!this.#isDisposed, "PSF");

    if (this.#preferencesFile === null) {
      return;
    }

    const jsonString = JSON.stringify(this.#data, null, 2);

    this.#preferencesFile.setContent(jsonString);

    await this.#preferencesFile.saveContent();
  }

  private _handleDeployUpdated(message: string) {
    this.#carto.notifyStatusUpdate(message);
  }

  async save(force?: boolean) {
    Log.assert(!this.#isDisposed, "PSFA");

    if (this.#readOnlySafety) {
      throw new Error("Attempting to save project in read-only mode.");
    }

    await this.ensureProjectFolder();

    // save all things inside of file containers first
    for (let i = 0; i < this.#items.length; i++) {
      const projectItem = this.#items[i];

      if ((projectItem.needsSave || force) && projectItem.isInFileContainer) {
        await projectItem.prepareToSave();

        this.updateContentsModified();

        await this.#items[i].saveContent();
      }
    }

    // save non container files
    for (let i = 0; i < this.#items.length; i++) {
      const projectItem = this.#items[i];

      if ((projectItem.needsSave || force) && !projectItem.isInFileContainer) {
        await projectItem.prepareToSave();

        this.updateContentsModified();

        await this.#items[i].saveContent();
      }
    }

    await this.saveToFile();

    this.changedFilesSinceLastSaved = {};

    if (this.projectFolder) {
      // we should have saved everything with individual project saves, but we should also allow folders to save their state.
      await this.projectFolder.saveAll();
    }

    if (
      this.autoDeploymentMode === ProjectAutoDeploymentMode.deployOnSave &&
      this.#carto.deploymentStorage !== null &&
      this.#carto.deployBehaviorPacksFolder !== null &&
      this.#carto.activeMinecraft
    ) {
      await this.#carto.activeMinecraft.syncWithDeployment();
    }

    this._onSaved.dispatch(this, this);
  }

  async autoCompleteProject() {
    await this.ensureScriptInDestination();
    await this.ensureCatalogIndex();
    await this.ensureAutogeneratedBehaviorPackManifest();
  }

  updateProjectItemsFromContent() {
    this.#itemsByProjectPath = {};

    for (const projectItem of this.items) {
      if (projectItem && projectItem.projectPath) {
        projectItem.updateProjectPath();

        this.#itemsByProjectPath[ProjectUtilities.canonicalizeStoragePath(projectItem.projectPath)] = projectItem;
      }
    }
  }

  setProjectFolder(newFolder: IFolder) {
    if (this.#projectFolder !== newFolder) {
      this._unapplyFromProjectFolder();

      this.#projectFolder = newFolder;
      this._applyToProjectFolder();
    }

    this.#isProjectFolderEnsured = true;
  }

  async attemptToLoadPreferences() {
    if (!this.#preferencesFile && this.#projectFolder) {
      const file = await this.#projectFolder.getFileFromRelativePath("/.mct/prefs.mctp.json");

      if (file && (await file.exists())) {
        this.#preferencesFile = file;

        await this.ensurePreferencesAndFolderLoadedFromFile();
      }
    }
  }

  _unapplyFromProjectFolder() {
    if (this.#projectFolder) {
      this.#projectFolder.storage.onFileContentsUpdated.unsubscribe(this._handleProjectFileContentsUpdated);
      this.#projectFolder.onChildFolderMoved.unsubscribe(this._handleProjectFolderMoved);
    }
  }

  _applyToProjectFolder() {
    if (this.#projectFolder) {
      this.#projectFolder.storage.readOnly = this.#readOnlySafety;

      this.#projectFolder.storage.onFileContentsUpdated.subscribe(this._handleProjectFileContentsUpdated);
      this.#projectFolder.onChildFolderMoved.subscribe(this._handleProjectFolderMoved);
    }
  }

  async ensureProjectFolder(force?: boolean): Promise<IFolder> {
    if (!force && this.#projectFolder !== null && this.#isProjectFolderEnsured) {
      return this.#projectFolder;
    }

    if (
      this.#data.localFolderPath !== undefined &&
      this.#carto.ensureLocalFolder !== undefined &&
      this.#carto.localFolderExists !== undefined
    ) {
      const folderExists = await this.#carto.localFolderExists(this.#data.localFolderPath);

      if (folderExists) {
        const folder = this.#carto.ensureLocalFolder(this.#data.localFolderPath);

        if (folder !== this.#projectFolder) {
          this._unapplyFromProjectFolder();

          await folder.ensureExists();

          this.#projectFolder = folder;
          this._applyToProjectFolder();
        }
      } else {
        const folder = this.#carto.projectsStorage.rootFolder.ensureFolder(
          StorageUtilities.convertFolderPlaceholdersComplete(ProjectUtilities.canonicalizeStoragePath(this.#data.name))
        );

        if (folder !== this.#projectFolder) {
          this._unapplyFromProjectFolder();

          await folder.ensureExists();

          this.#projectFolder = folder;
          this._applyToProjectFolder();
          Log.debug(
            "Using project storage root folder as a backup because local folder path could not be found: " +
              this.#projectFolder.fullPath
          );
        }

        this.#errorState = ProjectErrorState.projectFolderOrFileDoesNotExist;
      }
    } else if (
      this.#data.mainDeployFolderPath !== undefined &&
      this.#carto.ensureLocalFolder !== undefined &&
      this.#carto.localFolderExists !== undefined
    ) {
      const folder = this.#carto.projectsStorage.rootFolder.ensureFolder(
        ProjectUtilities.canonicalizeStoragePath(this.#data.name)
      );

      if (folder !== this.#projectFolder) {
        this._unapplyFromProjectFolder();

        await folder.ensureExists();

        this.#projectFolder = folder;
        this._applyToProjectFolder();
      }

      const deployFolderExists = await this.#carto.localFolderExists(this.#data.mainDeployFolderPath);

      if (deployFolderExists) {
        const folder = this.#carto.ensureLocalFolder(this.#data.mainDeployFolderPath);

        if (folder !== this.#mainDeployFolder) {
          this.#mainDeployFolder = folder;

          this.#mainDeploySync = new ProjectDeploySync(this, folder);

          await this.#mainDeploySync.fullIngestIntoProject();
        }
      } else {
        this.#errorState = ProjectErrorState.projectFolderOrFileDoesNotExist;
      }
    } else if (
      this.#data.mainDeployFolderPath !== undefined &&
      this.#carto.isDeployingToComMojang &&
      this.#carto.deploymentStorage
    ) {
      const folder = this.#carto.projectsStorage.rootFolder.ensureFolder(
        ProjectUtilities.canonicalizeStoragePath(this.#data.name)
      );

      if (folder !== this.#projectFolder) {
        this._unapplyFromProjectFolder();
        await folder.ensureExists();
        this.#projectFolder = folder;
        this._applyToProjectFolder();
      }

      const deployFolder = await this.#carto.deploymentStorage.ensureFolderFromStorageRelativePath(
        this.#data.mainDeployFolderPath
      );
      const deployFolderExists = await deployFolder.exists();

      if (deployFolderExists) {
        if (deployFolder !== this.#mainDeployFolder) {
          this.#mainDeployFolder = folder;
          this.#mainDeploySync = new ProjectDeploySync(this, deployFolder);

          await this.#mainDeploySync.fullIngestIntoProject();
        }
      } else {
        this.#errorState = ProjectErrorState.projectFolderOrFileDoesNotExist;
      }
    } else if (
      this.#data.localFilePath !== undefined &&
      this.#carto.ensureLocalFolder !== undefined &&
      this.#carto.localFileExists !== undefined &&
      this.#carto.localFolderExists !== undefined
    ) {
      const folderPath = StorageUtilities.getFolderPath(this.#data.localFilePath);
      const fileName = StorageUtilities.getLeafName(this.#data.localFilePath);

      if (!fileName || fileName.length < 2 || !folderPath || folderPath.length < 2) {
        throw new Error("Could not process file with path: `" + this.#data.localFilePath + "`");
      }

      const containingFolder = this.#carto.ensureLocalFolder(folderPath);

      const file = containingFolder.ensureFile(fileName);

      const fileExists = await file.exists();

      if (fileExists) {
        this.#projectCabinetFile = file;

        await this.ensureProjectFolderFromCabinet();

        Log.assert(
          this.#projectFolder !== null && this.#projectFolder !== undefined,
          "Could not create a project folder from " + this.#data.localFilePath + "." + this.errorMessage
            ? " " + this.errorMessage
            : ""
        );

        if (this.#accessoryFilePaths && this.#projectFolder) {
          for (let i = 0; i < this.#accessoryFilePaths.length; i++) {
            if (
              (this.#accessoryFilePaths[i].startsWith("\\") || this.#accessoryFilePaths[i].indexOf(":") >= 0) &&
              this.carto.localFileExists &&
              this.carto.ensureLocalFolder
            ) {
              if (StorageUtilities.isUsableFile(this.#accessoryFilePaths[i])) {
                const exists = await this.carto.localFileExists(this.#accessoryFilePaths[i]);

                if (exists) {
                  const folder = this.carto.ensureLocalFolder(
                    StorageUtilities.getFolderPath(this.#accessoryFilePaths[i])
                  );

                  if (folder) {
                    folder.storage.readOnly = true;

                    const fileName = StorageUtilities.getLeafName(this.#accessoryFilePaths[i]);
                    await folder.load();
                    const file = folder.files[fileName];

                    if (file && (await file.exists())) {
                      if (this.#accessoryFoldersForFilePaths === null) {
                        this.#accessoryFoldersForFilePaths = [];
                      }
                      this.#accessoryFoldersForFilePaths.push(file.parentFolder);
                      this._inferProjectItemFromFile(file, file.parentFolder, file.storageRelativePath);
                    }
                  }
                }
              }
            } else {
              const addFile = containingFolder.ensureFile(this.#accessoryFilePaths[i]);

              const additionalFileExists = await addFile.exists();
              if (additionalFileExists) {
                let isChildOfExistingFolder = false;

                if (this.#accessoryFoldersForFilePaths === null) {
                  this.#accessoryFoldersForFilePaths = [];
                }

                for (let j = 0; j < this.#accessoryFoldersForFilePaths.length; j++) {
                  let addFileStoragePath = addFile.getFolderRelativePath(this.#accessoryFoldersForFilePaths[j]);

                  if (addFileStoragePath) {
                    isChildOfExistingFolder = true;
                    this._inferProjectItemFromFile(addFile, this.#accessoryFoldersForFilePaths[j], addFileStoragePath);
                  }
                }

                if (!isChildOfExistingFolder) {
                  if (addFile.parentFolder) {
                    let addFileStoragePath = addFile.getFolderRelativePath(addFile.parentFolder);
                    if (addFileStoragePath) {
                      this.#accessoryFoldersForFilePaths.push(addFile.parentFolder);
                      this._inferProjectItemFromFile(addFile, addFile.parentFolder, addFileStoragePath);
                    }
                  }
                }
              }
            }
          }
        }
      }

      if (!this.#projectFolder) {
        const folder = this.#carto.projectsStorage.rootFolder.ensureFolder(
          ProjectUtilities.canonicalizeStoragePath(this.#data.name)
        );
        if (folder !== this.#projectFolder) {
          this._unapplyFromProjectFolder();
          this.#projectFolder = folder;
          this._applyToProjectFolder();
        }

        this.#errorState = ProjectErrorState.projectFolderOrFileDoesNotExist;
      }
    } else if (this.#useProjectNameInProjectStorage) {
      const folder = this.#carto.projectsStorage.rootFolder.ensureFolder(this.name);

      if (folder !== this.#projectFolder) {
        this._unapplyFromProjectFolder();
        this.#projectFolder = folder;
        this._applyToProjectFolder();
      }
    } else {
      // Log.debug("Using project storage root folder subfolder: " + this.#data.dataStorageRelativePath);

      const folder = await this.#carto.projectsStorage.ensureFolderFromStorageRelativePath(
        this.#data.dataStorageRelativePath
      );

      if (folder !== this.#projectFolder) {
        this._unapplyFromProjectFolder();
        this.#projectFolder = folder;
        this._applyToProjectFolder();
      }
    }

    const result = await this.#projectFolder.ensureExists();

    this.#isProjectFolderEnsured = result;

    return this.#projectFolder;
  }

  async _inferProjectItemFromFile(file: IFile, folder: IFolder, fileStoragePath: string) {
    const fileName = StorageUtilities.canonicalizeName(file.name);

    if (fileName.endsWith(".data.json")) {
      this.ensureItemByProjectPath(
        fileStoragePath,
        ProjectItemStorageType.singleFile,
        file.name,
        ProjectItemType.projectSummaryMetadata,
        FolderContext.metaData,
        undefined,
        ProjectItemCreationType.normal,
        file
      );
    } else if (fileName.endsWith(".tags.json")) {
      this.ensureItemByProjectPath(
        fileStoragePath,
        ProjectItemStorageType.singleFile,
        file.name,
        ProjectItemType.tagsMetadata,
        FolderContext.metaData,
        undefined,
        ProjectItemCreationType.normal,
        file
      );
    }
  }

  _handleProjectFolderMoved(folder: IFolder, folderMove: IFolderMove) {
    // refresh project paths from files/folders where possible
    this.updateProjectItemsFromContent();

    if (folderMove.previousStoragePath && this.#projectFolder) {
      const newProjectPath = folderMove.folder.getFolderRelativePath(this.#projectFolder);

      if (newProjectPath) {
        const storageRelativeComponent = this.#projectFolder.fullPath.substring(
          0,
          folderMove.folder.fullPath.length - newProjectPath.length + 1
        );

        let previousPath = folderMove.previousStoragePath;

        if (previousPath.startsWith(storageRelativeComponent)) {
          previousPath = previousPath.substring(storageRelativeComponent.length);
        }

        for (const item of this.items) {
          if (item && item.projectPath && item.projectPath.startsWith(previousPath)) {
            item.projectPath = newProjectPath + item.projectPath.substring(previousPath.length);
          }
        }
      }
    }
  }

  async _handleProjectFileContentsUpdated(storage: IStorage, file: IFile) {
    if (!this.#projectFolder) {
      return;
    }

    let rootRelativePath = file.storageRelativePath;
    this.#infoSetNeedsUpdating = true;

    if (
      this.#projectFolder.storageRelativePath.length > 0 &&
      rootRelativePath.startsWith(this.#projectFolder.storageRelativePath)
    ) {
      rootRelativePath = rootRelativePath.substring(this.#projectFolder.storageRelativePath.length - 1);
    }

    const storagePath = ProjectUtilities.canonicalizeStoragePath(rootRelativePath);

    if (Utilities.isUsableAsObjectKey(storagePath)) {
      if (!this.changedFilesSinceLastSaved[storagePath]) {
        this.changedFilesSinceLastSaved[storagePath] = file;

        this._onNeedsSaveChanged.dispatch(this, this);
      }

      const item = this.#itemsByProjectPath[storagePath];
      if (item) {
        this.notifyProjectItemChanged(item);
      }
    }
  }

  async ensureDistFolder(): Promise<IFolder> {
    if (this.#distBuildFolder) {
      return this.#distBuildFolder;
    }

    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.#distBuildFolder === null) {
      this.#distBuildFolder = this.#projectFolder.ensureFolder("dist");
      await this.#distBuildFolder.ensureExists();
    }

    return this.#distBuildFolder;
  }

  async ensureDistBuildScriptsFolder(): Promise<IFolder> {
    if (this.#distBuildScriptsFolder) {
      return this.#distBuildScriptsFolder;
    }

    await this.ensureDistFolder();

    if (this.#distBuildFolder === undefined || this.#distBuildFolder === null) {
      throw new Error("Unexpectedly could not create dist folder");
    }

    if (this.#distBuildScriptsFolder === null) {
      this.#distBuildScriptsFolder = this.#distBuildFolder.ensureFolder("scripts");
      await this.#distBuildScriptsFolder.ensureExists();
    }

    return this.#distBuildScriptsFolder;
  }

  getLibFolder(): IFolder | null {
    if (this.#libFolder) {
      return this.#libFolder;
    }

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      return null;
    }

    if (this.#libFolder === null) {
      this.#libFolder = this.#projectFolder.ensureFolder("lib");
    }

    return this.#libFolder;
  }

  getDistBuildFolder(): IFolder | null {
    if (this.#distBuildFolder) {
      return this.#distBuildFolder;
    }

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      return null;
    }

    if (this.#distBuildFolder === null) {
      this.#distBuildFolder = this.#projectFolder.ensureFolder("dist");
    }

    return this.#distBuildFolder;
  }

  async ensureLibFolder(): Promise<IFolder> {
    if (this.#libFolder) {
      return this.#libFolder;
    }

    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.#libFolder === null) {
      this.#libFolder = this.#projectFolder.ensureFolder("lib");
      await this.#libFolder.ensureExists();
    }

    return this.#libFolder;
  }

  getLibScriptsFolder(): IFolder | null {
    if (this.#libScriptsFolder) {
      return this.#libScriptsFolder;
    }

    const libFolder = this.getLibFolder();

    if (libFolder) {
      this.#libScriptsFolder = libFolder.ensureFolder("scripts");
    }

    return this.#libScriptsFolder;
  }

  getDistBuildScriptsFolder(): IFolder | null {
    if (this.#distBuildScriptsFolder) {
      return this.#distBuildScriptsFolder;
    }

    const distFolder = this.getDistBuildFolder();

    if (distFolder) {
      this.#distBuildScriptsFolder = distFolder.ensureFolder("scripts");
    }

    return this.#distBuildScriptsFolder;
  }

  async ensureLibScriptsFolder(): Promise<IFolder> {
    if (this.#libScriptsFolder) {
      return this.#libScriptsFolder;
    }

    await this.ensureLibFolder();

    if (this.#libFolder === undefined || this.#libFolder === null) {
      throw new Error("Unexpectedly could not create dist folder");
    }

    if (this.#libScriptsFolder === null) {
      this.#libScriptsFolder = this.#libFolder.ensureFolder("scripts");
      await this.#libScriptsFolder.ensureExists();
    }

    return this.#libScriptsFolder;
  }

  async ensureDocsFolder(): Promise<IFolder> {
    if (this.docsContainer !== null) {
      return this.docsContainer;
    }

    const rootFolder = await this.ensureProjectFolder();

    this.docsContainer = rootFolder.ensureFolder("docs");

    return this.docsContainer;
  }

  async ensureDefaultScriptsFolder(): Promise<IFolder> {
    if (this.#defaultScriptsFolder !== null) {
      return this.#defaultScriptsFolder;
    }

    for (let i = 0; i < this.items.length; i++) {
      const pi = this.items[i];

      if (pi.itemType === ProjectItemType.js || pi.itemType === ProjectItemType.ts) {
        await pi.ensureFileStorage();

        if (pi.primaryFile) {
          this.#defaultScriptsFolder = pi.primaryFile.parentFolder;

          if (this.#defaultScriptsFolder !== null) {
            return this.#defaultScriptsFolder;
          }
        }
      }
    }

    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.#defaultScriptsFolder !== null) {
      return this.#defaultScriptsFolder;
    }

    if (this.#defaultScriptsFolder === null) {
      await this.#projectFolder.load();

      const rootScriptsFolder = this.#projectFolder.folders["scripts"];

      if (rootScriptsFolder) {
        const rootScriptsFolderExists = await rootScriptsFolder.exists();

        if (rootScriptsFolderExists) {
          this.#defaultScriptsFolder = rootScriptsFolder;
          return this.#defaultScriptsFolder;
        }
      }
    }

    const defaultBehaviorPackFolder = await this.ensureDefaultBehaviorPackFolder();

    if (!defaultBehaviorPackFolder) {
      return this.#projectFolder.ensureFolder("scripts");
    }

    const defaultBehaviorPackScriptsFolder = defaultBehaviorPackFolder.ensureFolder("scripts");

    await defaultBehaviorPackScriptsFolder.ensureExists();

    this.#defaultScriptsFolder = defaultBehaviorPackScriptsFolder;

    return this.#defaultScriptsFolder;
  }

  async getDefaultWorldFolder(): Promise<IFolder | null> {
    if (this.defaultWorldFolder !== null) {
      return this.defaultWorldFolder;
    }

    await this.loadFolderStructure();

    return this.defaultWorldFolder;
  }

  async ensurePacks() {
    for (const item of this.items) {
      if (item.itemType === ProjectItemType.behaviorPackManifestJson) {
        await item.ensureStorage();
        const file = item.primaryFile;

        if (file && file.parentFolder) {
          await this.ensurePackByFolder(file.parentFolder, PackType.behavior);
        }
      } else if (item.itemType === ProjectItemType.resourcePackManifestJson) {
        await item.ensureStorage();
        const file = item.primaryFile;

        if (file && file.parentFolder) {
          await this.ensurePackByFolder(file.parentFolder, PackType.resource);
        }
      } else if (item.itemType === ProjectItemType.skinPackManifestJson) {
        await item.ensureStorage();
        const file = item.primaryFile;

        if (file && file.parentFolder) {
          await this.ensurePackByFolder(file.parentFolder, PackType.skin);
        }
      } else if (item.itemType === ProjectItemType.designPackManifestJson) {
        await item.ensureStorage();
        const file = item.primaryFile;

        if (file && file.parentFolder) {
          await this.ensurePackByFolder(file.parentFolder, PackType.design);
        }
      } else if (item.itemType === ProjectItemType.personaManifestJson) {
        await item.ensureStorage();
        const file = item.primaryFile;

        if (file && file.parentFolder) {
          await this.ensurePackByFolder(file.parentFolder, PackType.persona);
        }
      }
    }
  }

  async ensurePacksAsync() {
    for (const item of this.items) {
      if (item.itemType === ProjectItemType.behaviorPackManifestJson) {
        await item.ensureFileStorage();
        const file = item.primaryFile;

        if (file && file.parentFolder) {
          await this.ensurePackByFolder(file.parentFolder, PackType.behavior);
        }
      } else if (item.itemType === ProjectItemType.resourcePackManifestJson) {
        await item.ensureFileStorage();
        const file = item.primaryFile;

        if (file && file.parentFolder) {
          await this.ensurePackByFolder(file.parentFolder, PackType.resource);
        }
      } else if (item.itemType === ProjectItemType.skinPackManifestJson) {
        await item.ensureFileStorage();
        const file = item.primaryFile;

        if (file && file.parentFolder) {
          await this.ensurePackByFolder(file.parentFolder, PackType.skin);
        }
      } else if (item.itemType === ProjectItemType.designPackManifestJson) {
        await item.ensureFileStorage();
        const file = item.primaryFile;

        if (file && file.parentFolder) {
          await this.ensurePackByFolder(file.parentFolder, PackType.design);
        }
      } else if (item.itemType === ProjectItemType.personaManifestJson) {
        await item.ensureFileStorage();
        const file = item.primaryFile;

        if (file && file.parentFolder) {
          await this.ensurePackByFolder(file.parentFolder, PackType.persona);
        }
      }
    }
  }
  async getDefaultBehaviorPackFolder(force?: boolean, preventEnsureFileStorage?: boolean): Promise<IFolder | null> {
    if (this.defaultBehaviorPackFolder !== null && !force) {
      return this.defaultBehaviorPackFolder;
    }

    await this.loadFolderStructure();

    if (this.defaultBehaviorPackFolder !== null && !force) {
      return this.defaultBehaviorPackFolder;
    }

    if (force) {
      this.defaultBehaviorPackFolder = null;
    }

    for (let i = 0; i < this.items.length; i++) {
      const pi = this.items[i];

      if (pi.itemType === ProjectItemType.behaviorPackManifestJson) {
        if (!preventEnsureFileStorage) {
          // this is an option to avoid stack overflows of ensureFileStorage -> updateAutogenerated -> ensureFileStorage
          await pi.ensureFileStorage();
        }

        const itemFile = pi.primaryFile;

        if (itemFile) {
          this.defaultBehaviorPackFolder = itemFile.parentFolder;

          this.ensurePackByFolder(this.defaultBehaviorPackFolder, PackType.behavior, pi.isInWorld);

          if (this.defaultBehaviorPackFolder !== null) {
            return this.defaultBehaviorPackFolder;
          }
        }
      }
    }

    return this.defaultBehaviorPackFolder;
  }

  async getDefaultBehaviorPack(): Promise<Pack | undefined> {
    const folder = await this.getDefaultBehaviorPackFolder(false, false);

    if (!folder) {
      return undefined;
    }

    return await this.ensurePackByFolder(folder, PackType.behavior);
  }

  async ensureDefaultBehaviorPackFolder(force?: boolean): Promise<IFolder> {
    if (this.defaultBehaviorPackFolder !== null && !force) {
      return this.defaultBehaviorPackFolder;
    }

    await this.getDefaultBehaviorPackFolder(force);

    if (this.defaultBehaviorPackFolder !== null) {
      return this.defaultBehaviorPackFolder;
    }

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.behaviorPacksContainer === null) {
      this.behaviorPacksContainer = this.#projectFolder.ensureFolder("behavior_packs");
      await this.behaviorPacksContainer.ensureExists();
    }

    this.defaultBehaviorPackFolder = this.behaviorPacksContainer.ensureFolder(
      MinecraftUtilities.makeNameFolderSafe(this.effectiveShortName + "_bp")
    );

    await this.defaultBehaviorPackFolder.ensureExists();

    const pack = await this.ensurePackByFolder(this.defaultBehaviorPackFolder, PackType.behavior, false);
    await pack.ensureManifest();

    return this.defaultBehaviorPackFolder;
  }

  async ensureDefaultDesignPackFolder(force?: boolean): Promise<IFolder> {
    if (this.defaultDesignPackFolder !== null && !force) {
      return this.defaultDesignPackFolder;
    }

    await this.getDefaultDesignPackFolder(force);

    if (this.defaultDesignPackFolder !== null) {
      return this.defaultDesignPackFolder;
    }

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.designPacksContainer === null) {
      this.designPacksContainer = this.#projectFolder.ensureFolder("design_packs");
      await this.designPacksContainer.ensureExists();
    }

    this.defaultDesignPackFolder = this.designPacksContainer.ensureFolder(
      MinecraftUtilities.makeNameFolderSafe(this.effectiveShortName + "_dp")
    );

    await this.defaultDesignPackFolder.ensureExists();

    await this.ensurePackByFolder(this.defaultDesignPackFolder, PackType.design, false);

    return this.defaultDesignPackFolder;
  }

  async ensurePackByFolder(folder: IFolder, packType: PackType, isInWorld?: boolean) {
    const targetPath = StorageUtilities.canonicalizePath(folder.extendedPath);

    if (!this.projectFolder) {
      throw new Error("PEPBF");
    }

    for (const pack of this.#packs) {
      if (pack.folder === folder) {
        return pack;
      }

      if (pack.folder && StorageUtilities.canonicalizePath(pack.folder.extendedPath) === targetPath) {
        return pack;
      }
    }

    let itemType = ProjectItemType.behaviorPackFolder;
    let folderContext = FolderContext.behaviorPack;

    if (packType === PackType.resource) {
      itemType = ProjectItemType.resourcePackFolder;
      folderContext = FolderContext.resourcePack;
    } else if (packType === PackType.skin) {
      itemType = ProjectItemType.skinPackFolder;
      folderContext = FolderContext.skinPack;
    } else if (packType === PackType.persona) {
      itemType = ProjectItemType.personaPackFolder;
      folderContext = FolderContext.persona;
    } else if (packType === PackType.design) {
      itemType = ProjectItemType.designPackFolder;
      folderContext = FolderContext.designPack;
    }

    const folderPath = folder.getFolderRelativePath(this.projectFolder);

    if (!folderPath) {
      throw new Error("PEBBFA");
    }

    const folderProjectItem = this.ensureItemByProjectPath(
      folderPath,
      ProjectItemStorageType.folder,
      folder.name,
      itemType,
      folderContext,
      undefined,
      ProjectItemCreationType.normal,
      undefined,
      undefined,
      isInWorld
    );

    const newPack = Pack.ensureOnFolder(folder, packType, this, folderProjectItem);

    if (!this.#packs.includes(newPack)) {
      this.#packs.push(newPack);
    }

    await newPack.ensureManifest();

    return newPack;
  }

  async getDefaultDesignPackFolder(force?: boolean): Promise<IFolder | null> {
    if (this.defaultDesignPackFolder !== null && !force) {
      return this.defaultDesignPackFolder;
    }

    await this.loadFolderStructure();

    if (this.defaultDesignPackFolder !== null && !force) {
      return this.defaultDesignPackFolder;
    }

    if (force) {
      this.defaultDesignPackFolder = null;
    }

    for (let i = 0; i < this.items.length; i++) {
      const pi = this.items[i];

      if (pi.itemType === ProjectItemType.designPackManifestJson) {
        await pi.ensureFileStorage();

        if (pi.primaryFile) {
          this.defaultDesignPackFolder = pi.primaryFile.parentFolder;

          await this.ensurePackByFolder(this.defaultDesignPackFolder, PackType.design, pi.isInWorld);

          if (this.defaultDesignPackFolder !== null) {
            return this.defaultDesignPackFolder;
          }
        }
      }
    }

    return null;
  }

  async getDefaultSkinPackFolder(force?: boolean): Promise<IFolder | null> {
    if (this.defaultSkinPackFolder !== null && !force) {
      return this.defaultSkinPackFolder;
    }

    await this.loadFolderStructure();

    if (this.defaultSkinPackFolder !== null && !force) {
      return this.defaultSkinPackFolder;
    }

    if (force) {
      this.defaultSkinPackFolder = null;
    }

    for (let i = 0; i < this.items.length; i++) {
      const pi = this.items[i];

      if (pi.itemType === ProjectItemType.skinPackManifestJson) {
        await pi.ensureFileStorage();

        if (pi.primaryFile) {
          this.defaultSkinPackFolder = pi.primaryFile.parentFolder;

          await this.ensurePackByFolder(this.defaultSkinPackFolder, PackType.skin, pi.isInWorld);

          if (this.defaultSkinPackFolder !== null) {
            return this.defaultSkinPackFolder;
          }
        }
      }
    }

    return null;
  }

  async getDefaultResourcePackFolder(force?: boolean): Promise<IFolder | null> {
    if (this.defaultResourcePackFolder !== null && !force) {
      return this.defaultResourcePackFolder;
    }

    await this.loadFolderStructure();

    if (this.defaultResourcePackFolder !== null && !force) {
      return this.defaultResourcePackFolder;
    }

    if (force) {
      this.defaultResourcePackFolder = null;
    }

    for (let i = 0; i < this.items.length; i++) {
      const pi = this.items[i];

      if (pi.itemType === ProjectItemType.resourcePackManifestJson) {
        await pi.ensureFileStorage();

        if (pi.primaryFile) {
          this.defaultResourcePackFolder = pi.primaryFile.parentFolder;

          await this.ensurePackByFolder(this.defaultResourcePackFolder, PackType.resource, pi.isInWorld);

          if (this.defaultResourcePackFolder !== null) {
            return this.defaultResourcePackFolder;
          }
        }
      }
    }

    return null;
  }

  async ensureDefaultResourcePackFolder(force?: boolean): Promise<IFolder> {
    if (this.defaultResourcePackFolder !== null && !force) {
      return this.defaultResourcePackFolder;
    }

    if (force) {
      this.defaultResourcePackFolder = null;
    }

    await this.getDefaultResourcePackFolder(force);

    if (this.defaultResourcePackFolder !== null) {
      return this.defaultResourcePackFolder;
    }

    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.defaultResourcePackFolder !== null) {
      return this.defaultResourcePackFolder;
    }

    if (this.resourcePacksContainer === null) {
      this.resourcePacksContainer = this.#projectFolder.ensureFolder("resource_packs");
      await this.resourcePacksContainer.ensureExists();
    }

    this.defaultResourcePackFolder = this.resourcePacksContainer.ensureFolder(
      MinecraftUtilities.makeNameFolderSafe(this.effectiveShortName + "_rp")
    );

    await this.defaultResourcePackFolder.ensureExists();

    await this.ensurePackByFolder(this.defaultResourcePackFolder, PackType.resource);

    return this.defaultResourcePackFolder;
  }

  async ensureLoadedProjectFolder(force?: boolean): Promise<IFolder> {
    const projectFolder = await this.ensureProjectFolder();

    await projectFolder.load(force ? force : false);

    if (!this.readOnlySafety) {
      await this.save();
    }

    return projectFolder;
  }
}
