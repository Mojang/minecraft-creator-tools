// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import IFile from "../storage/IFile";
import IFolder from "../storage/IFolder";
import Carto from "./Carto";
import IProjectData, {
  ProjectEditPreference,
  ProjectRole,
  ProjectScriptLanguage,
  ProjectScriptVersion,
} from "./IProjectData";
import { ProjectDataType, ProjectFocus } from "./IProjectData";
import ProjectItem from "./ProjectItem";
import IProjectItemData, { ProjectItemCreationType, ProjectItemStorageType, ProjectItemType } from "./IProjectItemData";
import Utilities from "./../core/Utilities";
import { EventDispatcher } from "ste-events";
import StorageUtilities from "../storage/StorageUtilities";
import ProjectContent from "./ProjectContent";
import GitHubStorage from "../github/GitHubStorage";
import Log from "../core/Log";
import DifferenceSet from "../storage/DifferenceSet";
import IAddonManifest from "../minecraft/IAddonManifest";
import IProjectScriptState from "./IProjectScriptState";
import ProjectUtilities from "./ProjectUtilities";
import IStorage, { IFolderMove } from "../storage/IStorage";
import { GameType, Generator } from "../minecraft/WorldLevelDat";
import { BackupType } from "../minecraft/IWorldSettings";
import BehaviorManifestDefinition from "../minecraft/BehaviorManifestDefinition";
import MinecraftUtilities from "../minecraft/MinecraftUtilities";
import LocManager from "../minecraft/LocManager";
import ProjectInfoSet from "../info/ProjectInfoSet";
import ProjectUpdateRunner from "../updates/ProjectUpdateRunner";
import ProjectUpdateResult from "../updates/ProjectUpdateResult";
import { StatusTopic, StatusType } from "./Status";
import { ProjectInfoSuite } from "../info/IProjectInfoData";
import Pack, { PackType } from "../minecraft/Pack";
import { IErrorable } from "../core/IErrorable";
import ProjectDeploySync from "./ProjectDeploySync";
import { MinecraftTrack } from "./ICartoData";
import ProjectItemRelations from "./ProjectItemRelations";
import ResourceManifestDefinition from "../minecraft/ResourceManifestDefinition";

export enum ProjectAutoDeploymentMode {
  deployOnSave = 0,
  noAutoDeployment = 1,
}

export enum ProjectErrorState {
  noError = 0,
  projectFolderOrFileDoesNotExist = 1,
}

export enum FolderContext {
  unknown = 0,
  behaviorPack = 1,
  resourcePack = 2,
  skinPack = 3,
  docs = 4,
  world = 5,
  typeDefs = 6,
  distBuildFolder = 7,
  vscodeFolder = 8,
  resourcePackSubPack = 9,
  metaData = 10,
  libFolder = 11,
}

export const ProjectTargetStrings = [
  "<default>",
  "Latest Minecraft Bedrock",
  "Latest Minecraft Bedrock preview",
  "Latest Minecraft Education",
  "Latest Minecraft Education preview",
];

export const AUTOGENERATED_CONTENT_TOKEN = "==== AUTOGENERATED";
export const AUTOGENERATED_JS_SEPARATOR =
  "\r\n// ===== AUTOGENERATED CONTENT ===== CONTENT AT OR BELOW THIS LINE WILL BE WIPED AND UPDATED WHEN USED IN TOOLING";
export const AUTOGENERATED_WHOLEFILE_JS_SEPARATOR =
  "// ===== AUTOGENERATED FILE ===== CONTENT WITHIN THIS FILE WILL BE WIPED AND UPDATED WHEN USED IN TOOLING";
export const AUTOGENERATED_WHOLEFILE_MCFUNCTION_SEPARATOR =
  "# ===== AUTOGENERATED FILE ===== CONTENT WITHIN THIS FILE WILL BE WIPED AND UPDATED WHEN USED IN TOOLING";
export const AUTOGENERATED_WHOLEFILE_GENERAL_SEPARATOR =
  "===== AUTOGENERATED FILE ===== CONTENT WITHIN THIS FILE WILL BE WIPED AND UPDATED WHEN USED IN TOOLING";

export const minecraftScriptModules: {
  id: string;
  module_name?: string;
  uuid?: string;
  preferredVersion: string | number[];
}[] = [
  { id: "@minecraft/server", module_name: "@minecraft/server", preferredVersion: "1.12.0-beta" },
  { id: "@minecraft/server-gametest", module_name: "@minecraft/server-gametest", preferredVersion: "1.0.0-beta" },
  { id: "@minecraft/server-ui", module_name: "@minecraft/server-ui", preferredVersion: "1.2.0-beta" },
  { id: "@minecraft/server-admin", module_name: "@minecraft/server-admin", preferredVersion: "1.0.0-beta" },
  { id: "@minecraft/server-net", module_name: "@minecraft/server-net", preferredVersion: "1.0.0-beta" },
  { id: "@minecraft/server-editor", module_name: "@minecraft/server-editor", preferredVersion: "0.1.0-beta" },
];

export const remappedMinecraftScriptModules: { [oldModuleName: string]: string } = {
  "mojang-minecraft": "@minecraft/server",
  "mojang-gametest": "@minecraft/server-gametest",
  "mojang-minecraft-ui": "@minecraft/server-ui",
  "mojang-server-admin": "@minecraft/server-admin",
  "mojang-net": "@minecraft/server-net",
  "@minecraft/server-editor-bindings": "@minecraft/server-editor",
};

export default class Project {
  #data: IProjectData;
  #file: IFile | null;
  #carto: Carto;
  loc: LocManager;
  #errorState = ProjectErrorState.noError;
  #infoSet: ProjectInfoSet | null = null;

  #gitHubStorage?: GitHubStorage;

  public differencesFromGitHub?: DifferenceSet;

  #folderStructureLoaded: boolean = false;

  #mainDeployFolder: IFolder | null = null;
  #projectFolder: IFolder | null;
  #projectCabinetFile: IFile | null = null;

  #distBuildFolder: IFolder | null = null;
  #libFolder: IFolder | null = null;

  #distBuildScriptsFolder: IFolder | null = null;
  #libScriptsFolder: IFolder | null = null;

  #docsContainer: IFolder | null;

  #worldContainer: IFolder | null = null;

  #mainDeploySync: ProjectDeploySync | null = null;

  #isDisposed: boolean = false;

  #behaviorPacksContainer: IFolder | null;
  #defaultBehaviorPackFolder: IFolder | null;

  #skinPacksContainer: IFolder | null;
  #defaultSkinPackFolder: IFolder | null;

  #packs: Pack[] = [];

  #defaultWorldFolder: IFolder | null;

  #defaultScriptsFolder: IFolder | null;

  #resourcePacksContainer: IFolder | null;
  #defaultResourcePackFolder: IFolder | null;

  #items: ProjectItem[];
  #itemsByProjectPath: { [storagePath: string]: ProjectItem | undefined } = {};

  public changedFilesSinceLastSaved: { [storagePath: string]: IFile | undefined } = {};

  #isLoaded = false;
  #isInflated = false;

  #isProjectFolderEnsured = false;
  #useProjectNameInProjectStorage = false;

  #accessoryFilePaths: string[] | undefined;
  #accessoryFoldersForFilePaths: IFolder[] | null = null;

  #accessoryFolders: IFolder[] | null = null;

  private _onPropertyChanged = new EventDispatcher<Project, string>();
  private _onLoaded = new EventDispatcher<Project, Project>();
  private _onInflated = new EventDispatcher<Project, Project>();
  private _onSaved = new EventDispatcher<Project, Project>();
  private _onNeedsSaveChanged = new EventDispatcher<Project, Project>();
  private _onItemChanged = new EventDispatcher<Project, ProjectItem>();
  private _onItemAdded = new EventDispatcher<Project, ProjectItem>();
  private _onItemRemoved = new EventDispatcher<Project, ProjectItem>();

  #hasInferredFiles = false;
  #readOnlySafety = false;

  public get readOnlySafety() {
    return this.#readOnlySafety;
  }

  public set readOnlySafety(newReadOnly: boolean) {
    this.#readOnlySafety = newReadOnly;

    if (this.#projectFolder) {
      this.#projectFolder.storage.readOnly = this.#readOnlySafety;
    }
  }

  public get carto() {
    return this.#carto;
  }

  public get role() {
    if (this.#data.role === undefined) {
      return ProjectRole.general;
    }

    return this.#data.role;
  }

  public set role(newRole: ProjectRole) {
    this.#data.role = newRole;
  }

  public get errorState() {
    return this.#errorState;
  }

  public get file() {
    return this.#file;
  }

  public get accessoryFolders() {
    return this.#accessoryFolders;
  }

  public set accessoryFolders(folders: IFolder[] | null) {
    this.#accessoryFolders = folders;
  }

  public get accessoryFilePaths() {
    return this.#accessoryFilePaths;
  }

  public set accessoryFilePaths(files: string[] | undefined) {
    this.#accessoryFilePaths = files;
  }

  public get infoSet() {
    if (!this.#infoSet) {
      this.#infoSet = new ProjectInfoSet(this, ProjectInfoSuite.default);
    }

    return this.#infoSet;
  }

  public get collapsedStoragePaths() {
    if (!this.#data.collapsedStoragePaths) {
      this.#data.collapsedStoragePaths = [];
    }

    return this.#data.collapsedStoragePaths;
  }

  public set collapsedStoragePaths(newCollapsedPaths: string[]) {
    this.#data.collapsedStoragePaths = newCollapsedPaths;
  }

  public get packs() {
    return this.#packs;
  }

  public hasUnsavedChanges() {
    for (const filePath in this.changedFilesSinceLastSaved) {
      return true;
    }

    return false;
  }

  public getBehaviorPackCount() {
    let count = 0;
    for (const projectItem of this.items) {
      if (projectItem.itemType === ProjectItemType.behaviorPackManifestJson) {
        count++;
      }
    }

    return count;
  }

  public getResourcePackCount() {
    let count = 0;

    for (const projectItem of this.items) {
      if (projectItem.itemType === ProjectItemType.resourcePackManifestJson) {
        count++;
      }
    }

    return count;
  }

  public getIsPackFolderManaged() {
    let rpCount = 0;
    let bpCount = 0;

    for (const projectItem of this.items) {
      if (projectItem.itemType === ProjectItemType.behaviorPackManifestJson) {
        bpCount++;
      } else if (projectItem.itemType === ProjectItemType.resourcePackManifestJson) {
        rpCount++;
      }
    }

    return bpCount < 2 && rpCount < 2;
  }

  public get key() {
    if (this.localFilePath) {
      return StorageUtilities.canonicalizePath(this.localFilePath);
    }

    if (this.#projectFolder) {
      if (this.#projectFolder.name && this.#projectFolder.name.length > 0) {
        return this.#projectFolder.name;
      }

      return StorageUtilities.canonicalizePath(this.#projectFolder.fullPath);
    }

    if (this.#file) {
      return StorageUtilities.canonicalizePath(this.#file.name);
    }

    return this.title;
  }

  public get containerName() {
    if (this.localFilePath) {
      return StorageUtilities.getLeafName(this.localFilePath);
    }

    if (this.#projectFolder) {
      if (this.#projectFolder.name && this.#projectFolder.name.length > 0) {
        return this.#projectFolder.name;
      }

      return StorageUtilities.getLeafName(this.#projectFolder.fullPath);
    }

    if (this.#file) {
      return StorageUtilities.getBaseFromName(this.#file.name);
    }

    return this.title;
  }

  public get defaultNamespace(): string | undefined {
    return this.#data.defaultNamespace;
  }

  public get effectiveDefaultNamespace(): string {
    if (this.#data.defaultNamespace || this.#data.defaultNamespace === "") {
      return this.#data.defaultNamespace;
    }

    return this.effectiveShortName;
  }

  public set defaultNamespace(newDefaultNamespace: string | undefined) {
    if (newDefaultNamespace !== this.#data.defaultNamespace) {
      this.#data.defaultNamespace = newDefaultNamespace;

      this._onPropertyChanged.dispatch(this, "defaultNamespace");
    }
  }

  public get scriptEntryPoint(): string {
    if (this.#data.scriptEntryPoint || this.#data.scriptEntryPoint === "") {
      return this.#data.scriptEntryPoint;
    }

    return this.scriptEntryPoint;
  }

  public set scriptEntryPoint(newScriptEntryPoint: string) {
    if (newScriptEntryPoint !== this.#data.scriptEntryPoint) {
      this.#data.scriptEntryPoint = newScriptEntryPoint;

      this._onPropertyChanged.dispatch(this, "scriptEntryPoint");
    }
  }

  public get worldSettings() {
    return this.#data.worldSettings;
  }

  public get editorWorldSettings() {
    return this.#data.editorWorldSettings;
  }

  public ensureWorldSettings() {
    if (this.#data.worldSettings === undefined) {
      if (this.carto.worldSettings) {
        this.#data.worldSettings = this.carto.worldSettings;
      } else {
        this.initializeWorldSettings();

        if (this.#data.worldSettings === undefined) {
          throw new Error();
        }
      }
    }

    return this.#data.worldSettings;
  }

  public ensureEditorWorldSettings() {
    if (this.#data.editorWorldSettings === undefined) {
      if (this.carto.editorWorldSettings) {
        this.#data.editorWorldSettings = this.carto.editorWorldSettings;
      } else {
        this.initializeEditorWorldSettings();

        if (this.#data.editorWorldSettings === undefined) {
          throw new Error();
        }
      }
    }

    return this.#data.editorWorldSettings;
  }

  public get usesCustomWorldSettings() {
    return this.#data.usesCustomWorldSettings;
  }

  public set usesCustomWorldSettings(newValue: boolean | undefined) {
    this.#data.usesCustomWorldSettings = newValue;
  }

  public get isLoaded() {
    return this.#isLoaded;
  }

  public get isInflated() {
    return this.#isInflated;
  }

  public get distBuildFolder() {
    return this.#distBuildFolder;
  }

  public get libFolder() {
    return this.#libFolder;
  }

  public get distScriptsFolder() {
    return this.#distBuildScriptsFolder;
  }

  public get libScriptsFolder() {
    return this.#libScriptsFolder;
  }

  public get useProjectNameInRootProjectStorage() {
    return this.#useProjectNameInProjectStorage;
  }

  public set useProjectNameInRootProjectStorage(newVal: boolean) {
    this.#useProjectNameInProjectStorage = newVal;
  }

  public get onPropertyChanged() {
    return this._onPropertyChanged.asEvent();
  }

  public get onLoaded() {
    return this._onLoaded.asEvent();
  }

  public get onInflated() {
    return this._onLoaded.asEvent();
  }

  public get onSaved() {
    return this._onSaved.asEvent();
  }

  public get onNeedsSaveChanged() {
    return this._onNeedsSaveChanged.asEvent();
  }

  public get onItemChanged() {
    return this._onItemChanged.asEvent();
  }

  public get onItemAdded() {
    return this._onItemAdded.asEvent();
  }

  public get onItemRemoved() {
    return this._onItemRemoved.asEvent();
  }

  get projectFolder(): IFolder | null {
    return this.#projectFolder;
  }

  get accessoryFoldersForFilePaths(): IFolder[] | null {
    return this.#accessoryFoldersForFilePaths;
  }

  get localFolderPath(): string | undefined {
    return this.#data.localFolderPath;
  }

  set localFolderPath(newPath: string | undefined) {
    this.#data.localFolderPath = newPath;
  }

  get mainDeployFolderPath(): string | undefined {
    return this.#data.mainDeployFolderPath;
  }

  set mainDeployFolderPath(newPath: string | undefined) {
    this.#data.mainDeployFolderPath = newPath;
  }

  get localFilePath(): string | undefined {
    return this.#data.localFilePath;
  }

  set localFilePath(newPath: string | undefined) {
    this.#data.localFilePath = newPath;
  }

  get items(): ProjectItem[] {
    return this.#items;
  }

  get gitHubReferences() {
    if (this.#data.gitHubReferences === undefined) {
      this.#data.gitHubReferences = [];
    }

    return this.#data.gitHubReferences;
  }

  async getBehaviorPackScriptsFolder() {
    const bpFolder = await this.ensureDefaultBehaviorPackFolder();

    return bpFolder.folders["scripts"];
  }

  async ensureBehaviorPackScriptsFolder() {
    const bpFolder = await this.ensureDefaultBehaviorPackFolder();

    return bpFolder.ensureFolder("scripts");
  }

  async getMainScriptsFolder() {
    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    return this.#projectFolder.folders["scripts"];
  }

  async ensureMainScriptsFolder() {
    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    return this.#projectFolder.ensureFolder("scripts");
  }

  get preferredScriptLanguage() {
    if (
      this.#data.preferredScriptLanguage === undefined ||
      this.#data.preferredScriptLanguage === ProjectScriptLanguage.typeScript
    ) {
      return ProjectScriptLanguage.typeScript;
    }

    return this.#data.preferredScriptLanguage;
  }

  set preferredScriptLanguage(newLanguage: ProjectScriptLanguage) {
    this.#data.preferredScriptLanguage = newLanguage;
  }

  get scriptVersion() {
    if (this.#data.scriptVersion === undefined) {
      return ProjectScriptVersion.latestBeta;
    }

    return this.#data.scriptVersion;
  }

  get messages() {
    return this.#data.messages;
  }

  set scriptVersion(newVersion: ProjectScriptVersion) {
    this.#data.scriptVersion = newVersion;
  }

  get editPreference() {
    if (this.#data.editPreference === undefined) {
      return ProjectEditPreference.summarized;
    }

    return this.#data.editPreference;
  }

  set editPreference(newEditPreference: ProjectEditPreference) {
    this.#data.editPreference = newEditPreference;
  }

  get contentsModified() {
    let val = this.#data.contentsModified;

    if (val === null) {
      return null;
    }

    if (!(val instanceof Date)) {
      val = new Date(val);
    }

    return val;
  }

  getItemsCopy(): ProjectItem[] {
    return this.#items.slice();
  }

  public initializeWorldSettings() {
    if (this.#data.worldSettings === undefined) {
      this.#data.worldSettings = {
        gameType: GameType.creative,
        generator: Generator.infinite,
        randomSeed: "2000",
        isEditor: false,
        backupType: BackupType.every5Minutes,
        useCustomSettings: false,
      };

      this.ensureDefaultWorldName();
    }
  }

  private ensureDefaultWorldName() {
    if (this.worldSettings && this.worldSettings.name === undefined) {
      this.worldSettings.name = this.name + " " + Utilities.getDateStr(new Date());

      this.save();
    }
  }

  public initializeEditorWorldSettings() {
    if (this.#data.editorWorldSettings === undefined) {
      this.#data.editorWorldSettings = {
        gameType: GameType.creative,
        generator: Generator.infinite,
        randomSeed: "2000",
        isEditor: true,
        backupType: BackupType.every5Minutes,
        useCustomSettings: false,
      };

      this.ensureDefaultEditorWorldName();
    }
  }

  private ensureDefaultEditorWorldName() {
    if (this.editorWorldSettings && this.editorWorldSettings.name === undefined) {
      this.editorWorldSettings.name = this.name + " " + Utilities.getDateStr(new Date());

      this.save();
    }
  }

  public addMessage(message: string, context?: string, operation?: string, type?: StatusType, topic?: StatusTopic) {
    if (this.#data.messages === undefined) {
      this.#data.messages = [];
    }

    if (type === undefined) {
      type = StatusType.message;
    }

    const messageCanon = message.trim().toLowerCase();

    if (messageCanon.length > 1) {
      const status = {
        time: new Date(),
        message: message,
        context: context,
        operation: operation,
        topic: topic,
        type: type,
      };

      this.#data.messages.push(status);
    }
  }

  public appendErrors(errorable: IErrorable, operation?: string) {
    if (!errorable.errorMessages) {
      return;
    }

    for (const err of errorable.errorMessages) {
      this.carto.notifyStatusUpdate(err.message, StatusTopic.general);

      this.addMessage(err.message, err.context, operation, StatusType.message);
    }
  }

  removeItem(item: ProjectItem) {
    const newArr: ProjectItem[] = [];

    for (let i = 0; i < this.items.length; i++) {
      if (this.items[i] !== item) {
        newArr.push(this.items[i]);
      }
    }

    this.#itemsByProjectPath[ProjectUtilities.canonicalizeStoragePath(item.projectPath)] = undefined;

    this.#items = newArr;

    const newDataArr: IProjectItemData[] = [];

    for (let i = 0; i < this.#data.items.length; i++) {
      if (this.#data.items[i].projectPath !== item.projectPath) {
        newDataArr.push(this.#data.items[i]);
      }
    }

    this.#data.items = newDataArr;

    this._onItemRemoved.dispatch(this, item);
  }

  updateContentsModified() {
    this.#data.contentsModified = new Date();
  }

  get modified(): Date | null {
    if (this.#file != null && this.#file.latestModified != null) {
      if (this.contentsModified != null && this.contentsModified > this.#file.latestModified) {
        return this.contentsModified;
      }

      return this.#file.latestModified;
    } else {
      return this.contentsModified;
    }
  }

  get showHiddenItems() {
    if (this.#data.showHiddenItems === true) {
      return true;
    }

    return false;
  }

  set showHiddenItems(showItems: boolean) {
    if (showItems !== this.showHiddenItems) {
      this.#data.showHiddenItems = showItems;

      this._onPropertyChanged.dispatch(this, "showHiddenItems");
    }
  }

  get showFunctions() {
    if (this.#data.showFunctions === undefined) {
      return true;
    }

    return this.#data.showFunctions;
  }

  set showFunctions(showFunctions: boolean) {
    if (showFunctions !== this.showFunctions) {
      this.#data.showFunctions = showFunctions;

      this._onPropertyChanged.dispatch(this, "showFunctions");
    }
  }

  get showAssets() {
    if (this.#data.showAssets === undefined) {
      return true;
    }

    return this.#data.showAssets;
  }

  set showAssets(showAssets: boolean) {
    if (showAssets !== this.showAssets) {
      this.#data.showAssets = showAssets;

      this._onPropertyChanged.dispatch(this, "showAssets");
    }
  }

  get showTypes() {
    if (this.#data.showTypes === undefined) {
      return true;
    }

    return this.#data.showTypes;
  }

  set showTypes(showTypes: boolean) {
    if (showTypes !== this.showTypes) {
      this.#data.showTypes = showTypes;

      this._onPropertyChanged.dispatch(this, "showTypes");
    }
  }

  get name(): string {
    return this.#data.name;
  }

  set name(newName: string) {
    this.#data.name = newName;
  }

  get lastMapDeployedHash(): string | undefined {
    return this.#data.lastMapDeployedHash;
  }

  get lastMapDeployedDate(): Date | undefined {
    return this.#data.lastMapDeployedDate;
  }

  set lastMapDeployedHash(newValue: string | undefined) {
    this.#data.lastMapDeployedHash = newValue;
  }

  set lastMapDeployedDate(newValue: Date | undefined) {
    this.#data.lastMapDeployedDate = newValue;
  }

  get effectiveCreator(): string {
    if (this.#data.creator && this.#data.creator.length > 0) {
      return this.#data.creator;
    }

    if (this.carto.creator && this.carto.creator.length > 0) {
      return this.carto.creator;
    }

    return "contoso";
  }

  get effectiveShortName(): string {
    if (this.#data.shortName && this.#data.shortName.length > 0) {
      return this.#data.shortName;
    }
    if (this.effectiveCreator.length > 0 && this.#data.name && this.#data.name.length > 0) {
      return ProjectUtilities.getSuggestedProjectShortName(this.effectiveCreator, this.#data.name);
    }

    return "cont_game";
  }

  get shortName(): string | undefined {
    return this.#data.shortName;
  }

  set shortName(newShortName: string | undefined) {
    if (this.#data.shortName !== newShortName) {
      this.#data.shortName = newShortName;

      this._onPropertyChanged.dispatch(this, "shortName");
    }
  }

  get creator(): string | undefined {
    return this.#data.creator;
  }

  set creator(newCreator: string | undefined) {
    if (this.#data.creator !== newCreator) {
      this.#data.creator = newCreator;

      this._onPropertyChanged.dispatch(this, "creator");
    }
  }

  get title(): string {
    if (this.#data.title) {
      return this.#data.title;
    }

    return this.name;
  }

  set title(newTitle: string) {
    if (this.#data.title !== newTitle) {
      this.#data.title = newTitle;

      this._onPropertyChanged.dispatch(this, "title");
    }
  }

  get track(): MinecraftTrack | undefined {
    return this.#data.track;
  }

  set track(newTrack: MinecraftTrack | undefined) {
    if (newTrack !== this.#data.track) {
      this.#data.track = newTrack;
      this._onPropertyChanged.dispatch(this, "track");
    }
  }

  get effectiveTrack(): MinecraftTrack {
    if (this.#data.track !== undefined) {
      return this.#data.track;
    }

    return this.#carto.effectiveTrack;
  }

  set originalFullPath(newOriginalPath: string | undefined) {
    if (this.#data.originalFullPath !== newOriginalPath) {
      this.#data.originalFullPath = newOriginalPath;

      this._onPropertyChanged.dispatch(this, "originalFullPath");
    }
  }

  get originalFullPath(): string | undefined {
    return this.#data.originalFullPath;
  }

  set originalFileList(newFileList: string[] | undefined) {
    if (this.#data.originalFileList !== newFileList) {
      this.#data.originalFileList = newFileList;

      this._onPropertyChanged.dispatch(this, "originalFileList");
    }
  }

  get originalFileList(): string[] | undefined {
    return this.#data.originalFileList;
  }

  set originalGitHubOwner(newGitHubOwner: string | undefined) {
    if (this.#data.originalGitHubOwner !== newGitHubOwner) {
      this.#data.originalGitHubOwner = newGitHubOwner;

      this._onPropertyChanged.dispatch(this, "originalGitHubOwner");
    }
  }

  set originalGalleryId(newGalleryId: string | undefined) {
    if (this.#data.originalGalleryId !== newGalleryId) {
      this.#data.originalGalleryId = newGalleryId;

      this._onPropertyChanged.dispatch(this, "originalGalleryId");
    }
  }

  get originalGalleryId(): string | undefined {
    return this.#data.originalGalleryId;
  }

  set originalSampleId(newSampleId: string | undefined) {
    if (this.#data.originalSampleId !== newSampleId) {
      this.#data.originalSampleId = newSampleId;

      this._onPropertyChanged.dispatch(this, "originalSampleId");
    }
  }

  get originalSampleId(): string | undefined {
    return this.#data.originalSampleId;
  }

  get originalGitHubOwner(): string | undefined {
    return this.#data.originalGitHubOwner;
  }

  set originalGitHubFolder(newGitHubFolder: string | undefined) {
    if (this.#data.originalGitHubFolder !== newGitHubFolder) {
      this.#data.originalGitHubFolder = newGitHubFolder;

      this._onPropertyChanged.dispatch(this, "originalGitHubFolder");
    }
  }

  get originalGitHubFolder(): string | undefined {
    return this.#data.originalGitHubFolder;
  }

  set originalGitHubRepoName(newGitHubRepoName: string | undefined) {
    if (this.#data.originalGitHubRepoName !== newGitHubRepoName) {
      this.#data.originalGitHubRepoName = newGitHubRepoName;

      this._onPropertyChanged.dispatch(this, "originalGitHubRepoName");
    }
  }

  get originalGitHubRepoName(): string | undefined {
    return this.#data.originalGitHubRepoName;
  }

  set originalGitHubBranch(newGitHubBranch: string | undefined) {
    if (this.#data.originalGitHubBranch !== newGitHubBranch) {
      this.#data.originalGitHubBranch = newGitHubBranch;

      this._onPropertyChanged.dispatch(this, "originalGitHubBranch");
    }
  }

  get originalGitHubBranch(): string | undefined {
    return this.#data.originalGitHubBranch;
  }

  set gitHubOwner(newGitHubOwner: string | undefined) {
    if (this.#data.gitHubOwner !== newGitHubOwner) {
      this.#data.gitHubOwner = newGitHubOwner;

      this._onPropertyChanged.dispatch(this, "gitHubOwner");
    }
  }

  get gitHubOwner(): string | undefined {
    return this.#data.gitHubOwner;
  }

  set gitHubFolder(newGitHubFolder: string | undefined) {
    if (this.#data.gitHubFolder !== newGitHubFolder) {
      this.#data.gitHubFolder = newGitHubFolder;

      this._onPropertyChanged.dispatch(this, "gitHubFolder");
    }
  }

  get gitHubFolder(): string | undefined {
    return this.#data.gitHubFolder;
  }

  set gitHubRepoName(newGitHubRepoName: string | undefined) {
    if (this.#data.gitHubRepoName !== newGitHubRepoName) {
      this.#data.gitHubRepoName = newGitHubRepoName;

      this._onPropertyChanged.dispatch(this, "gitHubRepoName");
    }
  }

  get gitHubRepoName(): string | undefined {
    return this.#data.gitHubRepoName;
  }

  set gitHubBranch(newGitHubBranch: string | undefined) {
    if (this.#data.gitHubBranch !== newGitHubBranch) {
      this.#data.gitHubBranch = newGitHubBranch;

      this._onPropertyChanged.dispatch(this, "gitHubBranch");
    }
  }

  get gitHubBranch(): string | undefined {
    return this.#data.gitHubBranch;
  }

  get description(): string {
    return this.#data.description;
  }

  set description(newDescription: string) {
    if (this.#data.description !== newDescription) {
      this.#data.description = newDescription;

      this._onPropertyChanged.dispatch(this, "description");
    }
  }

  public async applyDescription(newTitle: string) {
    this.title = newTitle;

    if (this.editPreference === ProjectEditPreference.summarized && this.defaultBehaviorPackUniqueId) {
      for (const projectItem of this.items) {
        if (projectItem.file && projectItem.itemType === ProjectItemType.behaviorPackManifestJson) {
          const manifestJson = await BehaviorManifestDefinition.ensureOnFile(projectItem.file);

          if (
            manifestJson &&
            manifestJson.definition &&
            Utilities.uuidEqual(manifestJson.definition.header.uuid, this.defaultBehaviorPackUniqueId)
          ) {
            const header = manifestJson.ensureHeader(this.title, this.description);

            header.name = newTitle;

            manifestJson.save();
          }
        }
      }
    }
  }

  get autoDeploymentMode(): ProjectAutoDeploymentMode {
    if (this.#data.autoDeploymentMode === undefined) {
      return 0;
    }

    return this.#data.autoDeploymentMode as ProjectAutoDeploymentMode;
  }

  set autoDeploymentMode(newMode: ProjectAutoDeploymentMode) {
    if (this.#data.autoDeploymentMode !== newMode) {
      this.#data.autoDeploymentMode = newMode;

      this._onPropertyChanged.dispatch(this, "autoDeploymentMode");
    }
  }

  get version(): number[] {
    let vmj = this.#data.versionMajor;
    if (vmj === undefined) {
      vmj = 0;
    }

    let vmi = this.#data.versionMinor;
    if (vmi === undefined) {
      vmi = 0;
    }

    let vmp = this.#data.versionPatch;
    if (vmp === undefined) {
      vmp = 0;
    }

    return [vmj, vmi, vmp];
  }

  get versionMajor(): number | undefined {
    return this.#data.versionMajor;
  }

  set versionMajor(newVersion: number | undefined) {
    if (this.#data.versionMajor !== newVersion) {
      this.#data.versionMajor = newVersion;

      this._onPropertyChanged.dispatch(this, "versionMajor");
    }
  }

  get versionMinor(): number | undefined {
    return this.#data.versionMinor;
  }

  set versionMinor(newVersion: number | undefined) {
    if (this.#data.versionMinor !== newVersion) {
      this.#data.versionMinor = newVersion;

      this._onPropertyChanged.dispatch(this, "versionMinor");
    }
  }

  get versionPatch(): number | undefined {
    return this.#data.versionPatch;
  }

  set versionPatch(newVersion: number | undefined) {
    if (this.#data.versionPatch !== newVersion) {
      this.#data.versionPatch = newVersion;

      this._onPropertyChanged.dispatch(this, "versionPatch");
    }
  }

  get defaultResourcePackUniqueId(): string {
    return this.#data.defaultResourcePackUniqueId;
  }

  set defaultResourcePackUniqueId(newId: string) {
    if (this.#data.defaultResourcePackUniqueId !== newId) {
      this.#data.defaultResourcePackUniqueId = newId;

      this._onPropertyChanged.dispatch(this, "defaultResourcePackUniqueId");
    }
  }

  async setDefaultResourcePackUniqueIdAndUpdateDependencies(newId: string) {
    if (this.#data.defaultResourcePackUniqueId !== newId) {
      const oldId = this.#data.defaultResourcePackUniqueId;

      this.#data.defaultResourcePackUniqueId = newId;

      if (oldId && oldId.length > 4) {
        await ResourceManifestDefinition.setNewResourcePackId(this, newId, oldId);
      }

      this._onPropertyChanged.dispatch(this, "defaultResourcePackUniqueId");
    }
  }

  get defaultResourcePackVersion(): number[] {
    if (this.#data.defaultResourcePackVersion === undefined) {
      const vMajor = this.versionMajor ? this.versionMajor : 0;
      const vMinor = this.versionMinor ? this.versionMinor : 0;
      const vPatch = this.versionPatch ? this.versionPatch : 1;

      return [vMajor, vMinor, vPatch];
    }

    return this.#data.defaultResourcePackVersion;
  }

  set defaultResourcePackVersion(newVersion: number[]) {
    if (this.#data.defaultResourcePackVersion !== newVersion) {
      this.#data.defaultResourcePackVersion = newVersion;

      this._onPropertyChanged.dispatch(this, "defaultResourcePackVersion");
    }
  }

  get defaultBehaviorPackUniqueId(): string {
    return this.#data.defaultBehaviorPackUniqueId;
  }

  set defaultBehaviorPackUniqueId(newId: string) {
    if (this.#data.defaultBehaviorPackUniqueId !== newId) {
      this.#data.defaultBehaviorPackUniqueId = newId;

      this._onPropertyChanged.dispatch(this, "defaultBehaviorPackUniqueId");
    }
  }

  async setDefaultBehaviorPackUniqueIdAndUpdateDependencies(newId: string) {
    if (this.#data.defaultBehaviorPackUniqueId !== newId) {
      const oldId = this.#data.defaultBehaviorPackUniqueId;
      this.#data.defaultBehaviorPackUniqueId = newId;

      if (oldId && oldId.length > 4) {
        await BehaviorManifestDefinition.setNewBehaviorPackId(this, newId, oldId);
      }

      this._onPropertyChanged.dispatch(this, "defaultBehaviorPackUniqueId");
    }
  }

  get defaultBehaviorPackVersion(): number[] {
    if (this.#data.defaultBehaviorPackVersion === undefined) {
      const vMajor = this.versionMajor ? this.versionMajor : 0;
      const vMinor = this.versionMinor ? this.versionMinor : 0;
      const vPatch = this.versionPatch ? this.versionPatch : 1;

      return [vMajor, vMinor, vPatch];
    }

    return this.#data.defaultBehaviorPackVersion;
  }

  set defaultBehaviorPackVersion(newVersion: number[]) {
    if (this.#data.defaultBehaviorPackVersion !== newVersion) {
      this.#data.defaultBehaviorPackVersion = newVersion;

      this._onPropertyChanged.dispatch(this, "defaultBehaviorPackVersion");
    }
  }

  get defaultDataUniqueId(): string {
    return this.#data.defaultDataUniqueId;
  }

  set defaultDataUniqueId(newId: string) {
    if (this.#data.defaultDataUniqueId !== newId) {
      this.#data.defaultDataUniqueId = newId;

      this._onPropertyChanged.dispatch(this, "defaultDataUniqueId");
    }
  }

  async ensureScriptInDestination() {
    const bpScriptsFolder = await this.ensureBehaviorPackScriptsFolder();

    if (bpScriptsFolder === undefined) {
      return;
    }

    const coreScriptsFolderPath = StorageUtilities.canonicalizePath(bpScriptsFolder.storageRelativePath);

    for (const pi of this.#items) {
      if ((pi.itemType === ProjectItemType.testJs || pi.itemType === ProjectItemType.js) && pi.projectPath) {
        let spath = StorageUtilities.canonicalizePath(pi.projectPath);
        if (!spath.startsWith(coreScriptsFolderPath)) {
          const scriptsTokenIndex = spath.indexOf("/scripts/");
          if (scriptsTokenIndex >= 0) {
            spath = spath.substring(scriptsTokenIndex + 8);
          }

          await pi.load();

          if (pi.file && pi.file.content) {
            const item = this.ensureItemByProjectPath(
              StorageUtilities.ensureEndsWithDelimiter(coreScriptsFolderPath) +
                StorageUtilities.ensureNotStartsWithDelimiter(spath),
              ProjectItemStorageType.singleFile,
              StorageUtilities.getLeafName(spath),
              ProjectItemType.buildProcessedJs,
              undefined,
              ProjectItemCreationType.normal
            );

            const file = await item.ensureFileStorage();

            if (file) {
              file.setContent(pi.file.content);
            }
          }
        }
      }
    }
  }

  async hasScript() {
    for (const pi of this.#items) {
      if (
        pi.itemType === ProjectItemType.actionSet ||
        pi.itemType === ProjectItemType.testJs ||
        pi.itemType === ProjectItemType.js ||
        pi.itemType === ProjectItemType.buildProcessedJs ||
        pi.itemType === ProjectItemType.ts
      ) {
        return true;
      }
    }

    const scriptsFolder = await this.getBehaviorPackScriptsFolder();
    if (!scriptsFolder) {
      return false;
    }

    await scriptsFolder.load();

    if (scriptsFolder.fileCount > 0 || scriptsFolder.folderCount > 0) {
      return true;
    }

    return false;
  }

  get projectCabinetFile() {
    return this.#projectCabinetFile;
  }

  get defaultScriptModuleUniqueId(): string {
    return this.#data.defaultScriptModuleUniqueId;
  }

  set defaultScriptModuleUniqueId(newId: string) {
    if (this.#data.defaultScriptModuleUniqueId !== newId) {
      this.#data.defaultScriptModuleUniqueId = newId;

      this._onPropertyChanged.dispatch(this, "defaultScriptModuleUniqueId");
    }
  }

  get focus(): ProjectFocus {
    return this.#data.focus;
  }

  set focus(newFocus: ProjectFocus) {
    if (this.#data.focus !== newFocus) {
      this.#data.focus = newFocus;

      this._onPropertyChanged.dispatch(this, "focus");
    }
  }

  constructor(carto: Carto, name: string, file: IFile | null) {
    this._handleDeployUpdated = this._handleDeployUpdated.bind(this);
    this._handleProjectFileContentsUpdated = this._handleProjectFileContentsUpdated.bind(this);
    this.applyUpdate = this.applyUpdate.bind(this);
    this.ensureLoadedFromFile = this.ensureLoadedFromFile.bind(this);
    this.ensureProjectFolder = this.ensureProjectFolder.bind(this);
    this._handleProjectFolderMoved = this._handleProjectFolderMoved.bind(this);

    this.loc = new LocManager(this);

    this.#data = {
      dataType: ProjectDataType.clientStorage,
      storageBasePath: "",
      contentsModified: null,
      dataStorageRelativePath: "/" + name + "/",
      editPreference: ProjectEditPreference.summarized,
      name: name,
      title: name,
      description: name + " description",
      defaultBehaviorPackUniqueId: Utilities.createUuid(),
      defaultResourcePackUniqueId: Utilities.createUuid(),
      defaultScriptModuleUniqueId: Utilities.createUuid(),
      defaultDataUniqueId: Utilities.createUuid(),
      focus: ProjectFocus.general,
      items: [],
    };

    this.#file = file;

    this.#projectFolder = null;
    this.#defaultBehaviorPackFolder = null;
    this.#defaultWorldFolder = null;
    this.#defaultSkinPackFolder = null;
    this.#defaultScriptsFolder = null;
    this.#behaviorPacksContainer = null;
    this.#docsContainer = null;
    this.#defaultResourcePackFolder = null;
    this.#resourcePacksContainer = null;
    this.#skinPacksContainer = null;
    this.#worldContainer = null;

    this.#carto = carto;
    this.#items = [];
  }

  notifyProjectItemChanged(item: ProjectItem) {
    this._onItemChanged.dispatch(this, item);
  }

  clearFolders() {
    this._unapplyFromProjectFolder();

    if (this.#projectFolder) {
      this.#projectFolder.clearAllManagers();
    }

    this.#projectFolder = null;
    this.#defaultBehaviorPackFolder = null;
    this.#defaultWorldFolder = null;
    this.#defaultSkinPackFolder = null;
    this.#defaultScriptsFolder = null;
    this.#behaviorPacksContainer = null;
    this.#docsContainer = null;
    this.#defaultResourcePackFolder = null;
    this.#resourcePacksContainer = null;
    this.#skinPacksContainer = null;
    this.#worldContainer = null;

    this.#packs = [];
  }

  async inferProjectItemsFromFiles(force?: boolean) {
    if (!this.#hasInferredFiles || force) {
      await this.ensureProjectFolder();

      if (this.#projectCabinetFile !== null) {
        const operId = await this.carto.notifyOperationStarted(
          "Loading project files for '" + this.name + "' from '" + this.#projectCabinetFile.fullPath + "'",
          StatusTopic.projectLoad
        );

        await this.ensureProjectFolderFromCabinet();
        /*await this._inferProjectItemsFromZipFile(
          this.#projectCabinetFile.storageRelativePath,
          this.#projectCabinetFile,
          false
        );*/

        if (this.#projectFolder) {
          await this._inferProjectItemsFromFolder(
            this.#projectFolder,
            "",
            FolderContext.unknown,
            false,
            this.#projectFolder,
            0,
            undefined,
            force
          );
        }

        await this.carto.notifyOperationEnded(
          operId,
          "Done loading project files for '" + this.name + "' from file '" + this.#projectCabinetFile.fullPath + "'",
          StatusTopic.projectLoad
        );

        this.#hasInferredFiles = true;
      } else {
        await this.inferProjectItemsFromFilesRootFolder();
      }

      if (this.#accessoryFolders) {
        for (let i = 0; i < this.#accessoryFolders.length; i++) {
          await this._inferProjectItemsFromFolder(
            this.#accessoryFolders[i],
            "",
            FolderContext.unknown,
            false,
            this.#accessoryFolders[i],
            0,
            "o." + this.#accessoryFolders[i].name,
            force
          );
        }
      }

      await ProjectItemRelations.calculate(this);
    }
  }

  async inferProjectItemsFromFilesRootFolder(force?: boolean) {
    const rootFolder = await this.ensureProjectFolder();

    const operId = await this.carto.notifyOperationStarted(
      "Loading project files for '" + this.name + "' from folder '" + rootFolder.fullPath + "'",
      StatusTopic.projectLoad
    );

    if (this.#projectFolder) {
      await this._inferProjectItemsFromFolder(
        rootFolder,
        "",
        FolderContext.unknown,
        false,
        this.#projectFolder,
        0,
        undefined,
        force
      );

      await ProjectItemRelations.calculate(this);
    }
    await this.carto.notifyOperationEnded(
      operId,
      "Done loading project files for '" + this.name + "' from folder '" + rootFolder.fullPath + "'",
      StatusTopic.projectLoad
    );

    this.#hasInferredFiles = true;
  }

  async ensureWorldContainer() {
    if (!this.#worldContainer) {
      const pf = await this.ensureProjectFolder();

      if (pf) {
        await pf.load(false);

        if (pf.folders["worlds"]) {
          this.#worldContainer = pf.folders["worlds"];
        } else if (pf.folders["minecraftWorlds"]) {
          this.#worldContainer = pf.folders["minecraftWorlds"];
        } else {
          this.#worldContainer = pf;
        }
      }
    }

    return this.#worldContainer;
  }

  async ensureCatalogIndex() {
    if (!this.hasScript) {
      return;
    }

    const scriptsFolder = await this.ensureBehaviorPackScriptsFolder();

    if (!scriptsFolder) {
      return;
    }

    this.ensureItemByTag(
      "jsindex",
      "index.js",
      ProjectItemType.catalogIndexJs,
      StorageUtilities.ensureEndsWithDelimiter(scriptsFolder.storageRelativePath) + "index.js",
      ProjectItemStorageType.singleFile,
      ProjectItemCreationType.generated
    );
  }

  async ensureAutogeneratedBehaviorPackManifest() {
    const bpFolder = await this.ensureDefaultBehaviorPackFolder();

    if (!bpFolder) {
      return;
    }

    this.ensureItemByTag(
      "manifestjson",
      "behaviorpackmanifest",
      ProjectItemType.behaviorPackManifestJson,
      StorageUtilities.ensureEndsWithDelimiter(bpFolder.storageRelativePath) + "manifest.json",
      ProjectItemStorageType.singleFile,
      ProjectItemCreationType.generated
    );
  }

  dispose() {
    if (this.#projectFolder) {
      this._unapplyFromProjectFolder();
      this.#projectFolder.dispose();
      this.#projectFolder = null;
    }

    if (this.#projectCabinetFile) {
      this.#projectCabinetFile.dispose();
      this.#projectCabinetFile = null;
    }

    if (this.#distBuildFolder) {
      this.#distBuildFolder.dispose();
      this.#distBuildFolder = null;
    }

    if (this.#libFolder) {
      this.#libFolder.dispose();
      this.#libFolder = null;
    }

    if (this.#distBuildScriptsFolder) {
      this.#distBuildScriptsFolder.dispose();
      this.#distBuildScriptsFolder = null;
    }

    if (this.#libScriptsFolder) {
      this.#libScriptsFolder.dispose();
      this.#libScriptsFolder = null;
    }

    if (this.#docsContainer) {
      this.#docsContainer.dispose();
      this.#docsContainer = null;
    }

    if (this.#worldContainer) {
      this.#worldContainer.dispose();
      this.#worldContainer = null;
    }

    if (this.#behaviorPacksContainer) {
      this.#behaviorPacksContainer.dispose();
      this.#behaviorPacksContainer = null;
    }

    if (this.#defaultBehaviorPackFolder) {
      this.#defaultBehaviorPackFolder.dispose();
      this.#defaultBehaviorPackFolder = null;
    }

    if (this.#defaultScriptsFolder) {
      this.#defaultScriptsFolder.dispose();
      this.#defaultScriptsFolder = null;
    }

    if (this.#resourcePacksContainer) {
      this.#resourcePacksContainer.dispose();
      this.#resourcePacksContainer = null;
    }

    if (this.#defaultResourcePackFolder) {
      this.#defaultResourcePackFolder.dispose();
      this.#defaultResourcePackFolder = null;
    }

    this.#isDisposed = true;
  }

  resetProjectItems() {
    const newProjectItems: ProjectItem[] = [];

    for (const projectItem of this.items) {
      if (projectItem.itemType !== ProjectItemType.unknown && projectItem.itemType !== ProjectItemType.json) {
        newProjectItems.push(projectItem);
      }
    }

    this.#items = newProjectItems;
  }

  ensureStoragePathIsCollapsed(storagePath: string) {
    for (const pathCollapsed of this.collapsedStoragePaths) {
      if (pathCollapsed === storagePath) {
        return;
      }
    }

    this.collapsedStoragePaths.push(storagePath);
  }

  ensureStoragePathIsNotCollapsed(storagePath: string) {
    const newCollapsedPaths: string[] = [];

    for (const pathCollapsed of this.collapsedStoragePaths) {
      if (pathCollapsed !== storagePath) {
        newCollapsedPaths.push(storagePath);
      }
    }

    this.#data.collapsedStoragePaths = newCollapsedPaths;
  }

  async _inferProjectItemsFromFolder(
    folder: IFolder,
    fileSystemPrefix: string,
    folderContext: FolderContext,
    isInWorld: boolean,
    rootFolder: IFolder,
    depth: number,
    source?: string,
    force?: boolean
  ) {
    if (this.projectFolder === null || (folder.name.startsWith(".") && !folder.name.startsWith(".vscode"))) {
      Log.debugAlert("Could not process folder: " + folder.storageRelativePath);
      return;
    }

    await folder.load(force ? force : false);

    let parentFolder = folder.parentFolder;

    if (parentFolder === this.projectFolder.parentFolder) {
      parentFolder = null;
    }

    const folderPathA = StorageUtilities.canonicalizePath(StorageUtilities.getFolderPath(folder.storageRelativePath));

    if (
      folderPathA.indexOf("/checkpoint_input") >= 0 ||
      folderPathA.indexOf("/metadata") >= 0 ||
      folderPathA.indexOf("/type_definitions") >= 0 ||
      folderPathA.indexOf("/typedefs") >= 0 ||
      folderPathA.indexOf("/script_modules/") >= 0 ||
      folderPathA.indexOf("/vanilladata_modules/") >= 0 ||
      folderPathA.indexOf("/engine_modules/") >= 0 ||
      folderPathA.indexOf("/command_modules/") >= 0
    ) {
      folderContext = FolderContext.typeDefs;
    } else if (folderPathA.indexOf("/data/") >= 0 || folderPathA.indexOf("/forms/") >= 0) {
      folderContext = FolderContext.metaData;
    } else if (folderPathA.indexOf("/.vscode") >= 0) {
      folderContext = FolderContext.vscodeFolder;
    } else if (MinecraftUtilities.pathLooksLikeBehaviorPackName(folderPathA)) {
      folderContext = FolderContext.behaviorPack;
    } else if (MinecraftUtilities.pathLooksLikeResourcePackName(folderPathA)) {
      folderContext = FolderContext.resourcePack;
    } else if (MinecraftUtilities.pathLooksLikeSubPacksFolderName(folderPathA)) {
      folderContext = FolderContext.resourcePackSubPack;
    } else if (MinecraftUtilities.pathLooksLikeSkinPackName(folderPathA) && folderContext === FolderContext.unknown) {
      folderContext = FolderContext.skinPack;
    } else if (
      MinecraftUtilities.pathLooksLikeWorldFolderName(folderPathA) &&
      folderContext === FolderContext.unknown
    ) {
      folderContext = FolderContext.world;
      isInWorld = true;
    } else if (
      (folderPathA.indexOf("/docs/") >= 0 ||
        folderPathA.indexOf("/@minecraft/") >= 0 ||
        folderPathA.indexOf("/mojang-commands") >= 0) &&
      folderContext === FolderContext.unknown
    ) {
      folderContext = FolderContext.docs;

      if (this.#docsContainer === null) {
        this.#docsContainer = folder.parentFolder;
      }
    }

    if (
      folderContext === FolderContext.unknown &&
      (folder.files["manifest.json"] || folder.files["pack_manifest.json"]) &&
      !folder.files["level.dat"] &&
      !folder.files["levelname.txt"]
    ) {
      if (
        folder.folders["models"] ||
        folder.folders["textures"] ||
        folder.folders["lighting"] ||
        folder.folders["subpacks"] ||
        folder.folders["assets"] ||
        folder.folders["sounds"] ||
        folder.folders["texture_sets"] ||
        folder.folders["sounds"] ||
        folder.folders["ui"]
      ) {
        folderContext = FolderContext.resourcePack;
      } else if (
        folder.fullPath.indexOf("/rp/") >= 0 ||
        folder.fullPath.indexOf(" rp/") >= 0 ||
        folder.fullPath.indexOf("/rp ") >= 0 ||
        folder.fullPath.indexOf("esource") >= 0
      ) {
        folderContext = FolderContext.resourcePack;
      } else {
        folderContext = FolderContext.behaviorPack;
      }
    }

    if (
      folder.files["world_behavior_packs.json"] ||
      folder.files["world_resource_packs.json"] ||
      folder.files["levelname.txt"]
    ) {
      if (folderContext === FolderContext.unknown) {
        folderContext = FolderContext.world;
      }

      if (folder.parentFolder && !this.#worldContainer) {
        this.#worldContainer = folder.parentFolder;
      }
    }

    for (const fileName in folder.files) {
      const canonFileName = StorageUtilities.canonicalizeName(fileName);
      // console.log("Considering " + canonFileName + " in folder " + folder.storageRelativePath);

      if (canonFileName !== "gulpfile.js" && canonFileName !== "package-lock.json") {
        const candidateFile = folder.files[fileName];

        if (candidateFile !== undefined) {
          let pi = null;
          let projectPath = undefined;

          if (fileSystemPrefix.length > 0) {
            projectPath = fileSystemPrefix + candidateFile.fullPath;
            pi = this.getItemByProjectPath(projectPath);
          } else {
            const frPath = candidateFile.getFolderRelativePath(rootFolder);

            if (frPath !== undefined) {
              projectPath = StorageUtilities.canonicalizePath(frPath);

              pi = this.getItemByProjectPath(projectPath);
            }
          }

          if ((pi === undefined || pi === null) && projectPath !== undefined) {
            const fileExtension = candidateFile.type;
            const baseName = StorageUtilities.getBaseFromName(candidateFile.name);
            const folderPath = StorageUtilities.canonicalizePath(StorageUtilities.getFolderPath(projectPath));
            const folderPathLower = folderPath.toLowerCase();

            if (canonFileName === "manifest.json" || canonFileName === "pack_manifest.json") {
              if (folderContext === FolderContext.world) {
                this.#defaultWorldFolder = folder;
                this.#worldContainer = parentFolder;
              }

              await candidateFile.loadContent(false);

              if (
                candidateFile.content !== undefined &&
                candidateFile.content !== "" &&
                typeof candidateFile.content === "string"
              ) {
                try {
                  const manifest: IAddonManifest = JSON.parse(candidateFile.content);

                  if (manifest.header.uuid !== undefined) {
                    if (folderContext === FolderContext.behaviorPack) {
                      this.defaultBehaviorPackUniqueId = manifest.header.uuid;
                      this.#defaultBehaviorPackFolder = folder;
                      this.#behaviorPacksContainer = parentFolder;
                      this.ensurePackByFolder(folder, PackType.behavior);
                    } else if (folderContext === FolderContext.resourcePack) {
                      this.defaultResourcePackUniqueId = manifest.header.uuid;
                      this.#defaultResourcePackFolder = folder;
                      this.#resourcePacksContainer = parentFolder;
                      this.ensurePackByFolder(folder, PackType.resource);
                    }
                  }

                  if (manifest.modules) {
                    for (let i = 0; i < manifest.modules.length; i++) {
                      const mod = manifest.modules[i];

                      if (mod.type === "script") {
                        this.defaultScriptModuleUniqueId = mod.uuid;
                      }
                    }
                  }

                  if (manifest.header.description !== undefined) {
                    this.description = manifest.header.description;
                  }

                  if (manifest.header.name !== undefined) {
                    this.title = manifest.header.name;
                  }

                  if (
                    manifest.header.version !== undefined &&
                    manifest.header.version.length === 3 &&
                    folderContext === FolderContext.behaviorPack
                  ) {
                    this.versionMajor = manifest.header.version[0];
                    this.versionMinor = manifest.header.version[1];
                    this.versionPatch = manifest.header.version[2];
                  }
                } catch (e) {}
              }

              let newPiType = ProjectItemType.unknown;
              let tag = "";

              if (folderContext === FolderContext.behaviorPack) {
                newPiType = ProjectItemType.behaviorPackManifestJson;
                tag = "behaviorpackmanifest";
              } else if (folderContext === FolderContext.resourcePack) {
                newPiType = ProjectItemType.resourcePackManifestJson;
                tag = "resourcepackmanifest";
              } else if (folderContext === FolderContext.skinPack) {
                newPiType = ProjectItemType.skinPackManifestJson;
                tag = "skinpackmanifest";
              } else if (folderContext === FolderContext.world) {
                newPiType = ProjectItemType.worldTemplateManifestJson;
                tag = "worldtemplatemanifest";
              }

              // Log.assert(newPiType !== ProjectItemType.unknown, "Unknown manifest.json file found.");
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                newPiType,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                tag,
                isInWorld
              );
            } else if (projectPath.endsWith("/scripts/index.js")) {
              await candidateFile.loadContent();

              let creationType = ProjectItemCreationType.normal;

              if (
                candidateFile.content === undefined ||
                candidateFile.content === "" ||
                (typeof candidateFile.content === "string" &&
                  candidateFile.content.indexOf(AUTOGENERATED_CONTENT_TOKEN) >= 0)
              ) {
                creationType = ProjectItemCreationType.generated;
              }

              this.ensureItemByTag(
                "jsindex",
                "index.js",
                ProjectItemType.catalogIndexJs,
                projectPath,
                ProjectItemStorageType.singleFile,
                creationType,
                candidateFile,
                isInWorld
              );
            } else if (projectPath.endsWith("tasks.json") && folderContext === FolderContext.vscodeFolder) {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.vsCodeTasksJson,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (projectPath.endsWith("launch.json") && folderContext === FolderContext.vscodeFolder) {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.vsCodeLaunchJson,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (projectPath.endsWith("settings.json") && folderContext === FolderContext.vscodeFolder) {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.vsCodeSettingsJson,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (projectPath.endsWith("extensions.json") && folderContext === FolderContext.vscodeFolder) {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.vsCodeExtensionsJson,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (projectPath.endsWith("/tick.json")) {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.tickJson,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (fileExtension === "mcstructure") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.structure,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (fileExtension === "mcfunction") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.MCFunction,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (fileExtension === "material") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.material,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (fileExtension === "vertex") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.materialVertex,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (fileExtension === "fragment") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.materialFragment,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (fileExtension === "geometry") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.materialGeometry,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (
              canonFileName === "level.dat" &&
              fileSystemPrefix.indexOf(".mcworld") < 0 && // don't create a project item if we're inside of a mcworld/mctemplate since that broader item has a link already
              fileSystemPrefix.indexOf(".mctemplate") < 0 &&
              folderContext !== FolderContext.behaviorPack
            ) {
              isInWorld = true;
              this.ensureItemByProjectPath(
                folderPath,
                ProjectItemStorageType.folder,
                candidateFile.name,
                ProjectItemType.worldFolder,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (canonFileName === "just.config.ts") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.justConfigTs,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (canonFileName === "eslint.config.mjs") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.esLintConfigMjs,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (fileExtension === "js") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.js,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (fileExtension === "ts") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.ts,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (fileExtension === "mcworld") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.MCWorld,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );

              await this.inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            } else if (fileExtension === "mcproject") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.MCProject,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );

              await this.inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            } else if (fileExtension === "mctemplate") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.MCTemplate,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );

              await this.inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            } else if (fileExtension === "mcaddon") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.MCAddon,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );

              await this.inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            } else if (fileExtension === "mcpack") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.MCPack,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );

              await this.inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            } else if (fileExtension === "zip") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.zip,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );

              await this.inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            } else if (
              fileExtension === "png" ||
              fileExtension === "jpg" ||
              fileExtension === "gif" ||
              fileExtension === "jpeg" ||
              fileExtension === "tga"
            ) {
              let imageType = ProjectItemType.image;

              if (folderPathLower.indexOf("/marketing art/") >= 0) {
                imageType = ProjectItemType.marketingAssetImage;
              } else if (folderPathLower.indexOf("/store art/") >= 0) {
                imageType = ProjectItemType.storeAssetImage;
              } else if (folderPathLower.indexOf("/textures/ui/") >= 0) {
                imageType = ProjectItemType.uiTexture;
              } else if (baseName === "pack_icon" || folder.files["manifest.json"]) {
                imageType = ProjectItemType.iconImage;
              } else if (folderPathLower.indexOf("/textures/") >= 0) {
                imageType = ProjectItemType.texture;
              }

              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                imageType,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (fileExtension === "ogg" || fileExtension === "mp3" || fileExtension === "wav") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.audio,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (fileExtension === "env" && baseName === "") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.env,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (fileExtension === "lang") {
              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.lang,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            } else if (fileExtension === "json") {
              let newJsonType = ProjectItemType.json;
              let itemName = candidateFile.name;

              if (folderContext === FolderContext.behaviorPack && folderPathLower.indexOf("/loot_tables/") >= 0) {
                newJsonType = ProjectItemType.lootTableBehavior;
              } else if (folderContext === FolderContext.behaviorPack && folderPathLower.indexOf("/dialogue/") >= 0) {
                newJsonType = ProjectItemType.dialogueBehaviorJson;
              } else if (folderContext === FolderContext.behaviorPack && folderPathLower.indexOf("/recipes/") >= 0) {
                newJsonType = ProjectItemType.recipeBehavior;
              } else if (
                folderContext === FolderContext.behaviorPack &&
                folderPathLower.indexOf("/spawn_rules/") >= 0
              ) {
                newJsonType = ProjectItemType.spawnRuleBehavior;
              } else if (folderContext === FolderContext.behaviorPack && folderPathLower.indexOf("/cameras/") >= 0) {
                newJsonType = ProjectItemType.cameraJson;
              } else if (folderContext === FolderContext.behaviorPack && folderPathLower.indexOf("/trading/") >= 0) {
                newJsonType = ProjectItemType.tradingBehaviorJson;
              } else if (
                folderContext === FolderContext.behaviorPack &&
                folderPathLower.indexOf("/animation_controllers/") >= 0
              ) {
                newJsonType = ProjectItemType.animationControllerBehaviorJson;
              } else if (folderContext === FolderContext.behaviorPack && folderPathLower.indexOf("/animations/") >= 0) {
                newJsonType = ProjectItemType.animationBehaviorJson;
              } else if (
                folderContext === FolderContext.resourcePack &&
                (folderPathLower.indexOf("/models/") >= 0 ||
                  baseName.endsWith(".geo") ||
                  baseName.endsWith(".geometry"))
              ) {
                newJsonType = ProjectItemType.modelGeometryJson;
              } else if (baseName.endsWith(".mci")) {
                newJsonType = ProjectItemType.contentIndexJson;
              } else if (baseName.endsWith(".mcr")) {
                newJsonType = ProjectItemType.contentReportJson;
              } else if (folderContext === FolderContext.behaviorPack && folderPathLower.indexOf("/dimension/") >= 0) {
                newJsonType = ProjectItemType.dimensionJson;
              } else if (folderContext === FolderContext.behaviorPack && folderPathLower.indexOf("/features/") >= 0) {
                newJsonType = ProjectItemType.featureBehavior;
              } else if (
                folderContext === FolderContext.behaviorPack &&
                folderPathLower.indexOf("/feature_rules/") >= 0
              ) {
                newJsonType = ProjectItemType.featureRuleBehaviorJson;
              } else if (
                folderContext === FolderContext.resourcePack &&
                folderPathLower.indexOf("/animation_controllers/") >= 0
              ) {
                newJsonType = ProjectItemType.animationControllerResourceJson;
              } else if (folderContext === FolderContext.resourcePack && folderPathLower.indexOf("/animations/") >= 0) {
                newJsonType = ProjectItemType.animationResourceJson;
              } else if (
                folderContext === FolderContext.resourcePack &&
                folderPathLower.indexOf("/attachables/") >= 0
              ) {
                newJsonType = ProjectItemType.attachableResourceJson;
              } else if (folderContext === FolderContext.resourcePack && folderPathLower.indexOf("/fogs/") >= 0) {
                newJsonType = ProjectItemType.fogResourceJson;
              } else if (folderContext === FolderContext.resourcePack && folderPathLower.indexOf("/particles/") >= 0) {
                newJsonType = ProjectItemType.particleJson;
              } else if (
                folderContext === FolderContext.resourcePack &&
                folderPathLower.indexOf("/render_controllers/") >= 0
              ) {
                newJsonType = ProjectItemType.renderControllerJson;
              } else if (
                (folderContext === FolderContext.resourcePack || folderContext === FolderContext.resourcePackSubPack) &&
                (projectPath.endsWith("terrain_texture.json") || projectPath.endsWith("terrain_textures.json"))
              ) {
                newJsonType = ProjectItemType.terrainTextureCatalogResourceJson;
              } else if (
                (folderContext === FolderContext.resourcePack || folderContext === FolderContext.resourcePackSubPack) &&
                projectPath.endsWith("_global_variables.json")
              ) {
                newJsonType = ProjectItemType.globalVariablesJson;
              } else if (
                (folderContext === FolderContext.resourcePack || folderContext === FolderContext.resourcePackSubPack) &&
                projectPath.endsWith("flipbook_textures.json")
              ) {
                newJsonType = ProjectItemType.flipbookTexturesJson;
              } else if (
                (folderContext === FolderContext.resourcePack || folderContext === FolderContext.resourcePackSubPack) &&
                (projectPath.endsWith("item_texture.json") || projectPath.endsWith("item_textures.json"))
              ) {
                newJsonType = ProjectItemType.itemTextureJson;
              } else if (folderContext === FolderContext.skinPack && projectPath.endsWith("skins.json")) {
                newJsonType = ProjectItemType.skinCatalogJson;
              } else if (folderContext === FolderContext.resourcePack && folderPathLower.indexOf("/materials/") >= 0) {
                newJsonType = ProjectItemType.materialSetJson;
              } else if (
                folderContext === FolderContext.resourcePack &&
                folderPathLower.indexOf("/sounds/") >= 0 &&
                baseName === "sound_definitions"
              ) {
                newJsonType = ProjectItemType.soundDefinitionCatalog;
              } else if (
                folderContext === FolderContext.resourcePack &&
                folderPathLower.indexOf("/sounds/") >= 0 &&
                baseName === "music_definitions"
              ) {
                newJsonType = ProjectItemType.musicDefinitionJson;
              } else if (folderPathLower.indexOf("/texts/") >= 0 || baseName === "languages") {
                newJsonType = ProjectItemType.languagesCatalogResourceJson;
              } else if (
                (folderContext === FolderContext.resourcePack || folderContext === FolderContext.resourcePackSubPack) &&
                folderPathLower.indexOf("/textures/ui/") >= 0
              ) {
                newJsonType = ProjectItemType.ninesliceJson;
              } else if (
                folderContext === FolderContext.resourcePack &&
                folderPathLower.indexOf("/texture_sets/") >= 0
              ) {
                newJsonType = ProjectItemType.textureSetJson;
              } else if (
                (folderContext === FolderContext.resourcePack || folderContext === FolderContext.resourcePackSubPack) &&
                folderPathLower.indexOf("/lighting/") >= 0
              ) {
                newJsonType = ProjectItemType.lightingJson;
              } else if (folderContext === FolderContext.resourcePack && folderPathLower.indexOf("/ui/") >= 0) {
                newJsonType = ProjectItemType.uiJson;
              } else if (folderContext === FolderContext.docs && baseName === "example_files") {
                newJsonType = ProjectItemType.fileListArrayJson;
              } else if (folderContext === FolderContext.resourcePack && baseName === "biomes_client") {
                newJsonType = ProjectItemType.biomeResourceJson;
              } else if (
                (folderContext === FolderContext.resourcePack || folderContext === FolderContext.resourcePackSubPack) &&
                baseName === "blocks"
              ) {
                newJsonType = ProjectItemType.blocksCatalogResourceJson;
              } else if (
                (folderContext === FolderContext.resourcePack || folderContext === FolderContext.resourcePackSubPack) &&
                (projectPath.endsWith("texture_list.json") || projectPath.endsWith("textures_list.json"))
              ) {
                newJsonType = ProjectItemType.textureListJson;
              } else if (
                (folderContext === FolderContext.resourcePack || folderContext === FolderContext.resourcePackSubPack) &&
                projectPath.endsWith("texture_set.json")
              ) {
                newJsonType = ProjectItemType.textureSetJson;
              } else if (folderContext === FolderContext.resourcePack && folderPathLower.indexOf("/items/") >= 0) {
                newJsonType = ProjectItemType.itemTypeResourceJson;
              } else if (folderContext === FolderContext.resourcePack && baseName === "sounds") {
                newJsonType = ProjectItemType.soundCatalog;
              } else if (baseName === "world_behavior_packs") {
                newJsonType = ProjectItemType.behaviorPackListJson;
              } else if (baseName === "world_resource_packs") {
                newJsonType = ProjectItemType.resourcePackListJson;
              } else if (baseName === "world_behavior_pack_history") {
                newJsonType = ProjectItemType.behaviorPackHistoryListJson;
              } else if (baseName === "world_resource_pack_history") {
                newJsonType = ProjectItemType.resourcePackHistoryListJson;
              } else if (baseName === "tsconfig") {
                newJsonType = ProjectItemType.tsconfigJson;
              } else if (baseName === "docfx") {
                newJsonType = ProjectItemType.docfxJson;
              } else if (baseName === "jsdoc") {
                newJsonType = ProjectItemType.jsdocJson;
              } else if (baseName === "jsconfig") {
                newJsonType = ProjectItemType.jsconfigJson;
              } else if (baseName === "package") {
                newJsonType = ProjectItemType.packageJson;
              } else if (baseName === "package.lock") {
                newJsonType = ProjectItemType.packageLockJson;
              } else if (baseName === ".prettierrc") {
                newJsonType = ProjectItemType.prettierRcJson;
              } else if (folderContext === FolderContext.docs && baseName === "info") {
                newJsonType = ProjectItemType.docInfoJson;
                this.role = ProjectRole.documentation;

                itemName = StorageUtilities.getLeafName(folderPath);
              } else if (
                (folderContext === FolderContext.resourcePack || folderContext === FolderContext.resourcePackSubPack) &&
                folderPathLower.indexOf("/textures/") >= 0
              ) {
                newJsonType = ProjectItemType.ninesliceJson;
              } else if (
                folderContext === FolderContext.docs &&
                (baseName === "_example_files" || baseName === "example_files")
              ) {
                newJsonType = ProjectItemType.fileListArrayJson;
                this.role = ProjectRole.documentation;

                itemName = StorageUtilities.getLeafName(folderPath);
              } else if (folderContext === FolderContext.typeDefs && folderPathLower.indexOf("/command_modules") >= 0) {
                newJsonType = ProjectItemType.commandSetDefinitionJson;
                this.role = ProjectRole.documentation;
              } else if (
                (folderContext === FolderContext.metaData && folderPathLower.indexOf("/forms") >= 0) ||
                projectPath.endsWith(".form.json")
              ) {
                newJsonType = ProjectItemType.dataForm;
                this.role = ProjectRole.meta;
              } else if (folderContext === FolderContext.typeDefs && folderPathLower.indexOf("/script_modules") >= 0) {
                newJsonType = ProjectItemType.scriptTypesJson;
                this.role = ProjectRole.documentation;
              } else if (
                folderContext === FolderContext.typeDefs &&
                folderPathLower.indexOf("/vanilladata_modules") >= 0
              ) {
                newJsonType = ProjectItemType.vanillaDataJson;
                this.role = ProjectRole.documentation;
              } else if (folderContext === FolderContext.typeDefs && folderPathLower.indexOf("/engine_modules") >= 0) {
                newJsonType = ProjectItemType.engineOrderingJson;
                this.role = ProjectRole.documentation;
              }
              // these need to be near the bottom since URL segments like /items/, /blocks/, /entities etc. could theoretically be used in loot_tables, etc. and that should take precedence in detection
              else if (folderContext === FolderContext.behaviorPack && folderPathLower.indexOf("/items/") >= 0) {
                newJsonType = ProjectItemType.itemTypeBehavior;
              } else if (folderContext === FolderContext.behaviorPack && folderPathLower.indexOf("/blocks/") >= 0) {
                newJsonType = ProjectItemType.blockTypeBehavior;
              } else if (
                folderContext === FolderContext.resourcePack &&
                (folderPathLower.indexOf("/entities/") >= 0 || folderPathLower.indexOf("/entity/") >= 0)
              ) {
                newJsonType = ProjectItemType.entityTypeResource;
              } else if (
                folderContext === FolderContext.behaviorPack &&
                (folderPathLower.indexOf("/entities/") >= 0 || folderPathLower.indexOf("/entity/") >= 0)
              ) {
                newJsonType = ProjectItemType.entityTypeBehavior;
              } else {
                // Log.debugAlert("General JSON file found: " + projectPath);
              }

              this.ensureItemByProjectPath(
                projectPath,
                ProjectItemStorageType.singleFile,
                itemName,
                newJsonType,
                source,
                ProjectItemCreationType.normal,
                candidateFile,
                undefined,
                isInWorld
              );
            }
          } else if (pi && projectPath !== undefined) {
            if (
              pi.itemType === ProjectItemType.MCWorld ||
              pi.itemType === ProjectItemType.MCProject ||
              pi.itemType === ProjectItemType.MCTemplate ||
              pi.itemType === ProjectItemType.MCAddon ||
              pi.itemType === ProjectItemType.MCPack ||
              pi.itemType === ProjectItemType.zip
            ) {
              await this.inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            }
          }
        }
      }
    }

    for (const folderName in folder.folders) {
      const childFolder = folder.folders[folderName];

      if (childFolder && !childFolder.errorStatus) {
        const name = StorageUtilities.canonicalizeName(folderName);

        if (name === "build" || name === "out" || name === "dist") {
          this.#distBuildFolder = folder;
        } else if (name === "lib") {
          this.#libFolder = folder;
        } else if (
          name !== "node_modules" &&
          (name.startsWith(".vscode") || !name.startsWith(".")) &&
          name !== "test" &&
          (folderContext !== FolderContext.unknown || depth < 4) &&
          depth < 10
        ) {
          if (childFolder !== undefined) {
            await this._inferProjectItemsFromFolder(
              childFolder,
              fileSystemPrefix,
              folderContext,
              isInWorld,
              rootFolder,
              depth + 1,
              source,
              force
            );
          }
        }
      }
    }
  }

  async ensureProjectFolderFromCabinet() {
    if (!this.#projectCabinetFile) {
      Log.unexpectedUndefined("EPFFC");
      return;
    }

    await this.#projectCabinetFile.loadContent();

    const rootFolder = await StorageUtilities.getFileStorageFolder(this.#projectCabinetFile);

    if (rootFolder !== this.#projectFolder) {
      this._unapplyFromProjectFolder();
      if (rootFolder) {
        this.#projectFolder = rootFolder;

        this._applyToProjectFolder();
      } else {
        this.#projectFolder = null;
      }
    }
  }

  async inferProjectItemsFromZipFile(projectPath: string, file: IFile, force?: boolean) {
    let operId = await this.carto.notifyOperationStarted("Loading package file " + file.name);
    await file.loadContent();

    const rootFolder = await StorageUtilities.getFileStorageFolder(file);

    if (rootFolder) {
      await this._inferProjectItemsFromFolder(
        rootFolder,
        projectPath + "#",
        FolderContext.unknown,
        false,
        rootFolder,
        0,
        undefined,
        force
      );

      await ProjectItemRelations.calculate(this);
    }

    await this.carto.notifyOperationEnded(operId, "Done loading package file " + file.name);
  }

  async ensureDefaultItems() {
    if (this.focus === ProjectFocus.gameTests && this.projectFolder !== null) {
      const bpFolder = await this.ensureDefaultBehaviorPackFolder();

      const defaultPath = bpFolder.getFolderRelativePath(this.projectFolder);

      let pi = this.ensureItemByTag(
        "gametestjs",
        "Test",
        ProjectItemType.testJs,
        defaultPath + "scripts/test.js",
        ProjectItemStorageType.singleFile
      );

      let file = await pi.ensureFileStorage();

      if (file !== null) {
        let content = "";
        if (this.preferredScriptLanguage === ProjectScriptLanguage.typeScript) {
          content = ProjectContent.getDefaultTestTypeScript(this.name, StorageUtilities.getBaseFromName("test"));
        } else {
          content = ProjectContent.getDefaultTestJavaScript(this.name, StorageUtilities.getBaseFromName("test"));
        }

        file.setContent(content);
      }

      await this.ensureJsIndexFile();

      pi = this.ensureItemByTag(
        "manifestjson",
        "manifest",
        ProjectItemType.behaviorPackManifestJson,
        defaultPath + "manifest.json",
        ProjectItemStorageType.singleFile,
        ProjectItemCreationType.generated
      );

      pi = this.ensureItemByTag(
        "gameteststructure",
        "Basic",
        ProjectItemType.structure,
        defaultPath + "structures/gametests/basic.mcstructure",
        ProjectItemStorageType.singleFile
      );

      file = await pi.ensureFileStorage();

      if (file !== null) {
        const result = ProjectContent.generateDefaultStructure();

        if (result !== undefined) {
          file.setContent(result);
        }
      }
    }
  }

  async ensureJsIndexFile() {
    if (this.projectFolder === null) {
      throw new Error("Could not find project folder");
    }

    const bpFolder = await this.ensureDefaultBehaviorPackFolder();

    const defaultPath = bpFolder.getFolderRelativePath(this.projectFolder);

    this.ensureItemByTag(
      "jsindex",
      "index.js",
      ProjectItemType.catalogIndexJs,
      defaultPath + "scripts/index.js",
      ProjectItemStorageType.singleFile,
      ProjectItemCreationType.generated
    );
  }

  async applyUpdate(updaterId: string, updaterIndex: number): Promise<ProjectUpdateResult[]> {
    const pur = new ProjectUpdateRunner(this);

    return await pur.update(updaterId, updaterIndex);
  }

  async getScriptState() {
    const state: IProjectScriptState = {
      hasScript: false,
      hasModule: {},
    };

    for (let i = 0; i < this.#items.length; i++) {
      const pi = this.#items[i];

      if (
        pi.itemType === ProjectItemType.js ||
        pi.itemType === ProjectItemType.buildProcessedJs ||
        pi.itemType === ProjectItemType.testJs ||
        pi.itemType === ProjectItemType.ts ||
        pi.itemType === ProjectItemType.worldTest
      ) {
        state.hasScript = true;

        if (
          (pi.itemType === ProjectItemType.js ||
            pi.itemType === ProjectItemType.buildProcessedJs ||
            pi.itemType === ProjectItemType.testJs ||
            pi.itemType === ProjectItemType.ts) &&
          pi.file
        ) {
          await pi.file.loadContent();
          const content = pi.file.content;

          if (content && typeof content === "string") {
            for (let i = 0; i < minecraftScriptModules.length; i++) {
              const mod = minecraftScriptModules[i];

              if (content.indexOf(mod.id) >= 0) {
                state.hasModule[mod.id] = true;
              }
            }
          }
        }
      }
    }

    return state;
  }

  getFirstItemByType(itemType: ProjectItemType) {
    for (let i = 0; i < this.#items.length; i++) {
      const pi = this.#items[i];

      if (pi.itemType === itemType) {
        return pi;
      }
    }

    return undefined;
  }

  hasAddonJson() {
    return false;
  }

  private async loadFolderStructure() {
    Log.assert(!this.#isDisposed, "PLFS");

    if (this.#folderStructureLoaded) {
      return;
    }

    const projectFolder = await this.ensureProjectFolder();

    await this.processProjectFolder(projectFolder);

    this.#folderStructureLoaded = true;
  }

  private async processProjectFolder(folder: IFolder) {
    await folder.load();

    let manifest = folder.files["manifest.json"];

    if (manifest === undefined) {
      manifest = folder.files["pack_manifest.json"];
    }

    if (!this.#projectFolder) {
      throw new Error("Unexpectedly could not find a project folder.");
    }

    if (manifest) {
      let parentFolder = folder.parentFolder;

      if (parentFolder === this.#projectFolder.parentFolder) {
        parentFolder = null;
      }

      let isResource = false;
      let isWorld = false;

      if (parentFolder !== null) {
        const name = StorageUtilities.canonicalizeName(parentFolder.name);

        if (name.indexOf("resource") >= 0) {
          isResource = true;
        }
      }

      const levelDat = folder.files["level.dat"];

      if (levelDat) {
        isWorld = true;
      }

      if (isWorld && this.#defaultWorldFolder === null) {
        this.#defaultWorldFolder = folder;

        if (parentFolder !== null) {
          this.#worldContainer = parentFolder;
        }
      } else if (!isWorld && isResource && this.#defaultResourcePackFolder === null) {
        this.#defaultResourcePackFolder = folder;

        if (parentFolder !== null) {
          this.#resourcePacksContainer = parentFolder;
        }
      } else if (!isWorld && this.#defaultBehaviorPackFolder === null) {
        this.#defaultBehaviorPackFolder = folder;

        if (parentFolder !== null) {
          this.#behaviorPacksContainer = parentFolder;
        }
      }
    } else {
      for (const folderName in folder.folders) {
        const childFolder = folder.folders[folderName];

        if (childFolder !== undefined && !childFolder.errorStatus) {
          await this.processProjectFolder(childFolder);
        }
      }
    }
  }

  public getItemByFile(file: IFile) {
    let projectItem = this.getItemByProjectPath(file.storageRelativePath);

    if (projectItem !== undefined) {
      return projectItem;
    }

    return this.getItemByExtendedOrProjectPath(file.extendedPath);
  }

  public getItemByProjectPath(projectPath: string): ProjectItem | undefined {
    return this.#itemsByProjectPath[ProjectUtilities.canonicalizeStoragePath(projectPath)];
  }

  public getItemByExtendedOrProjectPath(storagePath: string): ProjectItem | undefined {
    let path = ProjectUtilities.canonicalizeStoragePath(storagePath);
    let result = this.#itemsByProjectPath[path];

    if (result) {
      return result;
    }

    let nextSlash = path.indexOf("/", 1);

    if (nextSlash > 1) {
      result = this.#itemsByProjectPath[path.substring(nextSlash)];

      if (result) {
        return result;
      }
    }

    nextSlash = path.indexOf("root/", 1);

    if (nextSlash > 1) {
      nextSlash = path.indexOf("/", nextSlash + 5);

      if (nextSlash > 1) {
        result = this.#itemsByProjectPath[path.substring(nextSlash)];

        if (result) {
          return result;
        }
      }
    }

    return undefined;
  }

  public ensureItemByProjectPath(
    projectPath: string,
    storageType: ProjectItemStorageType,
    name: string,
    itemType: ProjectItemType,
    source?: string,
    creationType?: ProjectItemCreationType,
    file?: IFile,
    tag?: string,
    isInWorld?: boolean
  ) {
    let pi = this.getItemByProjectPath(projectPath);

    if (pi !== undefined) {
      if (!pi.file && file) {
        pi.setFile(file);
      }

      return pi;
    }

    const tags = [];

    if (tag) {
      tags.push(tag);
    }

    pi = this.createItem({
      itemType: itemType,
      projectPath: projectPath,
      storageType: storageType,
      creationType: creationType,
      source: source,
      tags: tags,
      name: name,
    });

    if (file) {
      pi.setFile(file);
    }

    if (isInWorld !== undefined) {
      pi.isInWorld = isInWorld;
    }

    if (pi.itemType === ProjectItemType.json && itemType !== ProjectItemType.json) {
      pi.itemType = itemType;
    }

    return pi;
  }

  public getItemByTag(tag: string): ProjectItem | null {
    for (let i = 0; i < this.#items.length; i++) {
      const projectItem = this.#items[i];

      if (projectItem.hasTag(tag)) {
        return projectItem;
      }
    }

    return null;
  }

  public getItemByType(type: ProjectItemType): ProjectItem[] {
    const items = [];

    for (let i = 0; i < this.#items.length; i++) {
      const projectItem = this.#items[i];

      if (projectItem.itemType === type) {
        items.push(projectItem);
      }
    }

    return items;
  }

  public ensureItemByTag(
    tag: string,
    name: string,
    itemType: ProjectItemType,
    storagePath?: string,
    storageType?: ProjectItemStorageType,
    creationType?: ProjectItemCreationType,
    file?: IFile,
    isInWorld?: boolean
  ) {
    let pi = this.getItemByTag(tag);

    if (pi != null) {
      return pi;
    }

    pi = this.createItem({
      itemType: itemType,
      projectPath: storagePath,
      storageType: storageType,
      creationType: creationType,
      tags: [tag],
      name: name,
    });

    if (file) {
      pi.setFile(file);
    }

    if (pi.itemType === ProjectItemType.json && itemType !== ProjectItemType.json) {
      pi.itemType = itemType;
    }

    return pi;
  }

  async ensureWorkingFolderForFile(file: IFile) {
    if (!this.projectFolder) {
      return undefined;
    }

    let relativePath = file.getFolderRelativePath(this.projectFolder);

    if (relativePath === undefined) {
      return undefined;
    }

    relativePath = StorageUtilities.canonicalizePath(relativePath);

    relativePath = StorageUtilities.ensureEndsWithDelimiter(relativePath.replace(/\./gi, "_"));

    const workingFolder = this.projectFolder.ensureFolder(".working");

    return await workingFolder.ensureFolderFromRelativePath(relativePath);
  }

  createItem(initialSettings: IProjectItemData) {
    this.#data.items.push(initialSettings);

    const pi = new ProjectItem(this, initialSettings);

    this.#itemsByProjectPath[ProjectUtilities.canonicalizeStoragePath(pi.projectPath)] = pi;
    this.#items.push(pi);

    this._onItemAdded.dispatch(this, pi);

    return pi;
  }

  async ensureLoadedFromFile() {
    Log.assert(!this.#isDisposed, "PLF");

    if (this.#isLoaded) {
      return;
    }

    if (this.#file === null) {
      return;
    }

    await this.#file.loadContent(false);

    this.#hasInferredFiles = false;
    this.#items = [];
    this.#itemsByProjectPath = {};
    this.#data.items = [];

    if (Utilities.isString(this.#file.content) && this.#file.content != null) {
      this.#data = JSON.parse(this.#file.content as string);

      await this.ensureProjectFolder(true);
    } else {
      await this.ensureProjectFolder();
    }

    this._onLoaded.dispatch(this, this);

    this.#isLoaded = true;
  }

  async ensureInflated() {
    Log.assert(!this.#isDisposed, "PLINF");

    if (this.#isInflated) {
      return;
    }

    await this.ensureLoadedFromFile();

    this.#items = [];
    this.#itemsByProjectPath = {};

    if (this.#data) {
      for (let i = 0; i < this.#data.items.length; i++) {
        const projectItemData = this.#data.items[i];

        const projectItem = new ProjectItem(this, projectItemData);
        this.#itemsByProjectPath[ProjectUtilities.canonicalizeStoragePath(projectItem.projectPath)] = projectItem;
        this.#items.push(projectItem);

        this._onItemAdded.dispatch(this, projectItem);
      }
    }

    this._onInflated.dispatch(this, this);

    this.initializeWorldSettings();
    this.ensureDefaultWorldName();

    await ProjectItemRelations.calculate(this);

    this.#isInflated = true;
  }

  async deleteThisProject() {
    if (this.#file) {
      await this.#file.deleteThisFile();
    }

    await this.loadFolderStructure();

    if (this.projectFolder) {
      await this.#projectFolder?.deleteThisFolder();
    }
  }

  async saveToFile() {
    Log.assert(!this.#isDisposed, "PSF");

    if (this.#file === null) {
      return;
    }

    const jsonString = JSON.stringify(this.#data, null, 2);

    this.#file.setContent(jsonString);

    await this.#file.saveContent();
  }

  private _handleDeployUpdated(message: string) {
    this.#carto.notifyStatusUpdate(message);
  }

  async save(force?: boolean) {
    Log.assert(!this.#isDisposed, "PSFA");

    if (this.#readOnlySafety) {
      throw new Error("Attempting to save project in read-only mode.");
    }

    await this.ensureProjectFolder();

    // save all things inside of file containers first
    for (let i = 0; i < this.#items.length; i++) {
      const projectItem = this.#items[i];

      if ((projectItem.needsSave || force) && projectItem.isInFileContainer) {
        await projectItem.prepareToSave();

        this.updateContentsModified();

        await this.#items[i].saveContent();
      }
    }

    // save non container files
    for (let i = 0; i < this.#items.length; i++) {
      const projectItem = this.#items[i];

      if ((projectItem.needsSave || force) && !projectItem.isInFileContainer) {
        await projectItem.prepareToSave();

        this.updateContentsModified();

        await this.#items[i].saveContent();
      }
    }

    await this.saveToFile();

    this.changedFilesSinceLastSaved = {};

    if (this.projectFolder) {
      // we should have saved everything with individual project saves, but we should also allow folders to save their state.
      await this.projectFolder.saveAll();
    }

    if (
      this.autoDeploymentMode === ProjectAutoDeploymentMode.deployOnSave &&
      this.#carto.deploymentStorage !== null &&
      this.#carto.deployBehaviorPacksFolder !== null &&
      this.#carto.activeMinecraft
    ) {
      await this.#carto.activeMinecraft.syncWithDeployment();
    }

    this._onSaved.dispatch(this, this);
  }

  async autoCompleteProject() {
    await this.ensureScriptInDestination();
    await this.ensureCatalogIndex();
    await this.ensureAutogeneratedBehaviorPackManifest();
  }

  updateProjectItemsFromContent() {
    this.#itemsByProjectPath = {};

    for (const projectItem of this.items) {
      if (projectItem && projectItem.projectPath) {
        projectItem.updateProjectPath();

        this.#itemsByProjectPath[projectItem.projectPath] = projectItem;
      }
    }
  }

  setProjectFolder(newFolder: IFolder) {
    if (this.#projectFolder !== newFolder) {
      this._unapplyFromProjectFolder();
      this.#projectFolder = newFolder;
      this._applyToProjectFolder();
    }

    this.#isProjectFolderEnsured = true;
  }

  _unapplyFromProjectFolder() {
    if (this.#projectFolder) {
      this.#projectFolder.storage.onFileContentsUpdated.unsubscribe(this._handleProjectFileContentsUpdated);
      this.#projectFolder.onChildFolderMoved.unsubscribe(this._handleProjectFolderMoved);
    }
  }

  _applyToProjectFolder() {
    if (this.#projectFolder) {
      this.#projectFolder.storage.readOnly = this.#readOnlySafety;

      this.#projectFolder.storage.onFileContentsUpdated.subscribe(this._handleProjectFileContentsUpdated);
      this.#projectFolder.onChildFolderMoved.subscribe(this._handleProjectFolderMoved);
    }
  }

  async ensureProjectFolder(force?: boolean): Promise<IFolder> {
    if (!force && this.#projectFolder !== null && this.#isProjectFolderEnsured) {
      return this.#projectFolder;
    }

    if (
      this.#data.localFolderPath !== undefined &&
      this.#carto.ensureLocalFolder !== undefined &&
      this.#carto.localFolderExists !== undefined
    ) {
      const folderExists = await this.#carto.localFolderExists(this.#data.localFolderPath);

      if (folderExists) {
        const folder = this.#carto.ensureLocalFolder(this.#data.localFolderPath);

        if (folder !== this.#projectFolder) {
          this._unapplyFromProjectFolder();

          await folder.ensureExists();

          this.#projectFolder = folder;
          this._applyToProjectFolder();
        }
      } else {
        const folder = this.#carto.projectsStorage.rootFolder.ensureFolder(
          ProjectUtilities.canonicalizeStoragePath(this.#data.name)
        );

        if (folder !== this.#projectFolder) {
          this._unapplyFromProjectFolder();

          await folder.ensureExists();

          this.#projectFolder = folder;
          this._applyToProjectFolder();
          Log.debug(
            "Using project storage root folder as a backup because local folder path could not be found: " +
              this.#projectFolder.fullPath
          );
        }

        this.#errorState = ProjectErrorState.projectFolderOrFileDoesNotExist;
      }
    } else if (
      this.#data.mainDeployFolderPath !== undefined &&
      this.#carto.ensureLocalFolder !== undefined &&
      this.#carto.localFolderExists !== undefined
    ) {
      const folder = this.#carto.projectsStorage.rootFolder.ensureFolder(
        ProjectUtilities.canonicalizeStoragePath(this.#data.name)
      );

      if (folder !== this.#projectFolder) {
        this._unapplyFromProjectFolder();

        await folder.ensureExists();

        this.#projectFolder = folder;
        this._applyToProjectFolder();
      }

      const deployFolderExists = await this.#carto.localFolderExists(this.#data.mainDeployFolderPath);

      if (deployFolderExists) {
        const folder = this.#carto.ensureLocalFolder(this.#data.mainDeployFolderPath);

        if (folder !== this.#mainDeployFolder) {
          this.#mainDeployFolder = folder;

          this.#mainDeploySync = new ProjectDeploySync(this, folder);

          await this.#mainDeploySync.fullIngestIntoProject();
        }
      } else {
        this.#errorState = ProjectErrorState.projectFolderOrFileDoesNotExist;
      }
    } else if (
      this.#data.mainDeployFolderPath !== undefined &&
      this.#carto.isDeployingToComMojang &&
      this.#carto.deploymentStorage
    ) {
      const folder = this.#carto.projectsStorage.rootFolder.ensureFolder(
        ProjectUtilities.canonicalizeStoragePath(this.#data.name)
      );

      if (folder !== this.#projectFolder) {
        this._unapplyFromProjectFolder();
        await folder.ensureExists();
        this.#projectFolder = folder;
        this._applyToProjectFolder();
      }

      const deployFolder = await this.#carto.deploymentStorage.ensureFolderFromStorageRelativePath(
        this.#data.mainDeployFolderPath
      );
      const deployFolderExists = await deployFolder.exists();

      if (deployFolderExists) {
        if (deployFolder !== this.#mainDeployFolder) {
          this.#mainDeployFolder = folder;
          this.#mainDeploySync = new ProjectDeploySync(this, deployFolder);

          await this.#mainDeploySync.fullIngestIntoProject();
        }
      } else {
        this.#errorState = ProjectErrorState.projectFolderOrFileDoesNotExist;
      }
    } else if (
      this.#data.localFilePath !== undefined &&
      this.#carto.ensureLocalFolder !== undefined &&
      this.#carto.localFileExists !== undefined &&
      this.#carto.localFolderExists !== undefined
    ) {
      const folderPath = StorageUtilities.getFolderPath(this.#data.localFilePath);
      const fileName = StorageUtilities.getLeafName(this.#data.localFilePath);

      if (!fileName || fileName.length < 2 || !folderPath || folderPath.length < 2) {
        throw new Error("Could not process file with path: `" + this.#data.localFilePath + "`");
      }

      const containingFolder = this.#carto.ensureLocalFolder(folderPath);

      const file = containingFolder.ensureFile(fileName);

      const fileExists = await file.exists();

      if (fileExists) {
        this.#projectCabinetFile = file;

        await this.ensureProjectFolderFromCabinet();

        Log.assert(
          this.#projectFolder !== undefined,
          "Could not create a project folder from " + this.#data.localFilePath
        );

        if (this.#accessoryFilePaths && this.#projectFolder) {
          for (let i = 0; i < this.#accessoryFilePaths.length; i++) {
            if (
              (this.#accessoryFilePaths[i].startsWith("\\") || this.#accessoryFilePaths[i].indexOf(":") >= 0) &&
              this.carto.localFileExists &&
              this.carto.ensureLocalFolder
            ) {
              if (StorageUtilities.isUsableFile(this.#accessoryFilePaths[i])) {
                const exists = await this.carto.localFileExists(this.#accessoryFilePaths[i]);

                if (exists) {
                  const folder = this.carto.ensureLocalFolder(
                    StorageUtilities.getFolderPath(this.#accessoryFilePaths[i])
                  );

                  if (folder) {
                    folder.storage.readOnly = true;

                    const fileName = StorageUtilities.getLeafName(this.#accessoryFilePaths[i]);
                    await folder.load();
                    const file = folder.files[fileName];

                    if (file && (await file.exists())) {
                      if (this.#accessoryFoldersForFilePaths === null) {
                        this.#accessoryFoldersForFilePaths = [];
                      }
                      this.#accessoryFoldersForFilePaths.push(file.parentFolder);
                      this._inferProjectItemFromFile(file, file.parentFolder, file.storageRelativePath);
                    }
                  }
                }
              }
            } else {
              const addFile = containingFolder.ensureFile(this.#accessoryFilePaths[i]);

              const additionalFileExists = await addFile.exists();
              if (additionalFileExists) {
                let isChildOfExistingFolder = false;

                if (this.#accessoryFoldersForFilePaths === null) {
                  this.#accessoryFoldersForFilePaths = [];
                }

                for (let j = 0; j < this.#accessoryFoldersForFilePaths.length; j++) {
                  let addFileStoragePath = addFile.getFolderRelativePath(this.#accessoryFoldersForFilePaths[j]);

                  if (addFileStoragePath) {
                    isChildOfExistingFolder = true;
                    this._inferProjectItemFromFile(addFile, this.#accessoryFoldersForFilePaths[j], addFileStoragePath);
                  }
                }

                if (!isChildOfExistingFolder) {
                  if (addFile.parentFolder) {
                    let addFileStoragePath = addFile.getFolderRelativePath(addFile.parentFolder);
                    if (addFileStoragePath) {
                      this.#accessoryFoldersForFilePaths.push(addFile.parentFolder);
                      this._inferProjectItemFromFile(addFile, addFile.parentFolder, addFileStoragePath);
                    }
                  }
                }
              }
            }
          }
        }
      }

      if (!this.#projectFolder) {
        const folder = this.#carto.projectsStorage.rootFolder.ensureFolder(
          ProjectUtilities.canonicalizeStoragePath(this.#data.name)
        );
        if (folder !== this.#projectFolder) {
          this._unapplyFromProjectFolder();
          this.#projectFolder = folder;
          this._applyToProjectFolder();
        }

        this.#errorState = ProjectErrorState.projectFolderOrFileDoesNotExist;
      }
    } else if (this.#useProjectNameInProjectStorage) {
      const folder = this.#carto.projectsStorage.rootFolder.ensureFolder(this.name);

      if (folder !== this.#projectFolder) {
        this._unapplyFromProjectFolder();
        this.#projectFolder = folder;
        this._applyToProjectFolder();
      }
    } else {
      // Log.debug("Using project storage root folder subfolder: " + this.#data.dataStorageRelativePath);

      const folder = await this.#carto.projectsStorage.ensureFolderFromStorageRelativePath(
        this.#data.dataStorageRelativePath
      );

      if (folder !== this.#projectFolder) {
        this._unapplyFromProjectFolder();
        this.#projectFolder = folder;
        this._applyToProjectFolder();
      }
    }

    const result = await this.#projectFolder.ensureExists();

    this.#isProjectFolderEnsured = result;

    return this.#projectFolder;
  }

  async _inferProjectItemFromFile(file: IFile, folder: IFolder, fileStoragePath: string) {
    const fileName = StorageUtilities.canonicalizeName(file.name);

    if (fileName.endsWith(".data.json")) {
      this.ensureItemByProjectPath(
        fileStoragePath,
        ProjectItemStorageType.singleFile,
        file.name,
        ProjectItemType.projectSummaryMetadata,
        undefined,
        ProjectItemCreationType.normal,
        file
      );
    } else if (fileName.endsWith(".tags.json")) {
      this.ensureItemByProjectPath(
        fileStoragePath,
        ProjectItemStorageType.singleFile,
        file.name,
        ProjectItemType.tagsMetadata,
        undefined,
        ProjectItemCreationType.normal,
        file
      );
    }
  }

  _handleProjectFolderMoved(folder: IFolder, folderMove: IFolderMove) {
    // refresh project paths from files/folders where possible
    this.updateProjectItemsFromContent();

    if (folderMove.previousStoragePath && this.#projectFolder) {
      const newProjectPath = folderMove.folder.getFolderRelativePath(this.#projectFolder);

      if (newProjectPath) {
        const storageRelativeComponent = this.#projectFolder.fullPath.substring(
          0,
          folderMove.folder.fullPath.length - newProjectPath.length + 1
        );

        let previousPath = folderMove.previousStoragePath;

        if (previousPath.startsWith(storageRelativeComponent)) {
          previousPath = previousPath.substring(storageRelativeComponent.length);
        }

        for (const item of this.items) {
          if (item && item.projectPath && item.projectPath.startsWith(previousPath)) {
            item.projectPath = newProjectPath + item.projectPath.substring(previousPath.length);
          }
        }
      }
    }
  }

  async _handleProjectFileContentsUpdated(storage: IStorage, file: IFile) {
    if (!this.#projectFolder) {
      return;
    }

    let rootRelativePath = file.storageRelativePath;

    if (
      this.#projectFolder.storageRelativePath.length > 0 &&
      rootRelativePath.startsWith(this.#projectFolder.storageRelativePath)
    ) {
      rootRelativePath = rootRelativePath.substring(this.#projectFolder.storageRelativePath.length - 1);
    }

    const storagePath = ProjectUtilities.canonicalizeStoragePath(rootRelativePath);

    if (!this.changedFilesSinceLastSaved[storagePath]) {
      this.changedFilesSinceLastSaved[storagePath] = file;

      this._onNeedsSaveChanged.dispatch(this, this);
    }

    const item = this.#itemsByProjectPath[storagePath];
    if (item) {
      this.notifyProjectItemChanged(item);
    }
  }

  async ensureDistFolder(): Promise<IFolder> {
    if (this.#distBuildFolder) {
      return this.#distBuildFolder;
    }

    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.#distBuildFolder === null) {
      this.#distBuildFolder = this.#projectFolder.ensureFolder("dist");
      await this.#distBuildFolder.ensureExists();
    }

    return this.#distBuildFolder;
  }

  async ensureDistBuildScriptsFolder(): Promise<IFolder> {
    if (this.#distBuildScriptsFolder) {
      return this.#distBuildScriptsFolder;
    }

    await this.ensureDistFolder();

    if (this.#distBuildFolder === undefined || this.#distBuildFolder === null) {
      throw new Error("Unexpectedly could not create dist folder");
    }

    if (this.#distBuildScriptsFolder === null) {
      this.#distBuildScriptsFolder = this.#distBuildFolder.ensureFolder("scripts");
      await this.#distBuildScriptsFolder.ensureExists();
    }

    return this.#distBuildScriptsFolder;
  }

  getLibFolder(): IFolder | null {
    if (this.#libFolder) {
      return this.#libFolder;
    }

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      return null;
    }

    if (this.#libFolder === null) {
      this.#libFolder = this.#projectFolder.ensureFolder("lib");
    }

    return this.#libFolder;
  }

  getDistBuildFolder(): IFolder | null {
    if (this.#distBuildFolder) {
      return this.#distBuildFolder;
    }

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      return null;
    }

    if (this.#distBuildFolder === null) {
      this.#distBuildFolder = this.#projectFolder.ensureFolder("dist");
    }

    return this.#distBuildFolder;
  }

  async ensureLibFolder(): Promise<IFolder> {
    if (this.#libFolder) {
      return this.#libFolder;
    }

    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.#libFolder === null) {
      this.#libFolder = this.#projectFolder.ensureFolder("lib");
      await this.#libFolder.ensureExists();
    }

    return this.#libFolder;
  }

  getLibScriptsFolder(): IFolder | null {
    if (this.#libScriptsFolder) {
      return this.#libScriptsFolder;
    }

    const libFolder = this.getLibFolder();

    if (libFolder) {
      this.#libScriptsFolder = libFolder.ensureFolder("scripts");
    }

    return this.#libScriptsFolder;
  }

  getDistBuildScriptsFolder(): IFolder | null {
    if (this.#distBuildScriptsFolder) {
      return this.#distBuildScriptsFolder;
    }

    const distFolder = this.getDistBuildFolder();

    if (distFolder) {
      this.#distBuildScriptsFolder = distFolder.ensureFolder("scripts");
    }

    return this.#distBuildScriptsFolder;
  }

  async ensureLibScriptsFolder(): Promise<IFolder> {
    if (this.#libScriptsFolder) {
      return this.#libScriptsFolder;
    }

    await this.ensureLibFolder();

    if (this.#libFolder === undefined || this.#libFolder === null) {
      throw new Error("Unexpectedly could not create dist folder");
    }

    if (this.#libScriptsFolder === null) {
      this.#libScriptsFolder = this.#libFolder.ensureFolder("scripts");
      await this.#libScriptsFolder.ensureExists();
    }

    return this.#libScriptsFolder;
  }

  async ensureDocsFolder(): Promise<IFolder> {
    if (this.#docsContainer !== null) {
      return this.#docsContainer;
    }

    const rootFolder = await this.ensureProjectFolder();

    this.#docsContainer = rootFolder.ensureFolder("docs");

    return this.#docsContainer;
  }

  async ensureDefaultScriptsFolder(): Promise<IFolder> {
    if (this.#defaultScriptsFolder !== null) {
      return this.#defaultScriptsFolder;
    }

    for (let i = 0; i < this.items.length; i++) {
      const pi = this.items[i];

      if (pi.itemType === ProjectItemType.js || pi.itemType === ProjectItemType.ts) {
        await pi.ensureFileStorage();

        if (pi.file) {
          this.#defaultScriptsFolder = pi.file.parentFolder;

          if (this.#defaultScriptsFolder !== null) {
            return this.#defaultScriptsFolder;
          }
        }
      }
    }

    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.#defaultScriptsFolder !== null) {
      return this.#defaultScriptsFolder;
    }

    if (this.#defaultScriptsFolder === null) {
      await this.#projectFolder.load();

      const rootScriptsFolder = this.#projectFolder.folders["scripts"];

      if (rootScriptsFolder) {
        const rootScriptsFolderExists = await rootScriptsFolder.exists();

        if (rootScriptsFolderExists) {
          this.#defaultScriptsFolder = rootScriptsFolder;
          return this.#defaultScriptsFolder;
        }
      }
    }

    const defaultBehaviorPackFolder = await this.ensureDefaultBehaviorPackFolder();

    if (!defaultBehaviorPackFolder) {
      return this.#projectFolder.ensureFolder("scripts");
    }

    const defaultBehaviorPackScriptsFolder = defaultBehaviorPackFolder.ensureFolder("scripts");

    await defaultBehaviorPackScriptsFolder.ensureExists();

    this.#defaultScriptsFolder = defaultBehaviorPackScriptsFolder;

    return this.#defaultScriptsFolder;
  }

  async getDefaultWorldFolder(): Promise<IFolder | null> {
    if (this.#defaultWorldFolder !== null) {
      return this.#defaultWorldFolder;
    }

    await this.loadFolderStructure();

    return this.#defaultWorldFolder;
  }

  ensurePacks() {
    for (const item of this.items) {
      if (item.itemType === ProjectItemType.behaviorPackManifestJson) {
        const file = item.file;

        if (file && file.parentFolder) {
          this.ensurePackByFolder(file.parentFolder, PackType.behavior);
        }
      } else if (item.itemType === ProjectItemType.resourcePackManifestJson) {
        const file = item.file;

        if (file && file.parentFolder) {
          this.ensurePackByFolder(file.parentFolder, PackType.resource);
        }
      } else if (item.itemType === ProjectItemType.skinPackManifestJson) {
        const file = item.file;

        if (file && file.parentFolder) {
          this.ensurePackByFolder(file.parentFolder, PackType.skin);
        }
      }
    }
  }

  async getDefaultBehaviorPackFolder(force?: boolean, preventEnsureFileStorage?: boolean): Promise<IFolder | null> {
    if (this.#defaultBehaviorPackFolder !== null && !force) {
      return this.#defaultBehaviorPackFolder;
    }

    await this.loadFolderStructure();

    if (this.#defaultBehaviorPackFolder !== null && !force) {
      return this.#defaultBehaviorPackFolder;
    }

    if (force) {
      this.#defaultBehaviorPackFolder = null;
    }

    for (let i = 0; i < this.items.length; i++) {
      const pi = this.items[i];

      if (pi.itemType === ProjectItemType.behaviorPackManifestJson) {
        if (!preventEnsureFileStorage) {
          // this is an option to avoid stack overflows of ensureFileStorage -> updateAutogenerated -> ensureFileStorage
          await pi.ensureFileStorage();
        }

        if (pi.file) {
          this.#defaultBehaviorPackFolder = pi.file.parentFolder;

          this.ensurePackByFolder(this.#defaultBehaviorPackFolder, PackType.behavior, pi.isInWorld);

          if (this.#defaultBehaviorPackFolder !== null) {
            return this.#defaultBehaviorPackFolder;
          }
        }
      }
    }

    return this.#defaultBehaviorPackFolder;
  }

  async getDefaultBehaviorPack(): Promise<Pack | undefined> {
    const folder = await this.getDefaultBehaviorPackFolder(false, false);

    if (!folder) {
      return undefined;
    }

    return await this.ensurePackByFolder(folder, PackType.behavior);
  }

  async ensureDefaultBehaviorPackFolder(force?: boolean): Promise<IFolder> {
    if (this.#defaultBehaviorPackFolder !== null && !force) {
      return this.#defaultBehaviorPackFolder;
    }

    await this.getDefaultBehaviorPackFolder(force);

    if (this.#defaultBehaviorPackFolder !== null) {
      return this.#defaultBehaviorPackFolder;
    }

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.#behaviorPacksContainer === null) {
      this.#behaviorPacksContainer = this.#projectFolder.ensureFolder("behavior_packs");
      await this.#behaviorPacksContainer.ensureExists();
    }

    this.#defaultBehaviorPackFolder = this.#behaviorPacksContainer.ensureFolder(
      MinecraftUtilities.makeNameFolderSafe(this.effectiveShortName + "_bp")
    );

    await this.#defaultBehaviorPackFolder.ensureExists();

    this.ensurePackByFolder(this.#defaultBehaviorPackFolder, PackType.behavior, false);

    return this.#defaultBehaviorPackFolder;
  }

  async ensurePackByFolder(folder: IFolder, packType: PackType, isInWorld?: boolean) {
    const targetPath = StorageUtilities.canonicalizePath(folder.extendedPath);

    if (!this.projectFolder) {
      throw new Error("PEPBF");
    }

    for (const pack of this.#packs) {
      if (pack.folder === folder) {
        return pack;
      }

      if (pack.folder && StorageUtilities.canonicalizePath(pack.folder.extendedPath) === targetPath) {
        return pack;
      }
    }

    const newPack = Pack.ensureOnFolder(folder, packType, this);

    if (!this.#packs.includes(newPack)) {
      this.#packs.push(newPack);
    }

    let itemType = ProjectItemType.behaviorPackFolder;

    if (packType === PackType.resource) {
      itemType = ProjectItemType.resourcePackFolder;
    } else if (packType === PackType.skin) {
      itemType = ProjectItemType.skinPackFolder;
    }

    const folderPath = folder.getFolderRelativePath(this.projectFolder);

    if (!folderPath) {
      throw new Error("PEBBFA");
    }

    const folderProjectItem = this.ensureItemByProjectPath(
      folderPath,
      ProjectItemStorageType.folder,
      folder.name,
      itemType,
      undefined,
      ProjectItemCreationType.normal,
      undefined,
      undefined,
      isInWorld
    );

    newPack.projectItem = folderProjectItem;

    return newPack;
  }

  async getDefaultSkinPackFolder(force?: boolean): Promise<IFolder | null> {
    if (this.#defaultSkinPackFolder !== null && !force) {
      return this.#defaultSkinPackFolder;
    }

    await this.loadFolderStructure();

    if (this.#defaultSkinPackFolder !== null && !force) {
      return this.#defaultSkinPackFolder;
    }

    if (force) {
      this.#defaultSkinPackFolder = null;
    }

    for (let i = 0; i < this.items.length; i++) {
      const pi = this.items[i];

      if (pi.itemType === ProjectItemType.skinPackManifestJson) {
        await pi.ensureFileStorage();

        if (pi.file) {
          this.#defaultSkinPackFolder = pi.file.parentFolder;

          this.ensurePackByFolder(this.#defaultSkinPackFolder, PackType.skin, pi.isInWorld);

          if (this.#defaultSkinPackFolder !== null) {
            return this.#defaultSkinPackFolder;
          }
        }
      }
    }

    return null;
  }

  async getDefaultResourcePackFolder(force?: boolean): Promise<IFolder | null> {
    if (this.#defaultResourcePackFolder !== null && !force) {
      return this.#defaultResourcePackFolder;
    }

    await this.loadFolderStructure();

    if (this.#defaultResourcePackFolder !== null && !force) {
      return this.#defaultResourcePackFolder;
    }

    if (force) {
      this.#defaultResourcePackFolder = null;
    }

    for (let i = 0; i < this.items.length; i++) {
      const pi = this.items[i];

      if (pi.itemType === ProjectItemType.resourcePackManifestJson) {
        await pi.ensureFileStorage();

        if (pi.file) {
          this.#defaultResourcePackFolder = pi.file.parentFolder;

          this.ensurePackByFolder(this.#defaultResourcePackFolder, PackType.resource, pi.isInWorld);

          if (this.#defaultResourcePackFolder !== null) {
            return this.#defaultResourcePackFolder;
          }
        }
      }
    }

    return null;
  }

  async ensureDefaultResourcePackFolder(force?: boolean): Promise<IFolder> {
    if (this.#defaultResourcePackFolder !== null && !force) {
      return this.#defaultResourcePackFolder;
    }

    if (force) {
      this.#defaultResourcePackFolder = null;
    }

    await this.getDefaultResourcePackFolder(force);

    if (this.#defaultResourcePackFolder !== null) {
      return this.#defaultResourcePackFolder;
    }

    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.#defaultResourcePackFolder !== null) {
      return this.#defaultResourcePackFolder;
    }

    if (this.#resourcePacksContainer === null) {
      this.#resourcePacksContainer = this.#projectFolder.ensureFolder("resource_packs");
      await this.#resourcePacksContainer.ensureExists();
    }

    this.#defaultResourcePackFolder = this.#resourcePacksContainer.ensureFolder(
      MinecraftUtilities.makeNameFolderSafe(this.effectiveShortName + "_rp")
    );

    await this.#defaultResourcePackFolder.ensureExists();

    this.ensurePackByFolder(this.#defaultResourcePackFolder, PackType.resource);

    return this.#defaultResourcePackFolder;
  }

  async ensureLoadedProjectFolder(force?: boolean): Promise<IFolder> {
    const projectFolder = await this.ensureProjectFolder();

    await projectFolder.load(force ? force : false);

    if (!this.readOnlySafety) {
      await this.save();
    }

    return projectFolder;
  }
}
