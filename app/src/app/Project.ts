import IFile from "../storage/IFile";
import IFolder from "../storage/IFolder";
import Carto from "./Carto";
import IProjectData, { ProjectEditPreference, ProjectScriptLanguage, ProjectScriptVersion } from "./IProjectData";
import { ProjectDataType, ProjectFocus } from "./IProjectData";
import ProjectItem from "./ProjectItem";
import IProjectItemData, { ProjectItemStorageType, ProjectItemType } from "./IProjectItemData";
import Utilities from "./../core/Utilities";
import { EventDispatcher } from "ste-events";
import StorageUtilities from "../storage/StorageUtilities";
import Structure from "../minecraft/Structure";
import Converter from "../minecraft/Converter";
import ProjectContent from "./ProjectContent";
import GitHubStorage from "../github/GitHubStorage";
import Log from "../core/Log";
import DifferenceSet from "../storage/DifferenceSet";
import IAddonManifest from "../minecraft/IAddonManifest";
import IProjectScriptState from "./IProjectScriptState";
import ProjectUtilities from "./ProjectUtilities";
import IStorage from "../storage/IStorage";
import { GameType, Generator } from "../minecraft/WorldLevelDat";
import { BackupType } from "../minecraft/IWorldSettings";
import BehaviorManifestJson from "../minecraft/BehaviorManifestJson";
import MinecraftUtilities from "../minecraft/MinecraftUtilities";
import LocManager from "../minecraft/LocManager";
import ProjectInfoSet from "../info/ProjectInfoSet";
import ProjectUpdateRunner from "../updates/ProjectUpdateRunner";
import ProjectUpdateResult from "../updates/ProjectUpdateResult";
import { StatusTopic } from "./Status";
import { ProjectInfoSuite } from "../info/IProjectInfoData";

export enum ProjectAutoDeploymentMode {
  deployOnSave = 0,
  noAutoDeployment = 1,
}

export enum ProjectErrorState {
  noError = 0,
  projectFolderOrFileDoesNotExist = 1,
}

export enum ProjectRole {
  general = 0,
  documentation = 1,
}

export enum FolderContext {
  unknown = 0,
  behaviorPack = 1,
  resourcePack = 2,
  skinPack = 3,
  docs = 4,
  worldOrWorldTemplate = 5,
  typeDefs = 6,
  buildFolder = 7,
  vscodeFolder = 8,
  resourcePackSubPack = 9,
}

export const AUTOGENERATED_CONTENT_TOKEN = "==== AUTOGENERATED";
export const AUTOGENERATED_JS_SEPARATOR =
  "\r\n// ===== AUTOGENERATED CONTENT ===== CONTENT AT OR BELOW THIS LINE WILL BE WIPED AND UPDATED WHEN USED IN TOOLING";
export const AUTOGENERATED_WHOLEFILE_JS_SEPARATOR =
  "// ===== AUTOGENERATED FILE ===== CONTENT WITHIN THIS FILE WILL BE WIPED AND UPDATED WHEN USED IN TOOLING";
export const AUTOGENERATED_WHOLEFILE_MCFUNCTION_SEPARATOR =
  "# ===== AUTOGENERATED FILE ===== CONTENT WITHIN THIS FILE WILL BE WIPED AND UPDATED WHEN USED IN TOOLING";
export const AUTOGENERATED_WHOLEFILE_GENERAL_SEPARATOR =
  "===== AUTOGENERATED FILE ===== CONTENT WITHIN THIS FILE WILL BE WIPED AND UPDATED WHEN USED IN TOOLING";

export const minecraftScriptModules: {
  id: string;
  module_name?: string;
  uuid?: string;
  preferredVersion: string | number[];
}[] = [
  { id: "@minecraft/server", module_name: "@minecraft/server", preferredVersion: "1.1.0-beta" },
  { id: "@minecraft/server-gametest", module_name: "@minecraft/server-gametest", preferredVersion: "1.0.0-beta" },
  { id: "@minecraft/server-ui", module_name: "@minecraft/server-ui", preferredVersion: "1.0.0-beta" },
  { id: "@minecraft/server-admin", module_name: "@minecraft/server-admin", preferredVersion: "1.0.0-beta" },
  { id: "@minecraft/server-net", module_name: "@minecraft/server-net", preferredVersion: "1.0.0-beta" },
];

export const remappedMinecraftScriptModules: { [oldModuleName: string]: string } = {
  "mojang-minecraft": "@minecraft/server",
  "mojang-gametest": "@minecraft/server-gametest",
  "mojang-minecraft-ui": "@minecraft/server-ui",
  "mojang-server-admin": "@minecraft/server-admin",
  "mojang-net": "@minecraft/server-net",
  "@minecraft/server-editor-bindings": "@minecraft/server-editor",
};

export default class Project {
  #data: IProjectData;
  #file: IFile | null;
  #carto: Carto;
  loc: LocManager;
  #errorState = ProjectErrorState.noError;
  #infoSet: ProjectInfoSet | null = null;

  #gitHubStorage?: GitHubStorage;

  public differencesFromGitHub?: DifferenceSet;

  #projectFolder: IFolder | null;
  #accessoryFolders: IFolder[] | null = null;
  #projectCabinetFile: IFile | null = null;

  #buildFolder: IFolder | null = null;
  #docsContainer: IFolder | null;

  #worldContainer: IFolder | null = null;

  #isDisposed: boolean = false;

  #role: ProjectRole = ProjectRole.general;

  #behaviorPacksContainer: IFolder | null;
  #defaultBehaviorPackFolder: IFolder | null;

  #defaultWorldFolder: IFolder | null;

  #defaultScriptsFolder: IFolder | null;

  #resourcePacksContainer: IFolder | null;
  #defaultResourcePackFolder: IFolder | null;

  #items: ProjectItem[];
  #itemsByStoragePath: { [storagePath: string]: ProjectItem | undefined } = {};

  public changedFilesSinceLastSaved: { [storagePath: string]: IFile | undefined } = {};

  #isLoaded = false;
  #isProjectFolderEnsured = false;
  #useProjectNameInProjectStorage = false;

  #accessoryFiles: string[] | undefined;

  private _onPropertyChanged = new EventDispatcher<Project, string>();
  private _onLoaded = new EventDispatcher<Project, Project>();
  private _onSaved = new EventDispatcher<Project, Project>();
  private _onNeedsSaveChanged = new EventDispatcher<Project, Project>();
  private _onItemChanged = new EventDispatcher<Project, ProjectItem>();
  private _onItemAdded = new EventDispatcher<Project, ProjectItem>();
  private _onItemRemoved = new EventDispatcher<Project, ProjectItem>();
  private _hasInferredFiles = false;

  public get carto() {
    return this.#carto;
  }

  public get role() {
    return this.#role;
  }

  public get errorState() {
    return this.#errorState;
  }

  public get file() {
    return this.#file;
  }

  public get accessoryFiles() {
    return this.#accessoryFiles;
  }

  public set accessoryFiles(files: string[] | undefined) {
    this.#accessoryFiles = files;
  }

  public get infoSet() {
    if (!this.#infoSet) {
      this.#infoSet = new ProjectInfoSet(this, ProjectInfoSuite.allExceptAddOn);
    }

    return this.#infoSet;
  }

  public hasUnsavedChanges() {
    for (const filePath in this.changedFilesSinceLastSaved) {
      return true;
    }

    return false;
  }

  public getBehaviorPackCount() {
    let count = 0;
    for (const projectItem of this.items) {
      if (projectItem.itemType === ProjectItemType.behaviorPackManifestJson) {
        count++;
      }
    }

    return count;
  }

  public getResourcePackCount() {
    let count = 0;

    for (const projectItem of this.items) {
      if (projectItem.itemType === ProjectItemType.resourcePackManifestJson) {
        count++;
      }
    }

    return count;
  }

  public getIsPackFolderManaged() {
    let rpCount = 0;
    let bpCount = 0;

    for (const projectItem of this.items) {
      if (projectItem.itemType === ProjectItemType.behaviorPackManifestJson) {
        bpCount++;
      } else if (projectItem.itemType === ProjectItemType.resourcePackManifestJson) {
        rpCount++;
      }
    }

    return bpCount < 2 && rpCount < 2;
  }

  public get key() {
    if (this.localFilePath) {
      return StorageUtilities.canonicalizePath(this.localFilePath);
    }

    if (this.#projectFolder) {
      if (this.#projectFolder.name && this.#projectFolder.name.length > 0) {
        return this.#projectFolder.name;
      }

      return StorageUtilities.canonicalizePath(this.#projectFolder.fullPath);
    }

    if (this.#file) {
      return StorageUtilities.canonicalizePath(this.#file.name);
    }

    return this.title;
  }

  public get containerName() {
    if (this.localFilePath) {
      return StorageUtilities.getLeafName(this.localFilePath);
    }

    if (this.#projectFolder) {
      if (this.#projectFolder.name && this.#projectFolder.name.length > 0) {
        return this.#projectFolder.name;
      }

      return StorageUtilities.getLeafName(this.#projectFolder.fullPath);
    }

    if (this.#file) {
      return StorageUtilities.getBaseFromName(this.#file.name);
    }

    return this.title;
  }

  public get defaultNamespace(): string | undefined {
    return this.#data.defaultNamespace;
  }

  public get effectiveDefaultNamespace(): string {
    if (this.#data.defaultNamespace || this.#data.defaultNamespace === "") {
      return this.#data.defaultNamespace;
    }

    return this.effectiveShortName;
  }

  public set defaultNamespace(newDefaultNamespace: string | undefined) {
    if (newDefaultNamespace !== this.#data.defaultNamespace) {
      this.#data.defaultNamespace = newDefaultNamespace;

      this._onPropertyChanged.dispatch(this, "defaultNamespace");
    }
  }

  public get scriptEntryPoint(): string {
    if (this.#data.scriptEntryPoint || this.#data.scriptEntryPoint === "") {
      return this.#data.scriptEntryPoint;
    }

    return this.scriptEntryPoint;
  }

  public set scriptEntryPoint(newScriptEntryPoint: string) {
    if (newScriptEntryPoint !== this.#data.scriptEntryPoint) {
      this.#data.scriptEntryPoint = newScriptEntryPoint;

      this._onPropertyChanged.dispatch(this, "scriptEntryPoint");
    }
  }

  public get worldSettings() {
    return this.#data.worldSettings;
  }

  public get usesCustomWorldSettings() {
    return this.#data.usesCustomWorldSettings;
  }

  public set usesCustomWorldSettings(newValue: boolean | undefined) {
    this.#data.usesCustomWorldSettings = newValue;
  }

  public get isLoaded() {
    return this.#isLoaded;
  }

  public get buildFolder() {
    return this.#buildFolder;
  }

  public get defaultWorldFolder() {
    return this.#defaultWorldFolder;
  }

  public get defaultBehaviorPackFolder() {
    return this.#defaultBehaviorPackFolder;
  }

  public get defaultResourcePackFolder() {
    return this.#defaultResourcePackFolder;
  }

  public get useProjectNameInRootProjectStorage() {
    return this.#useProjectNameInProjectStorage;
  }

  public set useProjectNameInRootProjectStorage(newVal: boolean) {
    this.#useProjectNameInProjectStorage = newVal;
  }

  public get onPropertyChanged() {
    return this._onPropertyChanged.asEvent();
  }

  public get onLoaded() {
    return this._onLoaded.asEvent();
  }

  public get onSaved() {
    return this._onSaved.asEvent();
  }

  public get onNeedsSaveChanged() {
    return this._onNeedsSaveChanged.asEvent();
  }

  public get onItemChanged() {
    return this._onItemChanged.asEvent();
  }

  public get onItemAdded() {
    return this._onItemAdded.asEvent();
  }

  public get onItemRemoved() {
    return this._onItemRemoved.asEvent();
  }

  get projectFolder(): IFolder | null {
    return this.#projectFolder;
  }

  get accessoryFolders(): IFolder[] | null {
    return this.#accessoryFolders;
  }

  get localFolderPath(): string | undefined {
    return this.#data.localFolderPath;
  }

  set localFolderPath(newPath: string | undefined) {
    this.#data.localFolderPath = newPath;
  }

  get localFilePath(): string | undefined {
    return this.#data.localFilePath;
  }

  set localFilePath(newPath: string | undefined) {
    this.#data.localFilePath = newPath;
  }

  get items(): ProjectItem[] {
    return this.#items;
  }

  get gitHubReferences() {
    if (this.#data.gitHubReferences === undefined) {
      this.#data.gitHubReferences = [];
    }

    return this.#data.gitHubReferences;
  }

  async getBehaviorPackScriptsFolder() {
    const bpFolder = await this.ensureDefaultBehaviorPackFolder();

    return bpFolder.folders["scripts"];
  }

  async ensureBehaviorPackScriptsFolder() {
    const bpFolder = await this.ensureDefaultBehaviorPackFolder();

    return bpFolder.ensureFolder("scripts");
  }

  async getMainScriptsFolder() {
    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    return this.#projectFolder.folders["scripts"];
  }

  get preferredScriptLanguage() {
    if (
      this.#data.preferredScriptLanguage === undefined ||
      this.#data.preferredScriptLanguage === ProjectScriptLanguage.javaScript
    ) {
      return ProjectScriptLanguage.javaScript;
    }

    return this.#data.preferredScriptLanguage;
  }

  set preferredScriptLanguage(newLanguage: ProjectScriptLanguage) {
    this.#data.preferredScriptLanguage = newLanguage;
  }

  get scriptVersion() {
    if (this.#data.scriptVersion === undefined) {
      return ProjectScriptVersion.latestBeta;
    }

    return this.#data.scriptVersion;
  }

  set scriptVersion(newVersion: ProjectScriptVersion) {
    this.#data.scriptVersion = newVersion;
  }

  get editPreference() {
    if (this.#data.editPreference === undefined) {
      return ProjectEditPreference.summarized;
    }

    return this.#data.editPreference;
  }

  set editPreference(newEditPreference: ProjectEditPreference) {
    this.#data.editPreference = newEditPreference;
  }

  get contentsModified() {
    let val = this.#data.contentsModified;

    if (val === null) {
      return null;
    }

    if (!(val instanceof Date)) {
      val = new Date(val);
    }

    return val;
  }

  public initializeWorldSettings() {
    if (this.#data.worldSettings === undefined) {
      this.#data.worldSettings = {
        gameType: GameType.creative,
        generator: Generator.flat,
        isEditor: false,
        backupType: BackupType.every5Minutes,
        useCustomSettings: false,
      };

      this.ensureDefaultWorldName();
    }
  }

  private ensureDefaultWorldName() {
    if (this.worldSettings && this.worldSettings.name === undefined) {
      this.worldSettings.name = this.name + " " + Utilities.getDateStr(new Date());

      this.save();
    }
  }

  public async addBrowserFile(path: string, file: File) {
    if (!this.projectFolder) {
      return;
    }

    const pathCanon = path.toLowerCase();
    const fileName = file.name.toLowerCase();
    const extension = StorageUtilities.getTypeFromName(file.name);

    if (
      fileName === "level.dat" ||
      extension === "db" ||
      fileName === "current" ||
      fileName.startsWith("manifest-") ||
      fileName === "level.dat_old" ||
      fileName === "levelname.txt" ||
      fileName.startsWith("world_")
    ) {
      if (path.length < 2) {
        path = "/default";
      }

      if (pathCanon.indexOf("worlds") < 0) {
        path = StorageUtilities.joinPath("worlds", path);
      }

      path = StorageUtilities.ensureEndsWithDelimiter(StorageUtilities.absolutize(path));

      const folder = await this.projectFolder.ensureFolderFromRelativePath(path);

      if (fileName === "level.dat") {
        this.ensureItemByStoragePath(
          path,
          ProjectItemStorageType.folder,
          folder.name,
          ProjectItemType.worldFolder,
          false
        );
      }

      const buffer = await file.arrayBuffer();

      const contentFile = folder.ensureFile(file.name);

      contentFile.setContent(new Uint8Array(buffer));

      contentFile.saveContent();
    } else if (extension === "snbt") {
      const operId = await this.#carto.notifyOperationStarted("Saving new SNBT structure file '" + file.name + "'");

      const text = await file.text();

      const folder = this.projectFolder.ensureFolder("structures").ensureFolder("gametests");

      const contentFile = folder.ensureFile(file.name);
      contentFile.setContent(text);
      contentFile.saveContent();

      const relPath = contentFile.getFolderRelativePath(this.projectFolder as IFolder);

      if (relPath !== undefined) {
        this.ensureItemByStoragePath(
          relPath,
          ProjectItemStorageType.singleFile,
          file.name,
          ProjectItemType.structure,
          false
        );
      }

      await this.#carto.notifyOperationEnded(operId, "New SNBT structure file '" + file.name + "' added");
    } else if (extension === "mcworld") {
      const operId = await this.#carto.notifyOperationStarted("Saving new MCWorld file '" + file.name + "'");

      const buffer = await file.arrayBuffer();

      const folder = this.projectFolder.ensureFolder("worlds");

      const contentFile = folder.ensureFile(file.name);

      contentFile.setContent(new Uint8Array(buffer));

      contentFile.saveContent();

      const relPath = contentFile.getFolderRelativePath(this.projectFolder as IFolder);

      if (relPath !== undefined) {
        this.ensureItemByStoragePath(
          relPath,
          ProjectItemStorageType.singleFile,
          file.name,
          ProjectItemType.MCWorld,
          false
        );

        await this._inferProjectItemsFromZipFile(relPath, contentFile, false);
      }

      await this.#carto.notifyOperationEnded(operId, "New MCWorld file '" + file.name + "' added");
    } else if (extension === "mcproject") {
      const operId = await this.#carto.notifyOperationStarted("Saving new MCProject file '" + file.name + "'");

      const buffer = await file.arrayBuffer();

      const folder = this.projectFolder.ensureFolder("projects");

      const contentFile = folder.ensureFile(file.name);

      contentFile.setContent(new Uint8Array(buffer));

      contentFile.saveContent();

      const relPath = contentFile.getFolderRelativePath(this.projectFolder as IFolder);

      if (relPath !== undefined) {
        this.ensureItemByStoragePath(
          relPath,
          ProjectItemStorageType.singleFile,
          file.name,
          ProjectItemType.MCProject,
          false
        );

        await this._inferProjectItemsFromZipFile(relPath, contentFile, false);
      }

      await this.#carto.notifyOperationEnded(operId, "New MCProject file '" + file.name + "' added");
    } else if (extension === "mctemplate") {
      const operId = await this.#carto.notifyOperationStarted("Saving new MCTemplate file '" + file.name + "'");

      const buffer = await file.arrayBuffer();

      const folder = this.projectFolder.ensureFolder("templates");

      const contentFile = folder.ensureFile(file.name);

      contentFile.setContent(new Uint8Array(buffer));

      contentFile.saveContent();

      const relPath = contentFile.getFolderRelativePath(this.projectFolder as IFolder);

      if (relPath !== undefined) {
        this.ensureItemByStoragePath(
          relPath,
          ProjectItemStorageType.singleFile,
          file.name,
          ProjectItemType.MCTemplate,
          false
        );

        await this._inferProjectItemsFromZipFile(relPath, contentFile, false);
      }

      await this.#carto.notifyOperationEnded(operId, "New MCTemplate file '" + file.name + "' added");
    } else if (extension === "mcaddon") {
      const operId = await this.#carto.notifyOperationStarted("Saving new MCAddon file '" + file.name + "'");

      const buffer = await file.arrayBuffer();

      const folder = this.projectFolder.ensureFolder("addons");

      const contentFile = folder.ensureFile(file.name);

      contentFile.setContent(new Uint8Array(buffer));

      contentFile.saveContent();

      const relPath = contentFile.getFolderRelativePath(this.projectFolder as IFolder);

      if (relPath !== undefined) {
        this.ensureItemByStoragePath(
          relPath,
          ProjectItemStorageType.singleFile,
          file.name,
          ProjectItemType.MCAddon,
          false
        );

        await this._inferProjectItemsFromZipFile(relPath, contentFile, false);
      }

      await this.#carto.notifyOperationEnded(operId, "New MCAddon file '" + file.name + "' added");
    } else if (extension === "zip") {
      const operId = await this.#carto.notifyOperationStarted("Saving new zip file '" + file.name + "'");

      const buffer = await file.arrayBuffer();

      const folder = this.projectFolder.ensureFolder("zip");

      const contentFile = folder.ensureFile(file.name);

      contentFile.setContent(new Uint8Array(buffer));

      contentFile.saveContent();

      const relPath = contentFile.getFolderRelativePath(this.projectFolder as IFolder);

      if (relPath !== undefined) {
        this.ensureItemByStoragePath(relPath, ProjectItemStorageType.singleFile, file.name, ProjectItemType.zip, false);

        await this._inferProjectItemsFromZipFile(relPath, contentFile, false);
      }

      await this.#carto.notifyOperationEnded(operId, "New zip file '" + file.name + "' added");
    } else if (extension === "mcpack") {
      const operId = await this.#carto.notifyOperationStarted("Saving new MCPack file '" + file.name + "'");

      const buffer = await file.arrayBuffer();

      const folder = this.projectFolder.ensureFolder("packs");

      const contentFile = folder.ensureFile(file.name);

      contentFile.setContent(new Uint8Array(buffer));

      contentFile.saveContent();

      const relPath = contentFile.getFolderRelativePath(this.projectFolder as IFolder);

      if (relPath !== undefined) {
        this.ensureItemByStoragePath(
          relPath,
          ProjectItemStorageType.singleFile,
          file.name,
          ProjectItemType.MCPack,
          false
        );

        await this._inferProjectItemsFromZipFile(relPath, contentFile, false);
      }

      await this.#carto.notifyOperationEnded(operId, "New zip file '" + file.name + "' added");
    } else if (extension === "mcstructure") {
      const operId = await this.#carto.notifyOperationStarted("Saving new structure file '" + file.name + "'");

      const buffer = await file.arrayBuffer();

      const folder = this.projectFolder.ensureFolder("structures").ensureFolder("gametests");

      const contentFile = folder.ensureFile(file.name);
      contentFile.setContent(new Uint8Array(buffer));
      contentFile.saveContent();

      const relPath = contentFile.getFolderRelativePath(this.projectFolder as IFolder);

      if (relPath !== undefined) {
        this.ensureItemByStoragePath(
          relPath,
          ProjectItemStorageType.singleFile,
          file.name,
          ProjectItemType.structure,
          false
        );
      }

      await this.#carto.notifyOperationEnded(operId, "New structure file '" + file.name + "' added");
    }
  }

  removeItem(item: ProjectItem) {
    const newArr: ProjectItem[] = [];

    for (let i = 0; i < this.items.length; i++) {
      if (this.items[i] !== item) {
        newArr.push(this.items[i]);
      }
    }

    this.#itemsByStoragePath[ProjectUtilities.canonicalizeStoragePath(item.storagePath)] = undefined;

    this.#items = newArr;

    const newDataArr: IProjectItemData[] = [];

    for (let i = 0; i < this.#data.items.length; i++) {
      if (this.#data.items[i].storagePath !== item.storagePath) {
        newDataArr.push(this.#data.items[i]);
      }
    }

    this.#data.items = newDataArr;

    this._onItemRemoved.dispatch(this, item);
  }

  updateContentsModified() {
    this.#data.contentsModified = new Date();
  }

  get modified(): Date | null {
    if (this.#file != null && this.#file.latestModified != null) {
      if (this.contentsModified != null && this.contentsModified > this.#file.latestModified) {
        return this.contentsModified;
      }

      return this.#file.latestModified;
    } else {
      return this.contentsModified;
    }
  }

  get showHiddenItems() {
    if (this.#data.showHiddenItems === true) {
      return true;
    }

    return false;
  }

  set showHiddenItems(showItems: boolean) {
    if (showItems !== this.showHiddenItems) {
      this.#data.showHiddenItems = showItems;

      this._onPropertyChanged.dispatch(this, "showHiddenItems");
    }
  }

  get showFunctions() {
    if (this.#data.showFunctions === undefined) {
      return true;
    }

    return this.#data.showFunctions;
  }

  set showFunctions(showFunctions: boolean) {
    if (showFunctions !== this.showFunctions) {
      this.#data.showFunctions = showFunctions;

      this._onPropertyChanged.dispatch(this, "showFunctions");
    }
  }

  get showAssets() {
    if (this.#data.showAssets === undefined) {
      return true;
    }

    return this.#data.showAssets;
  }

  set showAssets(showAssets: boolean) {
    if (showAssets !== this.showAssets) {
      this.#data.showAssets = showAssets;

      this._onPropertyChanged.dispatch(this, "showAssets");
    }
  }

  get showTypes() {
    if (this.#data.showTypes === undefined) {
      return true;
    }

    return this.#data.showTypes;
  }

  set showTypes(showTypes: boolean) {
    if (showTypes !== this.showTypes) {
      this.#data.showTypes = showTypes;

      this._onPropertyChanged.dispatch(this, "showTypes");
    }
  }

  get name(): string {
    return this.#data.name;
  }

  set name(newName: string) {
    this.#data.name = newName;
  }

  get lastMapDeployedHash(): string | undefined {
    return this.#data.lastMapDeployedHash;
  }

  get lastMapDeployedDate(): Date | undefined {
    return this.#data.lastMapDeployedDate;
  }

  set lastMapDeployedHash(newValue: string | undefined) {
    this.#data.lastMapDeployedHash = newValue;
  }

  set lastMapDeployedDate(newValue: Date | undefined) {
    this.#data.lastMapDeployedDate = newValue;
  }

  get effectiveCreator(): string {
    if (this.#data.creator && this.#data.creator.length > 0) {
      return this.#data.creator;
    }

    if (this.carto.creator && this.carto.creator.length > 0) {
      return this.carto.creator;
    }

    return "contoso";
  }

  get effectiveShortName(): string {
    if (this.#data.shortName && this.#data.shortName.length > 0) {
      return this.#data.shortName;
    }
    if (this.effectiveCreator.length > 0 && this.#data.name && this.#data.name.length > 0) {
      return ProjectUtilities.getSuggestedProjectShortName(this.effectiveCreator, this.#data.name);
    }

    return "cont_game";
  }

  get shortName(): string | undefined {
    return this.#data.shortName;
  }

  set shortName(newShortName: string | undefined) {
    if (this.#data.shortName !== newShortName) {
      this.#data.shortName = newShortName;

      this._onPropertyChanged.dispatch(this, "shortName");
    }
  }

  get creator(): string | undefined {
    return this.#data.creator;
  }

  set creator(newCreator: string | undefined) {
    if (this.#data.creator !== newCreator) {
      this.#data.creator = newCreator;

      this._onPropertyChanged.dispatch(this, "creator");
    }
  }

  get title(): string {
    if (this.#data.title) {
      return this.#data.title;
    }

    return this.name;
  }

  set title(newTitle: string) {
    if (this.#data.title !== newTitle) {
      this.#data.title = newTitle;

      this._onPropertyChanged.dispatch(this, "title");
    }
  }

  set originalFullPath(newOriginalPath: string | undefined) {
    if (this.#data.originalFullPath !== newOriginalPath) {
      this.#data.originalFullPath = newOriginalPath;

      this._onPropertyChanged.dispatch(this, "originalFullPath");
    }
  }

  get originalFullPath(): string | undefined {
    return this.#data.originalFullPath;
  }

  set originalFileList(newFileList: string[] | undefined) {
    if (this.#data.originalFileList !== newFileList) {
      this.#data.originalFileList = newFileList;

      this._onPropertyChanged.dispatch(this, "originalFileList");
    }
  }

  get originalFileList(): string[] | undefined {
    return this.#data.originalFileList;
  }

  set originalGitHubOwner(newGitHubOwner: string | undefined) {
    if (this.#data.originalGitHubOwner !== newGitHubOwner) {
      this.#data.originalGitHubOwner = newGitHubOwner;

      this._onPropertyChanged.dispatch(this, "originalGitHubOwner");
    }
  }

  set originalGalleryId(newGalleryId: string | undefined) {
    if (this.#data.originalGalleryId !== newGalleryId) {
      this.#data.originalGalleryId = newGalleryId;

      this._onPropertyChanged.dispatch(this, "originalGalleryId");
    }
  }

  get originalGalleryId(): string | undefined {
    return this.#data.originalGalleryId;
  }

  set originalSampleId(newSampleId: string | undefined) {
    if (this.#data.originalSampleId !== newSampleId) {
      this.#data.originalSampleId = newSampleId;

      this._onPropertyChanged.dispatch(this, "originalSampleId");
    }
  }

  get originalSampleId(): string | undefined {
    return this.#data.originalSampleId;
  }

  get originalGitHubOwner(): string | undefined {
    return this.#data.originalGitHubOwner;
  }

  set originalGitHubFolder(newGitHubFolder: string | undefined) {
    if (this.#data.originalGitHubFolder !== newGitHubFolder) {
      this.#data.originalGitHubFolder = newGitHubFolder;

      this._onPropertyChanged.dispatch(this, "originalGitHubFolder");
    }
  }

  get originalGitHubFolder(): string | undefined {
    return this.#data.originalGitHubFolder;
  }

  set originalGitHubRepoName(newGitHubRepoName: string | undefined) {
    if (this.#data.originalGitHubRepoName !== newGitHubRepoName) {
      this.#data.originalGitHubRepoName = newGitHubRepoName;

      this._onPropertyChanged.dispatch(this, "originalGitHubRepoName");
    }
  }

  get originalGitHubRepoName(): string | undefined {
    return this.#data.originalGitHubRepoName;
  }

  set originalGitHubBranch(newGitHubBranch: string | undefined) {
    if (this.#data.originalGitHubBranch !== newGitHubBranch) {
      this.#data.originalGitHubBranch = newGitHubBranch;

      this._onPropertyChanged.dispatch(this, "originalGitHubBranch");
    }
  }

  get originalGitHubBranch(): string | undefined {
    return this.#data.originalGitHubBranch;
  }

  set gitHubOwner(newGitHubOwner: string | undefined) {
    if (this.#data.gitHubOwner !== newGitHubOwner) {
      this.#data.gitHubOwner = newGitHubOwner;

      this._onPropertyChanged.dispatch(this, "gitHubOwner");
    }
  }

  get gitHubOwner(): string | undefined {
    return this.#data.gitHubOwner;
  }

  set gitHubFolder(newGitHubFolder: string | undefined) {
    if (this.#data.gitHubFolder !== newGitHubFolder) {
      this.#data.gitHubFolder = newGitHubFolder;

      this._onPropertyChanged.dispatch(this, "gitHubFolder");
    }
  }

  get gitHubFolder(): string | undefined {
    return this.#data.gitHubFolder;
  }

  set gitHubRepoName(newGitHubRepoName: string | undefined) {
    if (this.#data.gitHubRepoName !== newGitHubRepoName) {
      this.#data.gitHubRepoName = newGitHubRepoName;

      this._onPropertyChanged.dispatch(this, "gitHubRepoName");
    }
  }

  get gitHubRepoName(): string | undefined {
    return this.#data.gitHubRepoName;
  }

  set gitHubBranch(newGitHubBranch: string | undefined) {
    if (this.#data.gitHubBranch !== newGitHubBranch) {
      this.#data.gitHubBranch = newGitHubBranch;

      this._onPropertyChanged.dispatch(this, "gitHubBranch");
    }
  }

  get gitHubBranch(): string | undefined {
    return this.#data.gitHubBranch;
  }

  get description(): string {
    return this.#data.description;
  }

  set description(newDescription: string) {
    if (this.#data.description !== newDescription) {
      this.#data.description = newDescription;

      this._onPropertyChanged.dispatch(this, "description");
    }
  }

  public async applyDescription(newTitle: string) {
    this.title = newTitle;

    if (this.editPreference === ProjectEditPreference.summarized && this.defaultBehaviorPackUniqueId) {
      for (const projectItem of this.items) {
        if (projectItem.file && projectItem.itemType === ProjectItemType.behaviorPackManifestJson) {
          const manifestJson = await BehaviorManifestJson.ensureOnFile(projectItem.file);

          if (
            manifestJson &&
            manifestJson.definition &&
            Utilities.uuidEqual(manifestJson.definition.header.uuid, this.defaultBehaviorPackUniqueId)
          ) {
            const header = manifestJson.ensureHeader(this.title, this.description);

            header.name = newTitle;

            manifestJson.save();
          }
        }
      }
    }
  }

  get autoDeploymentMode(): ProjectAutoDeploymentMode {
    if (this.#data.autoDeploymentMode === undefined) {
      return 0;
    }

    return this.#data.autoDeploymentMode as ProjectAutoDeploymentMode;
  }

  set autoDeploymentMode(newMode: ProjectAutoDeploymentMode) {
    if (this.#data.autoDeploymentMode !== newMode) {
      this.#data.autoDeploymentMode = newMode;

      this._onPropertyChanged.dispatch(this, "autoDeploymentMode");
    }
  }

  get version(): number[] {
    let vmj = this.#data.versionMajor;
    if (vmj === undefined) {
      vmj = 0;
    }

    let vmi = this.#data.versionMinor;
    if (vmi === undefined) {
      vmi = 0;
    }

    let vmp = this.#data.versionPatch;
    if (vmp === undefined) {
      vmp = 0;
    }

    return [vmj, vmi, vmp];
  }

  get versionMajor(): number | undefined {
    return this.#data.versionMajor;
  }

  set versionMajor(newVersion: number | undefined) {
    if (this.#data.versionMajor !== newVersion) {
      this.#data.versionMajor = newVersion;

      this._onPropertyChanged.dispatch(this, "versionMajor");
    }
  }

  get versionMinor(): number | undefined {
    return this.#data.versionMinor;
  }

  set versionMinor(newVersion: number | undefined) {
    if (this.#data.versionMinor !== newVersion) {
      this.#data.versionMinor = newVersion;

      this._onPropertyChanged.dispatch(this, "versionMinor");
    }
  }

  get versionPatch(): number | undefined {
    return this.#data.versionPatch;
  }

  set versionPatch(newVersion: number | undefined) {
    if (this.#data.versionPatch !== newVersion) {
      this.#data.versionPatch = newVersion;

      this._onPropertyChanged.dispatch(this, "versionPatch");
    }
  }

  get defaultResourcePackUniqueId(): string {
    return this.#data.defaultResourcePackUniqueId;
  }

  set defaultResourcePackUniqueId(newId: string) {
    if (this.#data.defaultResourcePackUniqueId !== newId) {
      this.#data.defaultResourcePackUniqueId = newId;

      this._onPropertyChanged.dispatch(this, "defaultResourcePackUniqueId");
    }
  }

  get defaultBehaviorPackUniqueId(): string {
    return this.#data.defaultBehaviorPackUniqueId;
  }

  set defaultBehaviorPackUniqueId(newId: string) {
    if (this.#data.defaultBehaviorPackUniqueId !== newId) {
      this.#data.defaultBehaviorPackUniqueId = newId;

      this._onPropertyChanged.dispatch(this, "defaultBehaviorPackUniqueId");
    }
  }

  get defaultDataUniqueId(): string {
    return this.#data.defaultDataUniqueId;
  }

  set defaultDataUniqueId(newId: string) {
    if (this.#data.defaultDataUniqueId !== newId) {
      this.#data.defaultDataUniqueId = newId;

      this._onPropertyChanged.dispatch(this, "defaultDataUniqueId");
    }
  }

  async ensureScriptInDestination() {
    const bpScriptsFolder = await this.ensureBehaviorPackScriptsFolder();

    if (bpScriptsFolder === undefined) {
      return;
    }

    const coreScriptsFolderPath = StorageUtilities.canonicalizePath(bpScriptsFolder.storageRelativePath);

    for (const pi of this.#items) {
      if ((pi.itemType === ProjectItemType.testJs || pi.itemType === ProjectItemType.js) && pi.storagePath) {
        let spath = StorageUtilities.canonicalizePath(pi.storagePath);
        if (!spath.startsWith(coreScriptsFolderPath)) {
          const scriptsTokenIndex = spath.indexOf("/scripts/");
          if (scriptsTokenIndex >= 0) {
            spath = spath.substring(scriptsTokenIndex + 8);
          }

          await pi.load();

          if (pi.file && pi.file.content) {
            const item = this.ensureItemByStoragePath(
              StorageUtilities.ensureEndsWithDelimiter(coreScriptsFolderPath) +
                StorageUtilities.ensureNotStartsWithDelimiter(spath),
              ProjectItemStorageType.singleFile,
              StorageUtilities.getLeafName(spath),
              ProjectItemType.buildProcessedJs,
              false
            );

            const file = await item.ensureFileStorage();

            if (file) {
              file.setContent(pi.file.content);
            }
          }
        }
      }
    }
  }

  async hasScript() {
    for (const pi of this.#items) {
      if (
        pi.itemType === ProjectItemType.autoScriptJson ||
        pi.itemType === ProjectItemType.testJs ||
        pi.itemType === ProjectItemType.js ||
        pi.itemType === ProjectItemType.buildProcessedJs ||
        pi.itemType === ProjectItemType.ts
      ) {
        return true;
      }
    }

    const scriptsFolder = await this.getBehaviorPackScriptsFolder();
    if (!scriptsFolder) {
      return false;
    }

    await scriptsFolder.load(false);

    if (scriptsFolder.fileCount > 0 || scriptsFolder.folderCount > 0) {
      return true;
    }

    return false;
  }

  get projectCabinetFile() {
    return this.#projectCabinetFile;
  }

  get defaultScriptModuleUniqueId(): string {
    return this.#data.defaultScriptModuleUniqueId;
  }

  set defaultScriptModuleUniqueId(newId: string) {
    if (this.#data.defaultScriptModuleUniqueId !== newId) {
      this.#data.defaultScriptModuleUniqueId = newId;

      this._onPropertyChanged.dispatch(this, "defaultScriptModuleUniqueId");
    }
  }

  get focus(): ProjectFocus {
    return this.#data.focus;
  }

  set focus(newFocus: ProjectFocus) {
    if (this.#data.focus !== newFocus) {
      this.#data.focus = newFocus;

      this._onPropertyChanged.dispatch(this, "focus");
    }
  }

  constructor(carto: Carto, name: string, file: IFile | null) {
    this._handleDeployUpdated = this._handleDeployUpdated.bind(this);
    this._handleProjectFileContentsUpdated = this._handleProjectFileContentsUpdated.bind(this);
    this.applyUpdate = this.applyUpdate.bind(this);
    this.loadFromFile = this.loadFromFile.bind(this);
    this.ensureProjectFolder = this.ensureProjectFolder.bind(this);

    this.loc = new LocManager(this);

    this.#data = {
      dataType: ProjectDataType.clientStorage,
      storageBasePath: "",
      contentsModified: null,
      dataStorageRelativePath: "/" + name + "/",
      editPreference: ProjectEditPreference.summarized,
      name: name,
      title: name,
      description: name + " description",
      defaultBehaviorPackUniqueId: Utilities.createUuid(),
      defaultResourcePackUniqueId: Utilities.createUuid(),
      defaultScriptModuleUniqueId: Utilities.createUuid(),
      defaultDataUniqueId: Utilities.createUuid(),
      focus: ProjectFocus.general,
      items: [],
    };

    this.#file = file;

    this.#projectFolder = null;
    this.#defaultBehaviorPackFolder = null;
    this.#defaultWorldFolder = null;
    this.#defaultScriptsFolder = null;
    this.#behaviorPacksContainer = null;
    this.#docsContainer = null;
    this.#defaultResourcePackFolder = null;
    this.#resourcePacksContainer = null;
    this.#worldContainer = null;

    this.#carto = carto;
    this.#items = [];
  }

  notifyProjectItemChanged(item: ProjectItem) {
    this._onItemChanged.dispatch(this, item);
  }

  async inferProjectItemsFromFiles(force?: boolean) {
    if (!this._hasInferredFiles || force) {
      await this.ensureProjectFolder();

      if (this.#projectCabinetFile !== null) {
        const operId = await this.carto.notifyOperationStarted(
          "Loading project files for '" + this.name + "' from '" + this.#projectCabinetFile.fullPath + "'",
          StatusTopic.projectLoad
        );

        await this.ensureProjectFolderFromCabinet();
        /*await this._inferProjectItemsFromZipFile(
          this.#projectCabinetFile.storageRelativePath,
          this.#projectCabinetFile,
          false
        );*/

        if (this.#projectFolder) {
          await this._inferProjectItemsFromFolder(this.#projectFolder, "", FolderContext.unknown, 0, force);
        }

        await this.carto.notifyOperationEnded(
          operId,
          "Done loading project files for '" + this.name + "' from file '" + this.#projectCabinetFile.fullPath + "'",
          StatusTopic.projectLoad
        );

        this._hasInferredFiles = true;
      } else {
        await this.inferProjectItemsFromFilesRootFolder();
      }

      this.adjustVisibleDefaults();
    }
  }

  async inferProjectItemsFromFilesRootFolder(force?: boolean) {
    const rootFolder = await this.ensureProjectFolder();

    const operId = await this.carto.notifyOperationStarted(
      "Loading project files for '" + this.name + "' from folder '" + rootFolder.fullPath + "'",
      StatusTopic.projectLoad
    );

    await this._inferProjectItemsFromFolder(rootFolder, "", FolderContext.unknown, 0, force);

    await this.carto.notifyOperationEnded(
      operId,
      "Done loading project files for '" + this.name + "' from folder '" + rootFolder.fullPath + "'",
      StatusTopic.projectLoad
    );

    this._hasInferredFiles = true;
  }

  async updateAutogeneratedItems() {
    for (let i = 0; i < this.#items.length; i++) {
      const item = this.#items[i];

      if (item.isAutogenerated) {
        await item.updateAutogenerated();
      }

      await item.updateAutogeneratedSideFiles();
    }
  }

  async ensureWorldContainer() {
    if (!this.#worldContainer) {
      const pf = await this.ensureProjectFolder();

      if (pf) {
        await pf.load(false);

        if (pf.folders["worlds"]) {
          this.#worldContainer = pf.folders["worlds"];
        } else if (pf.folders["minecraftWorlds"]) {
          this.#worldContainer = pf.folders["minecraftWorlds"];
        } else {
          this.#worldContainer = pf;
        }
      }
    }

    return this.#worldContainer;
  }

  async ensureCatalogIndex() {
    if (!this.hasScript) {
      return;
    }
    const scriptsFolder = await this.ensureBehaviorPackScriptsFolder();

    if (!scriptsFolder) {
      return;
    }

    this.ensureItemByTag(
      "jsindex",
      "index.js",
      ProjectItemType.catalogIndexJs,
      StorageUtilities.ensureEndsWithDelimiter(scriptsFolder.storageRelativePath) + "index.js",
      ProjectItemStorageType.singleFile,
      true
    );
  }

  async ensureAutogeneratedManifest() {
    const bpFolder = await this.ensureDefaultBehaviorPackFolder();

    if (!bpFolder) {
      return;
    }

    this.ensureItemByTag(
      "manifestjson",
      "behaviorpackmanifest",
      ProjectItemType.behaviorPackManifestJson,
      StorageUtilities.ensureEndsWithDelimiter(bpFolder.storageRelativePath) + "manifest.json",
      ProjectItemStorageType.singleFile,
      true
    );
  }

  dispose() {
    if (this.#projectFolder) {
      this.#projectFolder.dispose();
      this.#projectFolder = null;
    }

    if (this.#projectCabinetFile) {
      this.#projectCabinetFile.dispose();
      this.#projectCabinetFile = null;
    }

    if (this.#buildFolder) {
      this.#buildFolder.dispose();
      this.#buildFolder = null;
    }

    if (this.#docsContainer) {
      this.#docsContainer.dispose();
      this.#docsContainer = null;
    }

    if (this.#worldContainer) {
      this.#worldContainer.dispose();
      this.#worldContainer = null;
    }

    if (this.#behaviorPacksContainer) {
      this.#behaviorPacksContainer.dispose();
      this.#behaviorPacksContainer = null;
    }

    if (this.#defaultBehaviorPackFolder) {
      this.#defaultBehaviorPackFolder.dispose();
      this.#defaultBehaviorPackFolder = null;
    }

    if (this.#defaultScriptsFolder) {
      this.#defaultScriptsFolder.dispose();
      this.#defaultScriptsFolder = null;
    }

    if (this.#resourcePacksContainer) {
      this.#resourcePacksContainer.dispose();
      this.#resourcePacksContainer = null;
    }

    if (this.#defaultResourcePackFolder) {
      this.#defaultResourcePackFolder.dispose();
      this.#defaultResourcePackFolder = null;
    }

    this.#isDisposed = true;
  }

  async _inferProjectItemsFromFolder(
    folder: IFolder,
    fileSystemPrefix: string,
    folderContext: FolderContext,
    depth: number,
    force?: boolean
  ) {
    if (this.projectFolder === null || (folder.name.startsWith(".") && !folder.name.startsWith(".vscode"))) {
      Log.debugAlert("Could not process folder: " + folder.storageRelativePath);
      return;
    }

    await folder.load(force ? force : false);

    let parentFolder = folder.parentFolder;

    if (parentFolder === this.projectFolder.parentFolder) {
      parentFolder = null;
    }

    const folderPathA = StorageUtilities.canonicalizePath(StorageUtilities.getPath(folder.storageRelativePath));

    if (
      folderPathA.indexOf("/checkpoint_input") >= 0 ||
      folderPathA.indexOf("/metadata") >= 0 ||
      folderPathA.indexOf("/type_definitions") >= 0 ||
      folderPathA.indexOf("/typedefs") >= 0
    ) {
      folderContext = FolderContext.typeDefs;
    } else if (folderPathA.indexOf("/.vscode") >= 0) {
      folderContext = FolderContext.vscodeFolder;
    } else if (folderPathA.indexOf("/behavior") >= 0 || folderPathA.indexOf("/bp") >= 0) {
      folderContext = FolderContext.behaviorPack;
    } else if (folderPathA.indexOf("/resource") >= 0 || folderPathA.indexOf("/rp") >= 0) {
      folderContext = FolderContext.resourcePack;
    } else if (folderPathA.indexOf("/subpacks") >= 0) {
      folderContext = FolderContext.resourcePackSubPack;
    } else if (folderPathA.indexOf("/skin") >= 0 && folderContext === FolderContext.unknown) {
      folderContext = FolderContext.skinPack;
    } else if (folderPathA.indexOf("/world") >= 0 && folderContext === FolderContext.unknown) {
      folderContext = FolderContext.worldOrWorldTemplate;
    } else if (folderPathA.indexOf("/docs") >= 0) {
      folderContext = FolderContext.docs;

      if (folderPathA === "/docs/") {
        this.#docsContainer = folder;
      }
    }

    if (
      folderContext === FolderContext.unknown &&
      (folder.files["manifest.json"] || folder.files["pack_manifest.json"]) &&
      !folder.files["level.dat"] &&
      !folder.files["levelname.txt"]
    ) {
      if (
        folder.folders["models"] ||
        folder.folders["textures"] ||
        folder.folders["lighting"] ||
        folder.folders["subpacks"] ||
        folder.folders["assets"] ||
        folder.folders["sounds"] ||
        folder.folders["texture_sets"] ||
        folder.folders["sounds"] ||
        folder.folders["ui"]
      ) {
        folderContext = FolderContext.resourcePack;
      } else {
        folderContext = FolderContext.behaviorPack;
      }
    }

    if (
      folder.files["world_behavior_packs.json"] ||
      folder.files["world_resource_packs.json"] ||
      folder.files["levelname.txt"]
    ) {
      if (folderContext === FolderContext.unknown) {
        folderContext = FolderContext.worldOrWorldTemplate;
      }

      if (folder.parentFolder && !this.#worldContainer) {
        this.#worldContainer = folder.parentFolder;
      }
    }

    for (const fileName in folder.files) {
      const canonFileName = StorageUtilities.canonicalizeName(fileName);
      // console.log("Considering " + canonFileName + " in folder " + folder.storageRelativePath);

      if (!canonFileName.startsWith(".") && canonFileName !== "gulpfile.js" && canonFileName !== "package-lock.json") {
        const candidateFile = folder.files[fileName];

        if (candidateFile !== undefined) {
          let pi = null;
          let projectPath = undefined;

          if (fileSystemPrefix.length > 0) {
            projectPath = fileSystemPrefix + candidateFile.fullPath;
            pi = this.getItemByStoragePath(projectPath);
          } else {
            const frPath = candidateFile.getFolderRelativePath(this.projectFolder);

            if (frPath !== undefined) {
              projectPath = StorageUtilities.canonicalizePath(frPath);

              pi = this.getItemByStoragePath(projectPath);
            }
          }

          if ((pi === undefined || pi === null) && projectPath !== undefined) {
            const fileExtension = candidateFile.type;
            const baseName = StorageUtilities.getBaseFromName(candidateFile.name);
            const folderPath = StorageUtilities.canonicalizePath(StorageUtilities.getPath(projectPath));

            if (canonFileName === "manifest.json" || canonFileName === "pack_manifest.json") {
              if (folderContext === FolderContext.resourcePack) {
                this.#defaultResourcePackFolder = folder;
                this.#resourcePacksContainer = parentFolder;
              } else if (folderContext === FolderContext.behaviorPack) {
                this.#defaultBehaviorPackFolder = folder;
                this.#behaviorPacksContainer = parentFolder;
              } else if (folderContext === FolderContext.worldOrWorldTemplate) {
                this.#defaultWorldFolder = folder;
                this.#worldContainer = parentFolder;
              }

              await candidateFile.loadContent(false);

              let isAutogenerated = false;

              if (
                candidateFile.content !== undefined &&
                candidateFile.content !== "" &&
                typeof candidateFile.content === "string"
              ) {
                if (candidateFile.content.indexOf(AUTOGENERATED_CONTENT_TOKEN) >= 0) {
                  isAutogenerated = true;
                }

                try {
                  const manifest: IAddonManifest = JSON.parse(candidateFile.content);

                  if (manifest.header.uuid !== undefined) {
                    if (folderContext === FolderContext.behaviorPack) {
                      this.defaultBehaviorPackUniqueId = manifest.header.uuid;
                    } else if (folderContext === FolderContext.resourcePack) {
                      this.defaultResourcePackUniqueId = manifest.header.uuid;
                    }
                  }

                  if (manifest.modules) {
                    for (let i = 0; i < manifest.modules.length; i++) {
                      const mod = manifest.modules[i];

                      if (mod.type === "script") {
                        this.defaultScriptModuleUniqueId = mod.uuid;
                      }
                    }
                  }

                  if (manifest.header.description !== undefined) {
                    this.description = manifest.header.description;
                  }

                  if (manifest.header.name !== undefined) {
                    this.title = manifest.header.name;
                  }

                  if (
                    manifest.header.version !== undefined &&
                    manifest.header.version.length === 3 &&
                    folderContext === FolderContext.behaviorPack
                  ) {
                    this.versionMajor = manifest.header.version[0];
                    this.versionMinor = manifest.header.version[1];
                    this.versionPatch = manifest.header.version[2];
                  }
                } catch (e) {}
              }

              let newPiType = ProjectItemType.unknown;
              let tag = "";

              if (folderContext === FolderContext.behaviorPack) {
                newPiType = ProjectItemType.behaviorPackManifestJson;
                tag = "behaviorpackmanifest";
              } else if (folderContext === FolderContext.resourcePack) {
                newPiType = ProjectItemType.resourcePackManifestJson;
                tag = "resourcepackmanifest";
              } else if (folderContext === FolderContext.skinPack) {
                newPiType = ProjectItemType.skinPackManifestJson;
                tag = "skinpackmanifest";
              } else if (folderContext === FolderContext.worldOrWorldTemplate) {
                newPiType = ProjectItemType.worldTemplateManifestJson;
                tag = "worldtemplatemanifest";
              }

              // Log.assert(newPiType !== ProjectItemType.unknown, "Unknown manifest.json file found.");

              this.ensureItemByTag(
                tag,
                "manifest",
                newPiType,
                projectPath,
                ProjectItemStorageType.singleFile,
                isAutogenerated,
                candidateFile
              );
            } else if (projectPath.endsWith("/scripts/index.js")) {
              await candidateFile.loadContent();

              let isAutogenerated = false;

              if (
                candidateFile.content === undefined ||
                candidateFile.content === "" ||
                (typeof candidateFile.content === "string" &&
                  candidateFile.content.indexOf(AUTOGENERATED_CONTENT_TOKEN) >= 0)
              ) {
                isAutogenerated = true;
              }

              this.ensureItemByTag(
                "jsindex",
                "index.js",
                ProjectItemType.catalogIndexJs,
                projectPath,
                ProjectItemStorageType.singleFile,
                isAutogenerated,
                candidateFile
              );
            } else if (projectPath.endsWith("tasks.json") && folderContext === FolderContext.vscodeFolder) {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.vsCodeTasksJson,
                false,
                candidateFile
              );
            } else if (projectPath.endsWith("launch.json") && folderContext === FolderContext.vscodeFolder) {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.vsCodeLaunchJson,
                false,
                candidateFile
              );
            } else if (projectPath.endsWith("settings.json") && folderContext === FolderContext.vscodeFolder) {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.vsCodeSettingsJson,
                false,
                candidateFile
              );
            } else if (projectPath.endsWith("extensions.json") && folderContext === FolderContext.vscodeFolder) {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.vsCodeExtensionsJson,
                false,
                candidateFile
              );
            } else if (projectPath.endsWith("/tick.json")) {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.tickJson,
                false,
                candidateFile
              );
            } else if (fileExtension === "mcstructure") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.structure,
                false,
                candidateFile
              );
            } else if (fileExtension === "mcfunction") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.MCFunction,
                false,
                candidateFile
              );
            } else if (fileExtension === "material") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.material,
                false,
                candidateFile
              );
            } else if (fileExtension === "vertex") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.vertex,
                false,
                candidateFile
              );
            } else if (fileExtension === "fragment") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.fragment,
                false,
                candidateFile
              );
            } else if (fileExtension === "geometry") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.geometry,
                false,
                candidateFile
              );
            } else if (
              canonFileName === "level.dat" &&
              fileSystemPrefix.indexOf(".mcworld") < 0 && // don't create a project item if we're inside of a mcworld/mctemplate since that broader item has a link already
              fileSystemPrefix.indexOf(".mctemplate") < 0 &&
              folderContext !== FolderContext.behaviorPack
            ) {
              this.ensureItemByStoragePath(
                folderPath,
                ProjectItemStorageType.folder,
                candidateFile.name,
                ProjectItemType.worldFolder,
                false,
                candidateFile
              );
            } else if (fileExtension === "js") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.js,
                false,
                candidateFile
              );
            } else if (fileExtension === "ts") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.ts,
                false,
                candidateFile
              );
            } else if (fileExtension === "mcworld") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.MCWorld,
                false,
                candidateFile
              );

              await this._inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            } else if (fileExtension === "mcproject") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.MCProject,
                false,
                candidateFile
              );

              await this._inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            } else if (fileExtension === "mctemplate") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.MCTemplate,
                false,
                candidateFile
              );

              await this._inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            } else if (fileExtension === "mcaddon") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.MCAddon,
                false,
                candidateFile
              );

              await this._inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            } else if (fileExtension === "mcpack") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.MCPack,
                false,
                candidateFile
              );

              await this._inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            } else if (fileExtension === "zip") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.zip,
                false,
                candidateFile
              );

              await this._inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            } else if (
              fileExtension === "png" ||
              fileExtension === "jpg" ||
              fileExtension === "gif" ||
              fileExtension === "jpeg" ||
              fileExtension === "tga"
            ) {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.image,
                false,
                candidateFile
              );
            } else if (fileExtension === "lang") {
              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                candidateFile.name,
                ProjectItemType.lang,
                false,
                candidateFile
              );
            } else if (fileExtension === "json") {
              let newJsonType = ProjectItemType.json;
              let itemName = candidateFile.name;

              if (folderContext === FolderContext.behaviorPack && folderPath.indexOf("/loot_tables/") >= 0) {
                newJsonType = ProjectItemType.lootTableBehaviorJson;
              } else if (folderContext === FolderContext.behaviorPack && folderPath.indexOf("/dialogue/") >= 0) {
                newJsonType = ProjectItemType.dialogueBehaviorJson;
              } else if (folderContext === FolderContext.behaviorPack && folderPath.indexOf("/recipes/") >= 0) {
                newJsonType = ProjectItemType.recipeBehaviorJson;
              } else if (folderContext === FolderContext.behaviorPack && folderPath.indexOf("/spawn_rules/") >= 0) {
                newJsonType = ProjectItemType.spawnRuleBehaviorJson;
              } else if (folderContext === FolderContext.behaviorPack && folderPath.indexOf("/cameras/") >= 0) {
                newJsonType = ProjectItemType.cameraJson;
              } else if (folderContext === FolderContext.behaviorPack && folderPath.indexOf("/trading/") >= 0) {
                newJsonType = ProjectItemType.tradingBehaviorJson;
              } else if (
                folderContext === FolderContext.behaviorPack &&
                folderPath.indexOf("/animation_controllers/") >= 0
              ) {
                newJsonType = ProjectItemType.animationControllerBehaviorJson;
              } else if (folderContext === FolderContext.behaviorPack && folderPath.indexOf("/animations/") >= 0) {
                newJsonType = ProjectItemType.animationBehaviorJson;
              } else if (
                folderContext === FolderContext.resourcePack &&
                (folderPath.indexOf("/models/") >= 0 || baseName.endsWith(".geo"))
              ) {
                newJsonType = ProjectItemType.modelJson;
              } else if (
                folderContext === FolderContext.resourcePack &&
                folderPath.indexOf("/animation_controllers/") >= 0
              ) {
                newJsonType = ProjectItemType.animationControllerResourceJson;
              } else if (folderContext === FolderContext.resourcePack && folderPath.indexOf("/animations/") >= 0) {
                newJsonType = ProjectItemType.animationResourceJson;
              } else if (folderContext === FolderContext.resourcePack && folderPath.indexOf("/attachables/") >= 0) {
                newJsonType = ProjectItemType.attachableResourceJson;
              } else if (
                folderContext === FolderContext.resourcePack &&
                (folderPath.indexOf("/entities/") >= 0 || folderPath.indexOf("/entity/") >= 0)
              ) {
                newJsonType = ProjectItemType.entityTypeResourceJson;
              } else if (folderContext === FolderContext.resourcePack && folderPath.indexOf("/fogs/") >= 0) {
                newJsonType = ProjectItemType.fogResourceJson;
              } else if (folderContext === FolderContext.resourcePack && folderPath.indexOf("/particles/") >= 0) {
                newJsonType = ProjectItemType.particleJson;
              } else if (
                folderContext === FolderContext.resourcePack &&
                folderPath.indexOf("/render_controllers/") >= 0
              ) {
                newJsonType = ProjectItemType.renderControllerJson;
              } else if (folderContext === FolderContext.resourcePack && folderPath.indexOf("/materials/") >= 0) {
                newJsonType = ProjectItemType.materialSetJson;
              } else if (folderContext === FolderContext.resourcePack && folderPath.indexOf("/sounds/") >= 0) {
                newJsonType = ProjectItemType.soundDefinitionJson;
              } else if (folderPath.indexOf("/texts/") >= 0 || baseName === "languages") {
                newJsonType = ProjectItemType.languagesCatalogResourceJson;
              } else if (
                (folderContext === FolderContext.resourcePack && folderPath.indexOf("/texture_sets/") >= 0) ||
                ((folderContext === FolderContext.resourcePack ||
                  folderContext === FolderContext.resourcePackSubPack) &&
                  folderPath.indexOf("/textures/") >= 0)
              ) {
                newJsonType = ProjectItemType.itemTextureJson;
              } else if (
                (folderContext === FolderContext.resourcePack || folderContext === FolderContext.resourcePackSubPack) &&
                folderPath.indexOf("/lighting/") >= 0
              ) {
                newJsonType = ProjectItemType.lightingJson;
              } else if (folderContext === FolderContext.resourcePack && folderPath.indexOf("/ui/") >= 0) {
                newJsonType = ProjectItemType.uiJson;
              } else if (folderContext === FolderContext.resourcePack && baseName === "biomes_client") {
                newJsonType = ProjectItemType.biomeResourceJson;
              } else if (
                (folderContext === FolderContext.resourcePack || folderContext === FolderContext.resourcePackSubPack) &&
                baseName === "blocks"
              ) {
                newJsonType = ProjectItemType.blockTypeResourceJson;
              } else if (
                (folderContext === FolderContext.resourcePack || folderContext === FolderContext.resourcePackSubPack) &&
                projectPath.endsWith("texture_set.json")
              ) {
                newJsonType = ProjectItemType.textureSetJson;
              } else if (folderContext === FolderContext.resourcePack && folderPath.indexOf("/items/") >= 0) {
                newJsonType = ProjectItemType.itemTypeResourceJson;
              } else if (folderContext === FolderContext.resourcePack && baseName === "sounds") {
                newJsonType = ProjectItemType.soundsCatalogResourceJson;
              } else if (baseName === "world_behavior_packs") {
                newJsonType = ProjectItemType.behaviorPackListJson;
              } else if (baseName === "world_resource_packs") {
                newJsonType = ProjectItemType.resourcePackListJson;
              } else if (baseName === "tsconfig") {
                newJsonType = ProjectItemType.tsconfigJson;
              } else if (baseName === "docfx") {
                newJsonType = ProjectItemType.docfxJson;
              } else if (baseName === "jsdoc") {
                newJsonType = ProjectItemType.jsdocJson;
              } else if (baseName === "jsconfig") {
                newJsonType = ProjectItemType.jsconfigJson;
              } else if (baseName === "package") {
                newJsonType = ProjectItemType.packageJson;
              } else if (baseName === "package.lock") {
                newJsonType = ProjectItemType.packageLockJson;
              } else if (
                folderContext === FolderContext.behaviorPack &&
                (folderPath.indexOf("/entities/") >= 0 || folderPath.indexOf("/entity/") >= 0)
              ) {
                newJsonType = ProjectItemType.entityTypeBehaviorJson;
              } else if (folderContext === FolderContext.behaviorPack && folderPath.indexOf("/items/") >= 0) {
                newJsonType = ProjectItemType.itemTypeBehaviorJson;
              } else if (folderContext === FolderContext.behaviorPack && folderPath.indexOf("/blocks/") >= 0) {
                newJsonType = ProjectItemType.blockTypeBehaviorJson;
              } else if (folderContext === FolderContext.docs && baseName === "info") {
                newJsonType = ProjectItemType.docInfoJson;
                this.#role = ProjectRole.documentation;

                itemName = StorageUtilities.getLeafName(folderPath);
              } else if (folderContext === FolderContext.typeDefs && folderPath.indexOf("/command") >= 0) {
                newJsonType = ProjectItemType.commandSetDefinitionJson;
                this.#role = ProjectRole.documentation;
              } else if (folderContext === FolderContext.typeDefs) {
                newJsonType = ProjectItemType.typesDefinitionJson;
                this.#role = ProjectRole.documentation;
              } else {
                // Log.debugAlert("General JSON file found: " + projectPath);
              }

              this.ensureItemByStoragePath(
                projectPath,
                ProjectItemStorageType.singleFile,
                itemName,
                newJsonType,
                false,
                candidateFile
              );
            }
          } else if (pi && projectPath !== undefined) {
            if (
              pi.itemType === ProjectItemType.MCWorld ||
              pi.itemType === ProjectItemType.MCProject ||
              pi.itemType === ProjectItemType.MCTemplate ||
              pi.itemType === ProjectItemType.MCAddon ||
              pi.itemType === ProjectItemType.MCPack ||
              pi.itemType === ProjectItemType.zip
            ) {
              await this._inferProjectItemsFromZipFile(projectPath, candidateFile, force);
            }
          }
        }
      }
    }

    for (const folderName in folder.folders) {
      const childFolder = folder.folders[folderName];

      if (childFolder && !childFolder.errorStatus) {
        const name = StorageUtilities.canonicalizeName(folderName);

        if (name === "build" || name === "out" || name === "dist") {
          this.#buildFolder = folder;
        } else if (
          name !== "node_modules" &&
          (name.startsWith(".vscode") || !name.startsWith(".")) &&
          name !== "test" &&
          (folderContext !== FolderContext.unknown || depth < 4) &&
          depth < 10
        ) {
          if (childFolder !== undefined) {
            await this._inferProjectItemsFromFolder(childFolder, fileSystemPrefix, folderContext, depth + 1, force);
          }
        }
      }
    }
  }

  async ensureProjectFolderFromCabinet() {
    if (!this.#projectCabinetFile) {
      Log.unexpectedUndefined("EPFFC");
      return;
    }

    await this.#projectCabinetFile.loadContent();

    const rootFolder = await StorageUtilities.getFileStorageFolder(this.#projectCabinetFile);

    if (rootFolder) {
      this.#projectFolder = rootFolder;
    } else {
      this.#projectFolder = null;
    }
  }

  async _inferProjectItemsFromZipFile(projectPath: string, file: IFile, force?: boolean) {
    let operId = await this.carto.notifyOperationStarted("Loading package  file " + file.name);
    await file.loadContent();

    const rootFolder = await StorageUtilities.getFileStorageFolder(file);

    if (rootFolder) {
      await this._inferProjectItemsFromFolder(rootFolder, projectPath + "#", FolderContext.unknown, 0, force);
    }

    this.adjustVisibleDefaults();

    await this.carto.notifyOperationEnded(operId, "Done loading package file " + file.name);
  }

  adjustVisibleDefaults() {
    if (this.#data.showAssets === undefined && this.items.length > 64) {
      this.showAssets = false;
    }

    if (this.#data.showFunctions === undefined && this.items.length > 64) {
      this.showFunctions = false;
    }
  }

  async stageChangesToGitHub() {
    if (this.gitHubOwner === undefined || this.gitHubRepoName === undefined) {
      Log.fail("Attempting to stage on a project without a GitHub connection");
      return;
    }

    const operId = await this.#carto.notifyOperationStarted("Staging changes for a GitHub commit");

    await this.#carto.userGitHub.ensureUserStateLoaded();

    if (this.#gitHubStorage === undefined) {
      this.#gitHubStorage = new GitHubStorage(
        this.#carto.userGitHub,
        this.gitHubRepoName,
        this.gitHubOwner,
        this.gitHubBranch,
        this.gitHubFolder
      );
    }

    const projectFolder = await this.ensureLoadedProjectFolder();

    this.differencesFromGitHub = await StorageUtilities.getDifferences(
      this.#gitHubStorage.rootFolder,
      projectFolder,
      false
    );
    await this.#carto.notifyOperationEnded(operId, "Done staging changes for a GitHub commit");
  }

  async commitToGitHub(commitMessage: string) {
    if (
      this.gitHubOwner === undefined ||
      this.gitHubRepoName === undefined ||
      this.differencesFromGitHub === undefined
    ) {
      Log.fail("Invalid configuration for committing to GitHub");
      return;
    }

    const operId = await this.#carto.notifyOperationStarted(
      "Committing " + this.differencesFromGitHub.fileDifferences.length + " file changes to GitHub"
    );
    this.#carto.userGitHub.commitToRepo(
      this.gitHubOwner,
      this.gitHubRepoName,
      this.gitHubBranch,
      this.gitHubFolder,
      commitMessage,
      this.differencesFromGitHub
    );
    await this.#carto.notifyOperationEnded(
      operId,
      "Done committing " + this.differencesFromGitHub.fileDifferences.length + " file changes to GitHub"
    );
  }

  async convertToBedrock() {
    if (this.projectFolder === null) {
      return;
    }

    const structuresFolder = this.projectFolder.folders["structures"];

    if (structuresFolder !== undefined) {
      for (const fileName in structuresFolder.files) {
        if (StorageUtilities.getTypeFromName(fileName) === "snbt") {
          const targetFileName = StorageUtilities.getBaseFromName(fileName) + ".mcstructure";

          const operId = await this.#carto.notifyOperationStarted(
            "Converting file '" + fileName + "' to '" + targetFileName + "'"
          );

          const sourceFile = structuresFolder.files[fileName];

          if (sourceFile !== undefined) {
            await sourceFile.loadContent();

            if (typeof sourceFile.content === "string") {
              const targetFile = structuresFolder.ensureFile(targetFileName);

              const folderRelativePath = targetFile.getFolderRelativePath(this.projectFolder);

              if (folderRelativePath !== undefined) {
                this.ensureItemByStoragePath(
                  folderRelativePath,
                  ProjectItemStorageType.singleFile,
                  targetFileName,
                  ProjectItemType.structure,
                  false
                );

                const mcs = new Structure();

                mcs.loadFromSnbtText(sourceFile.content);

                if (mcs.cube !== undefined) {
                  Converter.cubeEnsureBedrockProperties(mcs.cube);
                }
              }
            }
          }

          await this.#carto.notifyOperationEnded(operId, "Conversion complete.");
        }
      }
    }
  }

  async ensureDefaultItems() {
    if (this.focus === ProjectFocus.gameTests && this.projectFolder !== null) {
      const bpFolder = await this.ensureDefaultBehaviorPackFolder();

      const defaultPath = bpFolder.getFolderRelativePath(this.projectFolder);

      let pi = this.ensureItemByTag(
        "gametestjs",
        "Test",
        ProjectItemType.testJs,
        defaultPath + "scripts/test.js",
        ProjectItemStorageType.singleFile
      );

      let file = await pi.ensureFileStorage();

      if (file !== null) {
        let content = "";
        if (this.preferredScriptLanguage === ProjectScriptLanguage.typeScript) {
          content = ProjectContent.getDefaultTestTypeScript(this.name, StorageUtilities.getBaseFromName("test"));
        } else {
          content = ProjectContent.getDefaultTestJavaScript(this.name, StorageUtilities.getBaseFromName("test"));
        }

        file.setContent(content);
      }

      await this.ensureJsIndexFile();

      pi = this.ensureItemByTag(
        "manifestjson",
        "manifest",
        ProjectItemType.behaviorPackManifestJson,
        defaultPath + "manifest.json",
        ProjectItemStorageType.singleFile,
        true
      );

      pi = this.ensureItemByTag(
        "gameteststructure",
        "Basic",
        ProjectItemType.structure,
        defaultPath + "structures/gametests/basic.mcstructure",
        ProjectItemStorageType.singleFile
      );

      file = await pi.ensureFileStorage();

      if (file !== null) {
        const result = ProjectContent.generateDefaultStructure();

        if (result !== undefined) {
          file.setContent(result);
        }
      }
    }
  }

  async ensureJsIndexFile() {
    if (this.projectFolder === null) {
      throw new Error("Could not find project folder");
    }

    const bpFolder = await this.ensureDefaultBehaviorPackFolder();

    const defaultPath = bpFolder.getFolderRelativePath(this.projectFolder);

    this.ensureItemByTag(
      "jsindex",
      "index.js",
      ProjectItemType.catalogIndexJs,
      defaultPath + "scripts/index.js",
      ProjectItemStorageType.singleFile,
      true
    );
  }

  async applyUpdate(updaterId: string, updaterIndex: number): Promise<ProjectUpdateResult[]> {
    const pur = new ProjectUpdateRunner(this);

    return await pur.update(updaterId, updaterIndex);
  }

  getScriptState() {
    const state: IProjectScriptState = {
      hasScript: false,
      hasModule: {},
    };

    for (let i = 0; i < this.#items.length; i++) {
      const pi = this.#items[i];

      if (
        pi.itemType === ProjectItemType.js ||
        pi.itemType === ProjectItemType.buildProcessedJs ||
        pi.itemType === ProjectItemType.testJs ||
        pi.itemType === ProjectItemType.ts ||
        pi.itemType === ProjectItemType.worldTest
      ) {
        state.hasScript = true;

        if (
          (pi.itemType === ProjectItemType.js ||
            pi.itemType === ProjectItemType.buildProcessedJs ||
            pi.itemType === ProjectItemType.testJs ||
            pi.itemType === ProjectItemType.ts) &&
          pi.file
        ) {
          const content = pi.file.content;

          if (content && typeof content === "string") {
            for (let i = 0; i < minecraftScriptModules.length; i++) {
              const mod = minecraftScriptModules[i];

              if (content.indexOf(mod.id) >= 0) {
                state.hasModule[mod.id] = true;
              }
            }
          }
        }
      }
    }

    return state;
  }

  getFirstItemByType(itemType: ProjectItemType) {
    for (let i = 0; i < this.#items.length; i++) {
      const pi = this.#items[i];

      if (pi.itemType === itemType) {
        return pi;
      }
    }

    return undefined;
  }

  hasAddonJson() {
    return false;
  }

  public async loadFolderStructure() {
    Log.assert(!this.#isDisposed);

    const projectFolder = await this.ensureProjectFolder();

    await this.processProjectFolder(projectFolder);
  }

  public async processProjectFolder(folder: IFolder) {
    await folder.load(false);

    let manifest = folder.files["manifest.json"];

    if (manifest === undefined) {
      manifest = folder.files["pack_manifest.json"];
    }

    if (!this.#projectFolder) {
      throw new Error("Unexpectedly could not find a project folder.");
    }

    if (manifest) {
      let parentFolder = folder.parentFolder;

      if (parentFolder === this.#projectFolder.parentFolder) {
        parentFolder = null;
      }

      let isResource = false;
      let isWorld = false;

      if (parentFolder !== null) {
        const name = StorageUtilities.canonicalizeName(parentFolder.name);

        if (name.indexOf("resource") >= 0) {
          isResource = true;
        }
      }

      const levelDat = folder.files["level.dat"];

      if (levelDat) {
        isWorld = true;
      }

      if (isWorld && this.defaultWorldFolder === null) {
        this.#defaultWorldFolder = folder;

        if (parentFolder !== null) {
          this.#worldContainer = parentFolder;
        }
      } else if (!isWorld && isResource && this.#defaultResourcePackFolder === null) {
        this.#defaultResourcePackFolder = folder;

        if (parentFolder !== null) {
          this.#resourcePacksContainer = parentFolder;
        }
      } else if (!isWorld && this.#defaultBehaviorPackFolder === null) {
        this.#defaultBehaviorPackFolder = folder;

        if (parentFolder !== null) {
          this.#behaviorPacksContainer = parentFolder;
        }
      }
    } else {
      for (const folderName in folder.folders) {
        const childFolder = folder.folders[folderName];

        if (childFolder !== undefined && !childFolder.errorStatus) {
          await this.processProjectFolder(childFolder);
        }
      }
    }
  }

  public getItemByStoragePath(storagePath: string): ProjectItem | undefined {
    return this.#itemsByStoragePath[ProjectUtilities.canonicalizeStoragePath(storagePath)];
  }

  public getItemByExtendedOrStoragePath(storagePath: string): ProjectItem | undefined {
    let path = ProjectUtilities.canonicalizeStoragePath(storagePath);
    let result = this.#itemsByStoragePath[path];

    if (result) {
      return result;
    }

    let nextSlash = path.indexOf("/", 1);

    if (nextSlash > 1) {
      return this.#itemsByStoragePath[path.substring(nextSlash)];
    }

    return undefined;
  }

  public ensureItemByStoragePath(
    storagePath: string,
    storageType: ProjectItemStorageType,
    name: string,
    itemType: ProjectItemType,
    isAutogenerated?: boolean,
    file?: IFile
  ) {
    let pi = this.getItemByStoragePath(storagePath);

    if (pi !== undefined) {
      if (!pi.file && file) {
        pi.setFile(file);
      }

      return pi;
    }

    pi = this.createItem({
      itemType: itemType,
      storagePath: storagePath,
      storageType: storageType,
      isAutogenerated: isAutogenerated,
      tags: [],
      name: name,
    });

    if (file) {
      pi.setFile(file);
    }

    if (pi.itemType === ProjectItemType.json && itemType !== ProjectItemType.json) {
      pi.itemType = itemType;
    }

    return pi;
  }

  public getItemByTag(tag: string): ProjectItem | null {
    for (let i = 0; i < this.#items.length; i++) {
      const projectItem = this.#items[i];

      if (projectItem.hasTag(tag)) {
        return projectItem;
      }
    }

    return null;
  }

  public ensureItemByTag(
    tag: string,
    name: string,
    itemType: ProjectItemType,
    storagePath?: string,
    storageType?: ProjectItemStorageType,
    isAutogenerated?: boolean,
    file?: IFile
  ) {
    let pi = this.getItemByTag(tag);

    if (pi != null) {
      return pi;
    }

    pi = this.createItem({
      itemType: itemType,
      storagePath: storagePath,
      storageType: storageType,
      isAutogenerated: isAutogenerated,
      tags: [tag],
      name: name,
    });

    if (file) {
      pi.setFile(file);
    }

    return pi;
  }

  createItem(initialSettings: IProjectItemData) {
    this.#data.items.push(initialSettings);

    const pi = new ProjectItem(this, initialSettings);

    this.#itemsByStoragePath[ProjectUtilities.canonicalizeStoragePath(pi.storagePath)] = pi;
    this.#items.push(pi);

    this._onItemAdded.dispatch(this, pi);

    return pi;
  }

  async loadFromFile() {
    Log.assert(!this.#isDisposed);

    if (this.#isLoaded) {
      return;
    }

    if (this.#file === null) {
      return;
    }

    await this.#file.loadContent(false);

    this.#items = [];

    if (Utilities.isString(this.#file.content) && this.#file.content != null) {
      this.#data = JSON.parse(this.#file.content as string);

      await this.ensureProjectFolder(true);

      for (let i = 0; i < this.#data.items.length; i++) {
        const projectItemData = this.#data.items[i];

        const projectItem = new ProjectItem(this, projectItemData);
        this.#itemsByStoragePath[ProjectUtilities.canonicalizeStoragePath(projectItem.storagePath)] = projectItem;
        this.#items.push(projectItem);

        this._onItemAdded.dispatch(this, projectItem);
      }
    } else {
      await this.ensureProjectFolder();
    }

    this._hasInferredFiles = false;

    this._onLoaded.dispatch(this, this);

    this.initializeWorldSettings();
    this.ensureDefaultWorldName();

    this.#isLoaded = true;
  }

  async deleteThisProject() {
    if (this.#file) {
      await this.#file.deleteThisFile();
    }

    await this.loadFolderStructure();

    if (this.projectFolder) {
      await this.#projectFolder?.deleteThisFolder();
    }
  }

  async saveToFile() {
    Log.assert(!this.#isDisposed);

    if (this.#file === null) {
      return;
    }

    const jsonString = JSON.stringify(this.#data, null, 2);

    this.#file.setContent(jsonString);

    await this.#file.saveContent();
  }

  private _handleDeployUpdated(message: string) {
    this.#carto.notifyStatusUpdate(message);
  }

  async save(force?: boolean) {
    Log.assert(!this.#isDisposed);

    await this.ensureProjectFolder();

    // save all things inside of file containers first
    for (let i = 0; i < this.#items.length; i++) {
      const projectItem = this.#items[i];

      if ((projectItem.needsSave || force) && projectItem.isInFileContainer) {
        await projectItem.prepareToSave();

        this.updateContentsModified();

        await this.#items[i].saveContent();
      }
    }

    // save non container files
    for (let i = 0; i < this.#items.length; i++) {
      const projectItem = this.#items[i];

      if ((projectItem.needsSave || force) && !projectItem.isInFileContainer) {
        await projectItem.prepareToSave();

        this.updateContentsModified();

        await this.#items[i].saveContent();
      }
    }

    await this.saveToFile();

    this.changedFilesSinceLastSaved = {};

    if (this.projectFolder) {
      // we should have saved everything with individual project saves, but we should also allow folders to save their state.
      await this.projectFolder.saveAll();
    }

    if (
      this.autoDeploymentMode === ProjectAutoDeploymentMode.deployOnSave &&
      this.#carto.deploymentStorage !== null &&
      this.#carto.deployBehaviorPacksFolder !== null &&
      this.#carto.activeMinecraft
    ) {
      await this.#carto.activeMinecraft.deploy();
    }

    this._onSaved.dispatch(this, this);
  }

  async autoCompleteProject() {
    await this.ensureScriptInDestination();
    await this.ensureCatalogIndex();
    await this.ensureAutogeneratedManifest();
  }

  setProjectFolder(newFolder: IFolder) {
    if (this.#projectFolder !== newFolder) {
      if (this.#projectFolder) {
        this.#projectFolder.storage.onFileContentsUpdated.unsubscribe(this._handleProjectFileContentsUpdated);
      }

      this.#projectFolder = newFolder;
    }

    this.#isProjectFolderEnsured = true;
  }

  async ensureProjectFolder(force?: boolean): Promise<IFolder> {
    if (!force && this.#projectFolder !== null && this.#isProjectFolderEnsured) {
      return this.#projectFolder;
    }

    if (
      this.#data.localFolderPath !== undefined &&
      this.#carto.ensureLocalFolder !== undefined &&
      this.#carto.localFolderExists !== undefined
    ) {
      const folderExists = await this.#carto.localFolderExists(this.#data.localFolderPath);

      if (folderExists) {
        this.#projectFolder = this.#carto.ensureLocalFolder(this.#data.localFolderPath);
      } else {
        this.#projectFolder = await this.#carto.projectsStorage.rootFolder.ensureFolder(
          ProjectUtilities.canonicalizeStoragePath(this.#data.name)
        );

        Log.debug(
          "Using project storage root folder as a backup because local folder path could not be found: " +
            this.#projectFolder.fullPath
        );

        this.#errorState = ProjectErrorState.projectFolderOrFileDoesNotExist;
      }
    } else if (
      this.#data.localFilePath !== undefined &&
      this.#carto.ensureLocalFolder !== undefined &&
      this.#carto.localFileExists !== undefined &&
      this.#carto.localFolderExists !== undefined
    ) {
      const folderPath = StorageUtilities.getParentFolderFromPath(this.#data.localFilePath);
      const fileName = StorageUtilities.getLeafName(this.#data.localFilePath);

      if (!fileName || fileName.length < 2 || !folderPath || folderPath.length < 2) {
        throw new Error("Could not process file with path: `" + this.#data.localFilePath + "`");
      }

      const containingFolder = this.#carto.ensureLocalFolder(folderPath);

      const file = containingFolder.ensureFile(fileName);

      const fileExists = await file.exists();

      if (fileExists) {
        this.#projectCabinetFile = file;

        await this.ensureProjectFolderFromCabinet();

        Log.assert(
          this.#projectFolder !== undefined,
          "Could not create a project folder from " + this.#data.localFilePath
        );

        if (this.#accessoryFiles && this.#projectFolder) {
          for (let i = 0; i < this.#accessoryFiles.length; i++) {
            const addFile = containingFolder.ensureFile(this.#accessoryFiles[i]);

            const additionalFileExists = await addFile.exists();
            if (additionalFileExists) {
              let isChildOfExistingFolder = false;

              if (this.#accessoryFolders === null) {
                this.#accessoryFolders = [];
              }

              for (let j = 0; j < this.#accessoryFolders.length; j++) {
                let addFileStoragePath = addFile.getFolderRelativePath(this.#accessoryFolders[j]);

                if (addFileStoragePath) {
                  isChildOfExistingFolder = true;
                  this._inferProjectItemFromFile(addFile, this.#accessoryFolders[j], addFileStoragePath);
                }
              }

              if (!isChildOfExistingFolder) {
                if (addFile.parentFolder) {
                  let addFileStoragePath = addFile.getFolderRelativePath(addFile.parentFolder);
                  if (addFileStoragePath) {
                    this.#accessoryFolders.push(addFile.parentFolder);
                    this._inferProjectItemFromFile(addFile, addFile.parentFolder, addFileStoragePath);
                  }
                }
              }
            }
          }
        }
      }

      if (!this.#projectFolder) {
        this.#projectFolder = await this.#carto.projectsStorage.rootFolder.ensureFolder(
          ProjectUtilities.canonicalizeStoragePath(this.#data.name)
        );
        // Log.debug("Using project storage root folder as a backup: " + this.#projectFolder.fullPath);
        this.#errorState = ProjectErrorState.projectFolderOrFileDoesNotExist;
      }
    } else if (this.#useProjectNameInProjectStorage) {
      this.#projectFolder = await this.#carto.projectsStorage.rootFolder.ensureFolder(this.name);
      // Log.debug("Using project storage root folder root: " + this.#projectFolder.fullPath);
    } else {
      // Log.debug("Using project storage root folder subfolder: " + this.#data.dataStorageRelativePath);

      this.#projectFolder = await this.#carto.projectsStorage.ensureFolderFromStorageRelativePath(
        this.#data.dataStorageRelativePath
      );
    }

    const result = await this.#projectFolder.ensureExists();

    this.#projectFolder.storage.onFileContentsUpdated.subscribe(this._handleProjectFileContentsUpdated);

    this.#isProjectFolderEnsured = result;

    return this.#projectFolder;
  }

  async _inferProjectItemFromFile(file: IFile, folder: IFolder, fileStoragePath: string) {
    this.ensureItemByStoragePath(
      fileStoragePath,
      ProjectItemStorageType.singleFile,
      file.name,
      ProjectItemType.projectSummaryMetadata,
      false,
      file
    );
  }

  async _handleProjectFileContentsUpdated(storage: IStorage, file: IFile) {
    if (!this.#projectFolder) {
      return;
    }

    let rootRelativePath = file.storageRelativePath;

    if (
      this.#projectFolder.storageRelativePath.length > 0 &&
      rootRelativePath.startsWith(this.#projectFolder.storageRelativePath)
    ) {
      rootRelativePath = rootRelativePath.substring(this.#projectFolder.storageRelativePath.length - 1);
    }

    const storagePath = ProjectUtilities.canonicalizeStoragePath(rootRelativePath);

    if (!this.changedFilesSinceLastSaved[storagePath]) {
      this.changedFilesSinceLastSaved[storagePath] = file;

      this._onNeedsSaveChanged.dispatch(this, this);
    }

    const item = this.#itemsByStoragePath[storagePath];
    if (item) {
      this.notifyProjectItemChanged(item);
    }
  }

  async ensureBuildFolder(): Promise<IFolder> {
    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.#buildFolder === null) {
      this.#buildFolder = this.#projectFolder.ensureFolder("dist");
      this.#buildFolder.ensureExists();
    }

    return this.#buildFolder;
  }

  async ensureDocsFolder(): Promise<IFolder> {
    if (this.#docsContainer !== null) {
      return this.#docsContainer;
    }

    const rootFolder = await this.ensureProjectFolder();

    this.#docsContainer = rootFolder.ensureFolder("docs");

    return this.#docsContainer;
  }

  async ensureScriptsFolder(): Promise<IFolder> {
    if (this.#defaultScriptsFolder !== null) {
      return this.#defaultScriptsFolder;
    }

    for (let i = 0; i < this.items.length; i++) {
      const pi = this.items[i];

      if (pi.itemType === ProjectItemType.js || pi.itemType === ProjectItemType.ts) {
        await pi.ensureFileStorage();

        if (pi.file) {
          this.#defaultScriptsFolder = pi.file.parentFolder;

          if (this.#defaultScriptsFolder !== null) {
            return this.#defaultScriptsFolder;
          }
        }
      }
    }

    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.#defaultScriptsFolder !== null) {
      return this.#defaultScriptsFolder;
    }

    if (this.#defaultScriptsFolder === null) {
      await this.#projectFolder.load(false);

      const rootScriptsFolder = await this.#projectFolder.folders["scripts"];

      if (rootScriptsFolder) {
        const rootScriptsFolderExists = await rootScriptsFolder.exists();

        if (rootScriptsFolderExists) {
          this.#defaultScriptsFolder = rootScriptsFolder;
          return this.#defaultScriptsFolder;
        }
      }
    }

    const defaultBehaviorPackFolder = await this.ensureDefaultBehaviorPackFolder();

    if (!defaultBehaviorPackFolder) {
      return this.#projectFolder.ensureFolder("scripts");
    }

    const defaultBehaviorPackScriptsFolder = await defaultBehaviorPackFolder.ensureFolder("scripts");

    await defaultBehaviorPackScriptsFolder.ensureExists();

    this.#defaultScriptsFolder = defaultBehaviorPackScriptsFolder;

    return this.#defaultScriptsFolder;
  }

  async getDefaultBehaviorPackFolder(force?: boolean): Promise<IFolder | null> {
    if (this.#defaultBehaviorPackFolder !== null && !force) {
      return this.#defaultBehaviorPackFolder;
    }

    if (force) {
      this.#defaultBehaviorPackFolder = null;
    }

    for (let i = 0; i < this.items.length; i++) {
      const pi = this.items[i];

      if (pi.itemType === ProjectItemType.behaviorPackManifestJson) {
        await pi.ensureFileStorage();

        if (pi.file) {
          this.#defaultBehaviorPackFolder = pi.file.parentFolder;

          if (this.#defaultBehaviorPackFolder !== null) {
            return this.#defaultBehaviorPackFolder;
          }
        }
      }
    }

    await this.loadFolderStructure();

    return this.#defaultBehaviorPackFolder;
  }

  async ensureDefaultBehaviorPackFolder(force?: boolean): Promise<IFolder> {
    if (this.#defaultBehaviorPackFolder !== null && !force) {
      return this.#defaultBehaviorPackFolder;
    }

    await this.getDefaultBehaviorPackFolder(force);

    if (this.#defaultBehaviorPackFolder !== null) {
      return this.#defaultBehaviorPackFolder;
    }

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.#behaviorPacksContainer === null) {
      this.#behaviorPacksContainer = this.#projectFolder.ensureFolder("behavior_packs");
      await this.#behaviorPacksContainer.ensureExists();
    }

    this.#defaultBehaviorPackFolder = this.#behaviorPacksContainer.ensureFolder(
      MinecraftUtilities.makeNameFolderSafe(this.effectiveShortName + "_bp")
    );

    await this.#defaultBehaviorPackFolder.ensureExists();

    return this.#defaultBehaviorPackFolder;
  }

  async getDefaultResourcePackFolder(force?: boolean): Promise<IFolder | undefined> {
    if (this.#defaultResourcePackFolder !== null && !force) {
      return this.#defaultResourcePackFolder;
    }

    if (force) {
      this.#defaultResourcePackFolder = null;
    }

    for (let i = 0; i < this.items.length; i++) {
      const pi = this.items[i];

      if (pi.itemType === ProjectItemType.resourcePackManifestJson) {
        await pi.ensureFileStorage();

        if (pi.file) {
          this.#defaultResourcePackFolder = pi.file.parentFolder;

          if (this.#defaultResourcePackFolder !== null) {
            return this.#defaultResourcePackFolder;
          }
        }
      }
    }

    return undefined;
  }
  async ensureDefaultResourcePackFolder(force?: boolean): Promise<IFolder> {
    if (this.#defaultResourcePackFolder !== null && !force) {
      return this.#defaultResourcePackFolder;
    }

    if (force) {
      this.#defaultResourcePackFolder = null;
    }

    await this.getDefaultResourcePackFolder(force);

    if (this.#defaultResourcePackFolder !== null) {
      return this.#defaultResourcePackFolder;
    }

    await this.loadFolderStructure();

    if (this.#projectFolder === undefined || this.#projectFolder === null) {
      throw new Error("Unexpectedly could not create project folder");
    }

    if (this.#defaultResourcePackFolder !== null) {
      return this.#defaultResourcePackFolder;
    }

    if (this.#resourcePacksContainer === null) {
      this.#resourcePacksContainer = this.#projectFolder.ensureFolder("resource_packs");
      await this.#resourcePacksContainer.ensureExists();
    }

    this.#defaultResourcePackFolder = this.#resourcePacksContainer.ensureFolder(
      MinecraftUtilities.makeNameFolderSafe(this.effectiveShortName + "_rp")
    );

    await this.#defaultResourcePackFolder.ensureExists();

    return this.#defaultResourcePackFolder;
  }

  async ensureLoadedProjectFolder(force?: boolean): Promise<IFolder> {
    const projectFolder = await this.ensureProjectFolder();

    await projectFolder.load(force ? force : false);

    await this.save();

    return projectFolder;
  }
}
