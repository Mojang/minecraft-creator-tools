import Action from "../actions/Action";
import ActionGroup from "../actions/ActionGroup";
import ActionSet from "../actions/ActionSet";
import { ActionContextType } from "../actions/IAction";
import IScriptGenerationContext, { ScriptGenerationPlacement } from "../actions/IScriptGenerationContext";
import IScriptRequirements from "../actions/IScriptRequirements";
import Utilities from "../core/Utilities";

export const AUTOGENERATED_WHOLEFILE_SCRIPT_SEPARATOR =
  "// ===== AUTOGENERATED FILE ===== CONTENT WITHIN THIS FILE WILL BE WIPED AND UPDATED WHEN USED IN TOOLING";

export interface IScriptGenerationOptions {
  typeScript: boolean;
  isFunction?: boolean;
  addTestIdlePause?: boolean;
  useGameTestApis?: boolean;
}

export default class ActionSetScriptGenerator {
  static generateScript(actionSet: ActionSet, options?: IScriptGenerationOptions): string {
    const lines: string[] = [];

    if (!options) {
      options = {
        typeScript: true,
      };
    }

    this.addScriptLines(lines, actionSet, options);

    return lines.join("\n");
  }

  static generateGameTestJavaScript(
    actionSet: ActionSet,
    groupName: string,
    nameSuffix: string,
    structureName: string
  ) {
    const lines: string[] = [];

    let name = actionSet.name;

    if (nameSuffix) {
      name += nameSuffix;
    }

    name = Utilities.getSimpleString(name);
    groupName = Utilities.getSimpleString(groupName);

    lines.push("async function gt_" + name + "(test) {");
    this.addScriptGroupLines(
      lines,
      actionSet,
      {
        isFunction: true,
        addTestIdlePause: true,
        useGameTestApis: true,
        typeScript: false,
      },
      { indent: 2 },
      ScriptGenerationPlacement.inSequence
    );
    lines.push("}");
    lines.push(
      'registerAsync("' +
        groupName +
        '", "' +
        name +
        '", gt_' +
        name +
        ').maxTicks(4000).structureName("gametest:' +
        structureName +
        'empty");'
    );

    return lines.join("\r\n");
  }

  static addScriptGroupLinesForFunction(
    lines: string[],
    actionGroup: ActionGroup,
    options: IScriptGenerationOptions,
    context: IScriptGenerationContext
  ) {
    this.addScriptGroupLines(lines, actionGroup, options, { indent: 2 }, ScriptGenerationPlacement.beforeBlockStart);
    if (actionGroup.groupAction) {
      actionGroup.groupAction.addScriptLines(lines, options, { indent: 2 }, ScriptGenerationPlacement.blockStart);
    } else {
      let functionLine = "export function " + actionGroup.name + "(";
      let args = "";

      if (actionGroup.expectedContext === ActionContextType.dimensionLocation) {
        args += "location: mc.DimensionLocation";
      }

      functionLine += args + ") {";

      options.isFunction = true;

      lines.push(functionLine);
    }
    this.addScriptGroupLines(lines, actionGroup, options, { indent: 2 }, ScriptGenerationPlacement.afterBlockStart);
    this.addScriptGroupLines(lines, actionGroup, options, { indent: 2 }, ScriptGenerationPlacement.inSequence);
    this.addScriptGroupLines(lines, actionGroup, options, { indent: 2 }, ScriptGenerationPlacement.beforeBlockEnd);
    if (actionGroup.groupAction) {
      actionGroup.groupAction.addScriptLines(lines, options, { indent: 2 }, ScriptGenerationPlacement.blockEnd);
    } else {
      lines.push("}");
    }
    this.addScriptGroupLines(lines, actionGroup, options, { indent: 2 }, ScriptGenerationPlacement.afterBlockEnd);
  }

  static addInitGroupLines(
    lines: string[],
    actionSet: ActionSet,
    options: IScriptGenerationOptions,
    context: IScriptGenerationContext
  ) {
    lines.push("export function init() {");

    this.addScriptGroupLines(lines, actionSet, options, { indent: 2 }, ScriptGenerationPlacement.initInSequence);

    lines.push("}");
  }

  static addScriptGroupLines(
    lines: string[],
    actionGroup: ActionGroup,
    scriptGenOptions: IScriptGenerationOptions,
    context: IScriptGenerationContext,
    placement: ScriptGenerationPlacement
  ) {
    const req: IScriptRequirements = {};

    for (const action of actionGroup.actions) {
      if (action instanceof Action) {
        ActionGroup.mergeScriptRequirements(req, action.getScriptRequirements(scriptGenOptions));
      }
    }

    if (req.needsLocalOverworld && placement === ScriptGenerationPlacement.inSequence) {
      ActionGroup.addLine(lines, context.indent, 'const overworld = mc.world.getDimension("overworld");');
    }

    if (
      actionGroup.groupAction &&
      (placement === ScriptGenerationPlacement.initInSequence || placement === ScriptGenerationPlacement.inSequence)
    ) {
      actionGroup.groupAction.addScriptLines(lines, scriptGenOptions, context, placement);
    }

    for (const action of actionGroup.actions) {
      if (action instanceof ActionGroup) {
        this.addScriptGroupLines(lines, action, scriptGenOptions, context, placement);
      } else if (action instanceof Action) {
        action.addScriptLines(lines, scriptGenOptions, context, placement);
      }
      if (scriptGenOptions.addTestIdlePause) {
        ActionGroup.addLine(lines, context.indent, "await test.idle(15);");
      }
    }
  }

  static addScriptLines(lines: string[], actionSet: ActionSet, options: IScriptGenerationOptions) {
    lines.push(AUTOGENERATED_WHOLEFILE_SCRIPT_SEPARATOR);

    lines.push('import * as mc from "@minecraft/server";');

    let subGroupCount = 0;
    let subActionCount = 0;

    for (const childAction of actionSet.actions) {
      if (childAction instanceof ActionGroup) {
        subGroupCount++;
      } else if (childAction instanceof Action) {
        subActionCount++;
      }
    }

    let actionGroupCount = 0;
    if (subGroupCount > 0 && subActionCount === 0) {
      for (const childAction of actionSet.actions) {
        if (childAction instanceof ActionGroup) {
          if (!childAction.name) {
            childAction.name = actionSet.name + "_" + String(actionGroupCount + 1);
          }

          this.addScriptGroupLinesForFunction(lines, childAction, options, { indent: 2 });
          actionGroupCount++;
        }
      }
    } else {
      this.addScriptGroupLinesForFunction(lines, actionSet, options, { indent: 2 });
    }

    this.addInitGroupLines(lines, actionSet, options, { indent: 2 });
  }
}
